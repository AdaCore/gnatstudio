<PREDEFINED_ADA>

   <ATTRIBUTE id = "0" name = "AST_Entry" origin = "GNAT RM" category = "variable">
      <DOC>
This attribute is implemented only in OpenVMS versions of GNAT.
Applied to the name of an entry, it yields a value of the predefined
type AST_Handler (declared in the predefined package System, as
extended by the use of pragma `Extend_System (Aux_DEC)').  This value
enables the given entry to be called when an AST occurs.  For further
details, refer to the `DEC Ada Language Reference Manual', section
9.12a.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Abort_Signal" origin = "GNAT RM" category = "variable">
      <DOC>
`Standard'Abort_Signal' (`Standard' is the only allowed prefix)
provides the entity for the special exception used to signal task abort
or asynchronous transfer of control.  Normally this attribute should
only be used in the tasking runtime (it is highly peculiar, and
completely outside the normal semantics of Ada, for a user program to
intercept the abort exception).
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "2" name = "Access" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix P that denotes a subprogram:

P'Access yields an access value that designates the subprogram
denoted by P. The type of P'Access is an access-to-subprogram
type (S), as determined by the expected type. See 3.10.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "4" name = "Access" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix X that denotes an aliased view of an object:

X'Access yields an access value that designates the object
denoted by X. The type of X'Access is an access-to-object type,
as determined by the expected type. The expected type shall be a
general access type. See 3.10.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "6/1" name = "Address" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix X that denotes an object, program unit, or label:

Denotes the address of the first of the storage elements
allocated to X. For a program unit or label, this value refers
to the machine code associated with the corresponding body or
statement. The value of this attribute is of type
System.Address. See 13.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Address_Size" origin = "GNAT RM" category = "variable">
      <DOC>
`Standard'Address_Size' (`Standard' is the only allowed prefix) is a
static constant giving the number of bits in an `Address'. It is the
same value as System.Address'Size, but has the advantage of being
static, while a direct reference to System.Address'Size is non-static
because Address is a private type.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "8" name = "Adjacent" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

S'Adjacent denotes a function with the following specification:

function S'Adjacent (X, Towards : T)
return T

If Towards = X, the function yields X; otherwise, it yields the
machine number of the type T adjacent to X in the direction of
Towards, if that machine number exists. If the result would be
outside the base range of S, Constraint_Error is raised. When
T'Signed_Zeros is True, a zero result has the sign of X. When
Towards is zero, its sign has no bearing on the result. See
A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "12" name = "Aft" origin = "Ada RM" category = "variable">
      <DOC>
For every fixed point subtype S:

S'Aft yields the number of decimal digits needed after the
decimal point to accommodate the delta of the subtype S, unless
the delta of the subtype S is greater than 0.1, in which case
the attribute yields the value one. (S'Aft is the smallest
positive integer N for which (10**N)*S'Delta is greater than or
equal to one.) The value of this attribute is of the type
universal_integer. See 3.5.10.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "13.1/2" name = "Alignment" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S:

The value of this attribute is of type universal_integer, and
nonnegative.

For an object X of subtype S, if S'Alignment is not zero, then
X'Alignment is a nonzero integral multiple of S'Alignment unless
specified otherwise by a representation item. See 13.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "14/1" name = "Alignment" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix X that denotes an object:

The value of this attribute is of type universal_integer, and
nonnegative; zero means that the object is not necessarily
aligned on a storage element boundary. If X'Alignment is not
zero, then X is aligned on a storage unit boundary and X'Address
is an integral multiple of X'Alignment (that is, the Address
modulo the Alignment is zero).

16/2  This paragraph was deleted. See 13.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Asm_Input" origin = "GNAT RM" category = "function">
      <DOC>
The `Asm_Input' attribute denotes a function that takes two parameters.
The first is a string, the second is an expression of the type
designated by the prefix.  The first (string) argument is required to
be a static expression, and is the constraint for the parameter, (e.g.
what kind of register is required).  The second argument is the value
to be used as the input argument.  The possible values for the constant
are the same as those used in the RTL, and are dependent on the
configuration file used to built the GCC back end.  *Note Machine Code
Insertions::
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Asm_Output" origin = "GNAT RM" category = "function">
      <DOC>
The `Asm_Output' attribute denotes a function that takes two
parameters.  The first is a string, the second is the name of a variable
of the type designated by the attribute prefix.  The first (string)
argument is required to be a static expression and designates the
constraint for the parameter (e.g. what kind of register is required).
The second argument is the variable to be updated with the result.  The
possible values for constraint are the same as those used in the RTL,
and are dependent on the configuration file used to build the GCC back
end.  If there are no output operands, then this argument may either be
omitted, or explicitly given as `No_Output_Operands'.  *Note Machine
Code Insertions::
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "17" name = "Base" origin = "Ada RM" category = "type">
      <DOC>
For every scalar subtype S:

S'Base denotes an unconstrained subtype of the type of S. This
unconstrained subtype is called the base subtype of the type.
See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Bit" origin = "GNAT RM" category = "variable">
      <DOC>
`OBJ'Bit', where OBJ is any object, yields the bit offset within the
storage unit (byte) that contains the first bit of storage allocated
for the object.  The value of this attribute is of the type
`Universal_Integer', and is always a non-negative number not exceeding
the value of `System.Storage_Unit'.

For an object that is a variable or a constant allocated in a
register, the value is zero.  (The use of this attribute does not force
the allocation of a variable to memory).

For an object that is a formal parameter, this attribute applies to
either the matching actual parameter or to a copy of the matching
actual parameter.

For an access object the value is zero.  Note that `OBJ.all'Bit' is
subject to an `Access_Check' for the designated object.  Similarly for
a record component `X.C'Bit' is subject to a discriminant check and
`X(I).Bit' and `X(I1..I2)'Bit' are subject to index checks.

This attribute is designed to be compatible with the DEC Ada 83
definition and implementation of the `Bit' attribute.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "19" name = "Bit_Order" origin = "Ada RM" category = "variable">
      <DOC>
For every specific record subtype S:

Denotes the bit ordering for the type of S. The value of this
attribute is of type System.Bit_Order. See 13.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Bit_Position" origin = "GNAT RM" category = "variable">
      <DOC>
`R.C'Bit_Position', where R is a record object and C is one of the
fields of the record type, yields the bit offset within the record
contains the first bit of storage allocated for the object.  The value
of this attribute is of the type `Universal_Integer'.  The value
depends only on the field C and is independent of the alignment of the
containing record R.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "21/1" name = "Body_Version" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix P that statically denotes a program unit:

Yields a value of the predefined type String that identifies the
version of the compilation unit that contains the body (but not
any subunits) of the program unit. See E.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "23" name = "Callable" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix T that is of a task type (after any implicit
dereference):

Yields the value True when the task denoted by T is callable,
and False otherwise; See 9.9.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "25" name = "Caller" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix E that denotes an entry_declaration:

Yields a value of the type Task_Id that identifies the task
whose call is now being serviced. Use of this attribute is
allowed only inside an entry_body or accept_statement
corresponding to the entry_declaration denoted by E. See C.7.1.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "27" name = "Ceiling" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

S'Ceiling denotes a function with the following specification:

function S'Ceiling (X : T)
return T

The function yields the value Ceiling(X), i.e., the smallest
(most negative) integral value greater than or equal to X. When
X is zero, the result has the sign of X; a zero result otherwise
has a negative sign when S'Signed_Zeros is True. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "31" name = "Class" origin = "Ada RM" category = "type">
      <DOC>
For every subtype S of an untagged private type whose full view
is tagged:

Denotes the class-wide subtype corresponding to the full view of
S. This attribute is allowed only from the beginning of the
private part in which the full view is declared, until the
declaration of the full view. After the full view, the Class
attribute of the full view can be used. See 7.3.1.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "33" name = "Class" origin = "Ada RM" category = "type">
      <DOC>
For every subtype S of a tagged type T (specific or class-wide):

S'Class denotes a subtype of the class-wide type (called T'Class
in this International Standard) for the class rooted at T (or if
S already denotes a class-wide subtype, then S'Class is the same
as S).

S'Class is unconstrained. However, if S is constrained, then the
values of S'Class are only those that when converted to the type
T belong to S. See 3.9.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "92" name = "Class'Input" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S'Class of a class-wide type T'Class:

S'Class'Input denotes a function with the following
specification:

function S'Class'Input(
Stream : not null access Ada.Streams.Root_Stream_Type'Class)
return T'Class

First reads the external tag from Stream and determines the
corresponding internal tag (by calling
Tags.Descendant_Tag(String'Input(Stream), S'Tag) which might
raise Tag_Error - see 3.9) and then dispatches to the subprogram
denoted by the Input attribute of the specific type identified
by the internal tag; returns that result. If the specific type
identified by the internal tag is not covered by T'Class or is
abstract, Constraint_Error is raised. See 13.13.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "165" name = "Class'Output" origin = "Ada RM" category = "procedure">
      <DOC>
For every subtype S'Class of a class-wide type T'Class:

S'Class'Output denotes a procedure with the following
specification:

procedure S'Class'Output(
Stream : not null access Ada.Streams.Root_Stream_Type'Class;
Item   : in T'Class)

First writes the external tag of Item to Stream (by calling
String'Output(Stream, Tags.External_Tag(Item'Tag)) - see 3.9)
and then dispatches to the subprogram denoted by the Output
attribute of the specific type identified by the tag. Tag_Error
is raised if the tag of Item identifies a type declared at an
accessibility level deeper than that of S. See 13.13.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "191" name = "Class'Read" origin = "Ada RM" category = "procedure">
      <DOC>
For every subtype S'Class of a class-wide type T'Class:

S'Class'Read denotes a procedure with the following
specification:

procedure S'Class'Read(
Stream : not null access Ada.Streams.Root_Stream_Type'Class;
Item : out T'Class)

Dispatches to the subprogram denoted by the Read attribute of
the specific type identified by the tag of Item. See 13.13.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "282" name = "Class'Write" origin = "Ada RM" category = "procedure">
      <DOC>
For every subtype S'Class of a class-wide type T'Class:

S'Class'Write denotes a procedure with the following
specification:

procedure S'Class'Write(
Stream : not null access Ada.Streams.Root_Stream_Type'Class;
Item   : in T'Class)

Dispatches to the subprogram denoted by the Write attribute of
the specific type identified by the tag of Item. See 13.13.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Code_Address" origin = "GNAT RM" category = "variable">
      <DOC>
The `'Address' attribute may be applied to subprograms in Ada 95 and
Ada 2005, but the intended effect seems to be to provide an address
value which can be used to call the subprogram by means of an address
clause as in the following example:

procedure K is ...

procedure L;
for L'Address use K'Address;
pragma Import (Ada, L);

A call to `L' is then expected to result in a call to `K'.  In Ada 83,
where there were no access-to-subprogram values, this was a common
work-around for getting the effect of an indirect call.  GNAT
implements the above use of `Address' and the technique illustrated by
the example code works correctly.

However, for some purposes, it is useful to have the address of the
start of the generated code for the subprogram.  On some architectures,
this is not necessarily the same as the `Address' value described above.
For example, the `Address' value may reference a subprogram descriptor
rather than the subprogram itself.

The `'Code_Address' attribute, which can only be applied to
subprogram entities, always returns the address of the start of the
generated code of the specified subprogram, which may or may not be the
same value as is returned by the corresponding `'Address' attribute.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Compiler_Version" origin = "GNAT RM" category = "variable">
      <DOC>
`Standard'Compiler_Version' (`Standard' is the only allowed prefix)
yields a static string identifying the version of the compiler being
used to compile the unit containing the attribute reference. A typical
result would be something like "GNAT Pro 6.3.0w (20090221)".
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "36/1" name = "Component_Size" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix X that denotes an array subtype or array object
(after any implicit dereference):

Denotes the size in bits of components of the type of X. The
value of this attribute is of type universal_integer. See 13.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "38" name = "Compose" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S of a floating point type T:

S'Compose denotes a function with the following specification:

function S'Compose (Fraction : T;
Exponent : universal_integer)
return T

Let v be the value Fraction x T'Machine_Radix(Exponent-k), where
k is the normalized exponent of Fraction. If v is a machine
number of the type T, or if |v| >= T'Model_Small, the function
yields v; otherwise, it yields either one of the machine numbers
of the type T adjacent to v. Constraint_Error is optionally
raised if v is outside the base range of S. A zero result has
the sign of Fraction when S'Signed_Zeros is True. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "42" name = "Constrained" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix A that is of a discriminated type (after any
implicit dereference):

Yields the value True if A denotes a constant, a value, or a
constrained variable, and False otherwise. See 3.7.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "44" name = "Copy_Sign" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S of a floating point type T:

S'Copy_Sign denotes a function with the following specification:

function S'Copy_Sign (Value, Sign : T)
return T

If the value of Value is nonzero, the function yields a result
whose magnitude is that of Value and whose sign is that of Sign;
otherwise, it yields the value zero. Constraint_Error is
optionally raised if the result is outside the base range of S.
A zero result has the sign of Sign when S'Signed_Zeros is True.
See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "48" name = "Count" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix E that denotes an entry of a task or protected unit:

Yields the number of calls presently queued on the entry E of
the current instance of the unit. The value of this attribute is
of the type universal_integer. See 9.9.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Default_Bit_Order" origin = "GNAT RM" category = "variable">
      <DOC>
`Standard'Default_Bit_Order' (`Standard' is the only permissible
prefix), provides the value `System.Default_Bit_Order' as a `Pos' value
(0 for `High_Order_First', 1 for `Low_Order_First').  This is used to
construct the definition of `Default_Bit_Order' in package `System'.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "50/1" name = "Definite" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix S that denotes a formal indefinite subtype:

S'Definite yields True if the actual subtype corresponding to S
is definite; otherwise it yields False. The value of this
attribute is of the predefined type Boolean. See 12.5.1.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "52" name = "Delta" origin = "Ada RM" category = "variable">
      <DOC>
For every fixed point subtype S:

S'Delta denotes the delta of the fixed point subtype S. The
value of this attribute is of the type universal_real. See
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "54" name = "Denorm" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

Yields the value True if every value expressible in the form
+- mantissa x T'Machine_Radix(T'Machine_Emin)
where mantissa is a nonzero T'Machine_Mantissa-digit fraction in
the number base T'Machine_Radix, the first digit of which is
zero, is a machine number (see 3.5.7) of the type T; yields the
value False otherwise. The value of this attribute is of the
predefined type Boolean. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "56" name = "Digits" origin = "Ada RM" category = "variable">
      <DOC>
For every decimal fixed point subtype S:

S'Digits denotes the digits of the decimal fixed point subtype
S, which corresponds to the number of decimal digits that are
representable in objects of the subtype. The value of this
attribute is of the type universal_integer. See 3.5.10.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "58" name = "Digits" origin = "Ada RM" category = "variable">
      <DOC>
For every floating point subtype S:

S'Digits denotes the requested decimal precision for the subtype
S. The value of this attribute is of the type universal_integer.
See 3.5.8.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Elab_Body" origin = "GNAT RM" category = "procedure">
      <DOC>
This attribute can only be applied to a program unit name.  It returns
the entity for the corresponding elaboration procedure for elaborating
the body of the referenced unit.  This is used in the main generated
elaboration procedure by the binder and is not normally used in any
other context.  However, there may be specialized situations in which it
is useful to be able to call this elaboration procedure from Ada code,
e.g. if it is necessary to do selective re-elaboration to fix some
error.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Elab_Spec" origin = "GNAT RM" category = "procedure">
      <DOC>
This attribute can only be applied to a program unit name.  It returns
the entity for the corresponding elaboration procedure for elaborating
the spec of the referenced unit.  This is used in the main generated
elaboration procedure by the binder and is not normally used in any
other context.  However, there may be specialized situations in which
it is useful to be able to call this elaboration procedure from Ada
code, e.g. if it is necessary to do selective re-elaboration to fix
some error.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Elaborated" origin = "GNAT RM" category = "variable">
      <DOC>
The prefix of the `'Elaborated' attribute must be a unit name.  The
value is a Boolean which indicates whether or not the given unit has
been elaborated.  This attribute is primarily intended for internal use
by the generated code for dynamic elaboration checking, but it can also
be used in user programs.  The value will always be True once
elaboration of all units has been completed.  An exception is for units
which need no elaboration, the value is always False for such units.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Emax" origin = "GNAT RM" category = "variable">
      <DOC>
The `Emax' attribute is provided for compatibility with Ada 83.  See
the Ada 83 reference manual for an exact description of the semantics of
this attribute.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Enabled" origin = "GNAT RM" category = "variable">
      <DOC>
The `Enabled' attribute allows an application program to check at
compile time to see if the designated check is currently enabled. The
prefix is a simple identifier, referencing any predefined check name
(other than `All_Checks') or a check name introduced by pragma
Check_Name. If no argument is given for the attribute, the check is for
the general state of the check, if an argument is given, then it is an
entity name, and the check indicates whether an `Suppress' or
`Unsuppress' has been given naming the entity (if not, then the
argument is ignored).

Note that instantiations inherit the check status at the point of the
instantiation, so a useful idiom is to have a library package that
introduces a check name with `pragma Check_Name', and then contains
generic packages or subprograms which use the `Enabled' attribute to
see if the check is enabled. A user of this package can then issue a
`pragma Suppress' or `pragma Unsuppress' before instantiating the
package or subprogram, controlling whether the check will be present.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Enum_Rep" origin = "GNAT RM" category = "function">
      <DOC>
For every enumeration subtype S, `S'Enum_Rep' denotes a function with
the following spec:

function S'Enum_Rep (Arg : S'Base)
return Universal_Integer;

It is also allowable to apply `Enum_Rep' directly to an object of an
enumeration type or to a non-overloaded enumeration literal.  In this
case `S'Enum_Rep' is equivalent to `TYP'Enum_Rep(S)' where TYP is the
type of the enumeration literal or object.

The function returns the representation value for the given
enumeration value.  This will be equal to value of the `Pos' attribute
in the absence of an enumeration representation clause.  This is a
static attribute (i.e. the result is static if the argument is static).

`S'Enum_Rep' can also be used with integer types and objects, in
which case it simply returns the integer value.  The reason for this is
to allow it to be used for `(&lt;&gt;)' discrete formal arguments in a
generic unit that can be instantiated with either enumeration types or
integer types.  Note that if `Enum_Rep' is used on a modular type whose
upper bound exceeds the upper bound of the largest signed integer type,
and the argument is a variable, so that the universal integer
calculation is done at run time, then the call to `Enum_Rep' may raise
`Constraint_Error'.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Enum_Val" origin = "GNAT RM" category = "function">
      <DOC>
For every enumeration subtype S, `S'Enum_Val' denotes a function with
the following spec:

function S'Enum_Val (Arg : Universal_Integer)
return S'Base;

The function returns the enumeration value whose representation matches
the argument, or raises Constraint_Error if no enumeration literal of
the type has the matching value.  This will be equal to value of the
`Val' attribute in the absence of an enumeration representation clause.
This is a static attribute (i.e. the result is static if the argument
is static).
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Epsilon" origin = "GNAT RM" category = "variable">
      <DOC>
The `Epsilon' attribute is provided for compatibility with Ada 83.  See
the Ada 83 reference manual for an exact description of the semantics of
this attribute.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "60" name = "Exponent" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S of a floating point type T:

S'Exponent denotes a function with the following specification:

function S'Exponent (X : T)
return universal_integer

The function yields the normalized exponent of X. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "64" name = "External_Tag" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a tagged type T (specific or class-wide):

S'External_Tag denotes an external string representation for
S'Tag; it is of the predefined type String. External_Tag may be
specified for a specific tagged type via an
attribute_definition_clause; the expression of such a clause
shall be static. The default external tag representation is
implementation defined. See 3.9.2 and 13.13.2. See 13.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "66/1" name = "First" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

A'First denotes the lower bound of the first index range; its
type is the corresponding index type. See 3.6.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "68" name = "First" origin = "Ada RM" category = "variable">
      <DOC>
For every scalar subtype S:

S'First denotes the lower bound of the range of S. The value of
this attribute is of the type of S. See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "70/1" name = "First(N)" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

A'First(N) denotes the lower bound of the N-th index range; its
type is the corresponding index type. See 3.6.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "72" name = "First_Bit" origin = "Ada RM" category = "variable">
      <DOC>
For a component C of a composite, non-array object R:

If the nondefault bit ordering applies to the composite type,
and if a component_clause specifies the placement of C, denotes
the value given for the first_bit of the component_clause;
otherwise, denotes the offset, from the start of the first of
the storage elements occupied by C, of the first bit occupied by
C. This offset is measured in bits. The first bit of a storage
element is numbered zero. The value of this attribute is of the
type universal_integer. See 13.5.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Fixed_Value" origin = "GNAT RM" category = "function">
      <DOC>
For every fixed-point type S, `S'Fixed_Value' denotes a function with
the following specification:

function S'Fixed_Value (Arg : Universal_Integer)
return S;

The value returned is the fixed-point value V such that

V = Arg * S'Small

The effect is thus similar to first converting the argument to the
integer type used to represent S, and then doing an unchecked
conversion to the fixed-point type.  The difference is that there are
full range checks, to ensure that the result is in range.  This
attribute is primarily intended for use in implementation of the
input-output functions for fixed-point values.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "74" name = "Floor" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S of a floating point type T:

S'Floor denotes a function with the following specification:

function S'Floor (X : T)
return T

The function yields the value Floor(X), i.e., the largest (most
positive) integral value less than or equal to X. When X is
zero, the result has the sign of X; a zero result otherwise has
a positive sign. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "78" name = "Fore" origin = "Ada RM" category = "variable">
      <DOC>
For every fixed point subtype S:

S'Fore yields the minimum number of characters needed before the
decimal point for the decimal representation of any value of the
subtype S, assuming that the representation does not include an
exponent, but includes a one-character prefix that is either a
minus sign or a space. (This minimum number does not include
superfluous zeros or underlines, and is at least 2.) The value
of this attribute is of the type universal_integer. See 3.5.10.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "80" name = "Fraction" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S of a floating point type T:

S'Fraction denotes a function with the following specification:

function S'Fraction (X : T)
return T

The function yields the value X x T'Machine_Radix(-k), where k
is the normalized exponent of X. A zero result, which can only
occur when X is zero, has the sign of X. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Has_Access_Values" origin = "GNAT RM" category = "variable">
      <DOC>
The prefix of the `Has_Access_Values' attribute is a type.  The result
is a Boolean value which is True if the is an access type, or is a
composite type with a component (at any nesting depth) that is an
access type, and is False otherwise.  The intended use of this
attribute is in conjunction with generic definitions.  If the attribute
is applied to a generic private type, it indicates whether or not the
corresponding actual type has access values.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Has_Discriminants" origin = "GNAT RM" category = "variable">
      <DOC>
The prefix of the `Has_Discriminants' attribute is a type.  The result
is a Boolean value which is True if the type has discriminants, and
False otherwise.  The intended use of this attribute is in conjunction
with generic definitions.  If the attribute is applied to a generic
private type, it indicates whether or not the corresponding actual type
has discriminants.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "84" name = "Identity" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix T that is of a task type (after any implicit
dereference):

Yields a value of the type Task_Id that identifies the task
denoted by T. See C.7.1.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "86/1" name = "Identity" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix E that denotes an exception:

E'Identity returns the unique identity of the exception. The
type of this attribute is Exception_Id. See 11.4.1.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "88" name = "Image" origin = "Ada RM" category = "function">
      <DOC>
For every scalar subtype S:

S'Image denotes a function with the following specification:

function S'Image(Arg : S'Base)
return String

The function returns an image of the value of Arg as a String.
See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Img" origin = "GNAT RM" category = "function">
      <DOC>
The `Img' attribute differs from `Image' in that it may be applied to
objects as well as types, in which case it gives the `Image' for the
subtype of the object.  This is convenient for debugging:

Put_Line ("X = " &amp; X'Img);

has the same meaning as the more verbose:

Put_Line ("X = " &amp; T'Image (X));

where T is the (sub)type of the object `X'.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "96" name = "Input" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S of a specific type T:

S'Input denotes a function with the following specification:

function S'Input(
Stream : not null access Ada.Streams.Root_Stream_Type'Class)
return T

S'Input reads and returns one value from Stream, using any
bounds or discriminants written by a corresponding S'Output to
determine how much to read. See 13.13.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Integer_Value" origin = "GNAT RM" category = "function">
      <DOC>
For every integer type S, `S'Integer_Value' denotes a function with the
following spec:

function S'Integer_Value (Arg : Universal_Fixed)
return S;

The value returned is the integer value V, such that

Arg = V * T'Small

where T is the type of `Arg'.  The effect is thus similar to first
doing an unchecked conversion from the fixed-point type to its
corresponding implementation type, and then converting the result to
the target integer type.  The difference is that there are full range
checks, to ensure that the result is in range.  This attribute is
primarily intended for use in implementation of the standard
input-output functions for fixed-point values.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Invalid_Value" origin = "GNAT RM" category = "variable">
      <DOC>
For every scalar type S, S'Invalid_Value returns an undefined value of
the type. If possible this value is an invalid representation for the
type. The value returned is identical to the value used to initialize
an otherwise uninitialized value of the type if pragma
Initialize_Scalars is used, including the ability to modify the value
with the binder -Sxx flag and relevant environment variables at run
time.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Large" origin = "GNAT RM" category = "variable">
      <DOC>
The `Large' attribute is provided for compatibility with Ada 83.  See
the Ada 83 reference manual for an exact description of the semantics of
this attribute.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "100/1" name = "Last" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

A'Last denotes the upper bound of the first index range; its
type is the corresponding index type. See 3.6.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "102" name = "Last" origin = "Ada RM" category = "variable">
      <DOC>
For every scalar subtype S:

S'Last denotes the upper bound of the range of S. The value of
this attribute is of the type of S. See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "104/1" name = "Last(N)" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

A'Last(N) denotes the upper bound of the N-th index range; its
type is the corresponding index type. See 3.6.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "106" name = "Last_Bit" origin = "Ada RM" category = "variable">
      <DOC>
For a component C of a composite, non-array object R:

If the nondefault bit ordering applies to the composite type,
and if a component_clause specifies the placement of C, denotes
the value given for the last_bit of the component_clause;
otherwise, denotes the offset, from the start of the first of
the storage elements occupied by C, of the last bit occupied by
C. This offset is measured in bits. The value of this attribute
is of the type universal_integer. See 13.5.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "108" name = "Leading_Part" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S of a floating point type T:

S'Leading_Part denotes a function with the following
specification:

function S'Leading_Part (X : T;
Radix_Digits : universal_integer)
return T

Let v be the value T'Machine_Radix(k-Radix_Digits), where k is
the normalized exponent of X. The function yields the value

Floor(X/v) x v, when X is nonnegative and Radix_Digits is
positive;

Ceiling(X/v) x v, when X is negative and Radix_Digits is
positive.

Constraint_Error is raised when Radix_Digits is zero or
negative. A zero result, which can only occur when X is zero,
has the sign of X. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "115/1" name = "Length" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

A'Length denotes the number of values of the first index range
(zero for a null range); its type is universal_integer. See
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "117/1" name = "Length(N)" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

A'Length(N) denotes the number of values of the N-th index range
(zero for a null range); its type is universal_integer. See
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "119" name = "Machine" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S of a floating point type T:

S'Machine denotes a function with the following specification:

function S'Machine (X : T)
return T

If X is a machine number of the type T, the function yields X;
otherwise, it yields the value obtained by rounding or
truncating X to either one of the adjacent machine numbers of
the type T. Constraint_Error is raised if rounding or truncating
X to the precision of the machine numbers results in a value
outside the base range of S. A zero result has the sign of X
when S'Signed_Zeros is True. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "123" name = "Machine_Emax" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

Yields the largest (most positive) value of exponent such that
every value expressible in the canonical form (for the type T),
having a mantissa of T'Machine_Mantissa digits, is a machine
number (see 3.5.7) of the type T. This attribute yields a value
of the type universal_integer. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "125" name = "Machine_Emin" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

Yields the smallest (most negative) value of exponent such that
every value expressible in the canonical form (for the type T),
having a mantissa of T'Machine_Mantissa digits, is a machine
number (see 3.5.7) of the type T. This attribute yields a value
of the type universal_integer. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "127" name = "Machine_Mantissa" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

Yields the largest value of p such that every value expressible
in the canonical form (for the type T), having a p-digit
mantissa and an exponent between T'Machine_Emin and
T'Machine_Emax, is a machine number (see 3.5.7) of the type T.
This attribute yields a value of the type universal_integer. See
A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "129" name = "Machine_Overflows" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a fixed point type T:

Yields the value True if overflow and divide-by-zero are
detected and reported by raising Constraint_Error for every
predefined operation that yields a result of the type T; yields
the value False otherwise. The value of this attribute is of the
predefined type Boolean. See A.5.4.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "131" name = "Machine_Overflows" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

Yields the value True if overflow and divide-by-zero are
detected and reported by raising Constraint_Error for every
predefined operation that yields a result of the type T; yields
the value False otherwise. The value of this attribute is of the
predefined type Boolean. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "133" name = "Machine_Radix" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a fixed point type T:

Yields the radix of the hardware representation of the type T.
The value of this attribute is of the type universal_integer.
See A.5.4.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "135" name = "Machine_Radix" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

Yields the radix of the hardware representation of the type T.
The value of this attribute is of the type universal_integer.
See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "136.1/2" name = "Machine_Rounding" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S of a floating point type T:

S'Machine_Rounding denotes a function with the following
specification:

function S'Machine_Rounding (X : T)
return T

The function yields the integral value nearest to X. If X lies
exactly halfway between two integers, one of those integers is
returned, but which of them is returned is unspecified. A zero
result has the sign of X when S'Signed_Zeros is True. This
function provides access to the rounding behavior which is most
efficient on the target processor. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "137" name = "Machine_Rounds" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a fixed point type T:

Yields the value True if rounding is performed on inexact
results of every predefined operation that yields a result of
the type T; yields the value False otherwise. The value of this
attribute is of the predefined type Boolean. See A.5.4.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "139" name = "Machine_Rounds" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

Yields the value True if rounding is performed on inexact
results of every predefined operation that yields a result of
the type T; yields the value False otherwise. The value of this
attribute is of the predefined type Boolean. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Machine_Size" origin = "GNAT RM" category = "variable">
      <DOC>
This attribute is identical to the `Object_Size' attribute.  It is
provided for compatibility with the DEC Ada 83 attribute of this name.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Mantissa" origin = "GNAT RM" category = "variable">
      <DOC>
The `Mantissa' attribute is provided for compatibility with Ada 83.  See
the Ada 83 reference manual for an exact description of the semantics of
this attribute.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "141" name = "Max" origin = "Ada RM" category = "function">
      <DOC>
For every scalar subtype S:

S'Max denotes a function with the following specification:

function S'Max(Left, Right : S'Base)
return S'Base

The function returns the greater of the values of the two
parameters. See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Max_Interrupt_Priority" origin = "GNAT RM" category = "variable">
      <DOC>
`Standard'Max_Interrupt_Priority' (`Standard' is the only permissible
prefix), provides the same value as `System.Max_Interrupt_Priority'.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Max_Priority" origin = "GNAT RM" category = "variable">
      <DOC>
`Standard'Max_Priority' (`Standard' is the only permissible prefix)
provides the same value as `System.Max_Priority'.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "145" name = "Max_Size_In_Storage_Elements" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S:

Denotes the maximum value for Size_In_Storage_Elements that
could be requested by the implementation via Allocate for an
access type whose designated subtype is S. For a type with
access discriminants, if the implementation allocates space for
a coextension in the same pool as that of the object having the
access discriminant, then this accounts for any calls on
Allocate that could be performed to provide space for such
coextensions. The value of this attribute is of type
universal_integer. See 13.11.1.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Maximum_Alignment" origin = "GNAT RM" category = "variable">
      <DOC>
`Standard'Maximum_Alignment' (`Standard' is the only permissible
prefix) provides the maximum useful alignment value for the target.
This is a static value that can be used to specify the alignment for an
object, guaranteeing that it is properly aligned in all cases.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Mechanism_Code" origin = "GNAT RM" category = "variable">
      <DOC>
`FUNCTION'Mechanism_Code' yields an integer code for the mechanism used
for the result of function, and `SUBPROGRAM'Mechanism_Code (N)' yields
the mechanism used for formal parameter number N (a static integer
value with 1 meaning the first parameter) of SUBPROGRAM.  The code
returned is:

by copy (value)

by reference

by descriptor (default descriptor class)

by descriptor (UBS: unaligned bit string)

by descriptor (UBSB: aligned bit string with arbitrary bounds)

by descriptor (UBA: unaligned bit array)

by descriptor (S: string, also scalar access type parameter)

by descriptor (SB: string with arbitrary bounds)

by descriptor (A: contiguous array)

by descriptor (NCA: non-contiguous array)

Values from 3 through 10 are only relevant to Digital OpenVMS
implementations.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "147" name = "Min" origin = "Ada RM" category = "function">
      <DOC>
For every scalar subtype S:

S'Min denotes a function with the following specification:

function S'Min(Left, Right : S'Base)
return S'Base

The function returns the lesser of the values of the two
parameters. See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "150.1/2" name = "Mod" origin = "Ada RM" category = "function">
      <DOC>
For every modular subtype S:

S'Mod denotes a function with the following specification:

function S'Mod (Arg : universal_integer)
return S'Base

This function returns Arg mod S'Modulus, as a value of the
type of S. See 3.5.4.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "151" name = "Model" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S of a floating point type T:

S'Model denotes a function with the following specification:

function S'Model (X : T)
return T

If the Numerics Annex is not supported, the meaning of this
attribute is implementation defined; see G.2.2 for the
definition that applies to implementations supporting the
Numerics Annex. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "155" name = "Model_Emin" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

If the Numerics Annex is not supported, this attribute yields an
implementation defined value that is greater than or equal to
the value of T'Machine_Emin. See G.2.2 for further requirements
that apply to implementations supporting the Numerics Annex. The
value of this attribute is of the type universal_integer. See
A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "157" name = "Model_Epsilon" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

Yields the value T'Machine_Radix(1 - T'Model_Mantissa). The
value of this attribute is of the type universal_real. See
A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "159" name = "Model_Mantissa" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

If the Numerics Annex is not supported, this attribute yields an
implementation defined value that is greater than or equal to
Ceiling(d x log(10) / log(T'Machine_Radix)) + 1, where d is the
requested decimal precision of T, and less than or equal to the
value of T'Machine_Mantissa. See G.2.2 for further requirements
that apply to implementations supporting the Numerics Annex. The
value of this attribute is of the type universal_integer. See
A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "161" name = "Model_Small" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

Yields the value T'Machine_Radix(T'Model_Emin - 1). The value of
this attribute is of the type universal_real. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "163" name = "Modulus" origin = "Ada RM" category = "variable">
      <DOC>
For every modular subtype S:

S'Modulus yields the modulus of the type of S, as a value of the
type universal_integer. See 3.5.4.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Null_Parameter" origin = "GNAT RM" category = "variable">
      <DOC>
A reference `T'Null_Parameter' denotes an imaginary object of type or
subtype T allocated at machine address zero.  The attribute is allowed
only as the default expression of a formal parameter, or as an actual
expression of a subprogram call.  In either case, the subprogram must
be imported.

The identity of the object is represented by the address zero in the
argument list, independent of the passing mechanism (explicit or
default).

This capability is needed to specify that a zero address should be
passed for a record or other composite object passed by reference.
There is no way of indicating this without the `Null_Parameter'
attribute.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Object_Size" origin = "GNAT RM" category = "variable">
      <DOC>
The size of an object is not necessarily the same as the size of the
type of an object.  This is because by default object sizes are
increased to be a multiple of the alignment of the object.  For example,
`Natural'Size' is 31, but by default objects of type `Natural' will
have a size of 32 bits.  Similarly, a record containing an integer and
a character:

type Rec is record
I : Integer;
C : Character;
end record;

will have a size of 40 (that is `Rec'Size' will be 40).  The alignment
will be 4, because of the integer field, and so the default size of
record objects for this type will be 64 (8 bytes).
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Old" origin = "GNAT RM" category = "variable">
      <DOC>
The attribute Prefix'Old can be used within a subprogram body or within
a precondition or postcondition pragma. The effect is to refer to the
value of the prefix on entry. So for example if you have an argument of
a record type X called Arg1, you can refer to Arg1.Field'Old which
yields the value of Arg1.Field on entry. The implementation simply
involves generating an object declaration which captures the value on
entry. Any prefix is allowed except one of a limited type (since limited
types cannot be copied to capture their values) or an expression which
references a local variable (since local variables do not exist at
subprogram entry time).

The following example shows the use of 'Old to implement a test of a
postcondition:

with Old_Pkg;
procedure Old is
begin
Old_Pkg.Incr;
end Old;

package Old_Pkg is
procedure Incr;
end Old_Pkg;

package body Old_Pkg is
Count : Natural := 0;

procedure Incr is
begin
code manipulating the value of Count

pragma Assert (Count = Count'Old + 1);
end Incr;
end Old_Pkg;

Note that it is allowed to apply 'Old to a constant entity, but this
will result in a warning, since the old and new values will always be
the same.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "169" name = "Output" origin = "Ada RM" category = "procedure">
      <DOC>
For every subtype S of a specific type T:

S'Output denotes a procedure with the following specification:

procedure S'Output(
Stream : not null access Ada.Streams.Root_Stream_Type'Class;
Item : in T)

S'Output writes the value of Item to Stream, including any
bounds or discriminants. See 13.13.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "173/1" name = "Partition_Id" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix D that denotes a library-level declaration,
excepting a declaration of or within a declared-pure library
unit:

Denotes a value of the type universal_integer that identifies
the partition in which D was elaborated. If D denotes the
declaration of a remote call interface library unit (see E.2.3)
the given partition is the one where the body of D was
elaborated. See E.1.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Passed_By_Reference" origin = "GNAT RM" category = "variable">
      <DOC>
`TYPE'Passed_By_Reference' for any subtype TYPE returns a value of type
`Boolean' value that is `True' if the type is normally passed by
reference and `False' if the type is normally passed by copy in calls.
For scalar types, the result is always `False' and is static.  For
non-scalar types, the result is non-static.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Pool_Address" origin = "GNAT RM" category = "variable">
      <DOC>
`X'Pool_Address' for any object X returns the address of X within its
storage pool. This is the same as `X'Address', except that for an
unconstrained array whose bounds are allocated just before the first
component, `X'Pool_Address' returns the address of those bounds,
whereas `X'Address' returns the address of the first component.

Here, we are interpreting "storage pool" broadly to mean "wherever
the object is allocated", which could be a user-defined storage pool,
the global heap, on the stack, or in a static memory area. For an
object created by `new', `PTR.ALL'Pool_Address' is what is passed to
`Allocate' and returned from `Deallocate'.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "175" name = "Pos" origin = "Ada RM" category = "function">
      <DOC>
For every discrete subtype S:

S'Pos denotes a function with the following specification:

function S'Pos(Arg : S'Base)
return universal_integer

This function returns the position number of the value of Arg,
as a value of type universal_integer. See 3.5.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "179" name = "Position" origin = "Ada RM" category = "variable">
      <DOC>
For a component C of a composite, non-array object R:

If the nondefault bit ordering applies to the composite type,
and if a component_clause specifies the placement of C, denotes
the value given for the position of the component_clause;
otherwise, denotes the same value as R.C'Address - R'Address.
The value of this attribute is of the type universal_integer.
See 13.5.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "181" name = "Pred" origin = "Ada RM" category = "function">
      <DOC>
For every scalar subtype S:

S'Pred denotes a function with the following specification:

function S'Pred(Arg : S'Base)
return S'Base

For an enumeration type, the function returns the value whose
position number is one less than that of the value of Arg;
Constraint_Error is raised if there is no such value of the
type. For an integer type, the function returns the result of
subtracting one from the value of Arg. For a fixed point type,
the function returns the result of subtracting small from the
value of Arg. For a floating point type, the function returns
the machine number (as defined in 3.5.7) immediately below the
value of Arg; Constraint_Error is raised if there is no such
machine number. See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "184.1/2" name = "Priority" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix P that denotes a protected object:

Denotes a non-aliased component of the protected object P.
This component is of type System.Any_Priority and its value is
the priority of P. P'Priority denotes a variable if and only if
P denotes a variable. A reference to this attribute shall appear
only within the body of P. See D.5.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "185/1" name = "Range" origin = "Ada RM" category = "type">
      <DOC>
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

A'Range is equivalent to the range A'First .. A'Last, except
that the prefix A is only evaluated once. See 3.6.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "187" name = "Range" origin = "Ada RM" category = "type">
      <DOC>
For every scalar subtype S:

S'Range is equivalent to the range S'First .. S'Last. See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "189/1" name = "Range(N)" origin = "Ada RM" category = "type">
      <DOC>
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

A'Range(N) is equivalent to the range A'First(N) .. A'Last(N),
except that the prefix A is only evaluated once. See 3.6.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Range_Length" origin = "GNAT RM" category = "variable">
      <DOC>
`TYPE'Range_Length' for any discrete type TYPE yields the number of
values represented by the subtype (zero for a null range).  The result
is static for static subtypes.  `Range_Length' applied to the index
subtype of a one dimensional array always gives the same result as
`Range' applied to the array itself.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "195" name = "Read" origin = "Ada RM" category = "procedure">
      <DOC>
For every subtype S of a specific type T:

S'Read denotes a procedure with the following specification:

procedure S'Read(
Stream : not null access Ada.Streams.Root_Stream_Type'Class;
Item : out T)

S'Read reads the value of Item from Stream. See 13.13.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Ref" origin = "GNAT RM" category = "unknown">
      <DOC>
The `System.Address'Ref' (`System.Address' is the only permissible
prefix) denotes a function identical to
`System.Storage_Elements.To_Address' except that it is a static
attribute.  See *Note To_Address:: for more details.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "199" name = "Remainder" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S of a floating point type T:

S'Remainder denotes a function with the following specification:

function S'Remainder (X, Y : T)
return T

For nonzero Y, let v be the value X - n x Y, where n is the
integer nearest to the exact value of X/Y; if |n - X/Y| = 1/2,
then n is chosen to be even. If v is a machine number of the
type T, the function yields v; otherwise, it yields zero.
Constraint_Error is raised if Y is zero. A zero result has the
sign of X when S'Signed_Zeros is True. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Result" origin = "GNAT RM" category = "variable">
      <DOC>
`FUNCTION'Result' can only be used with in a Postcondition pragma for a
function. The prefix must be the name of the corresponding function.
This is used to refer to the result of the function in the
postcondition expression.  For a further discussion of the use of this
attribute and examples of its use, see the description of pragma
Postcondition.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "203" name = "Round" origin = "Ada RM" category = "function">
      <DOC>
For every decimal fixed point subtype S:

S'Round denotes a function with the following specification:

function S'Round(X : universal_real)
return S'Base

The function returns the value obtained by rounding X (away from
, if X is midway between two values of the type of S). See
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "207" name = "Rounding" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S of a floating point type T:

S'Rounding denotes a function with the following specification:

function S'Rounding (X : T)
return T

The function yields the integral value nearest to X, rounding
away from zero if X lies exactly halfway between two integers. A
zero result has the sign of X when S'Signed_Zeros is True. See
A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Safe_Emax" origin = "GNAT RM" category = "variable">
      <DOC>
The `Safe_Emax' attribute is provided for compatibility with Ada 83.
See the Ada 83 reference manual for an exact description of the
semantics of this attribute.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "211" name = "Safe_First" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

Yields the lower bound of the safe range (see 3.5.7) of the type
T. If the Numerics Annex is not supported, the value of this
attribute is implementation defined; see G.2.2 for the
definition that applies to implementations supporting the
Numerics Annex. The value of this attribute is of the type
universal_real. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Safe_Large" origin = "GNAT RM" category = "variable">
      <DOC>
The `Safe_Large' attribute is provided for compatibility with Ada 83.
See the Ada 83 reference manual for an exact description of the
semantics of this attribute.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "213" name = "Safe_Last" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

Yields the upper bound of the safe range (see 3.5.7) of the type
T. If the Numerics Annex is not supported, the value of this
attribute is implementation defined; see G.2.2 for the
definition that applies to implementations supporting the
Numerics Annex. The value of this attribute is of the type
universal_real. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "215" name = "Scale" origin = "Ada RM" category = "variable">
      <DOC>
For every decimal fixed point subtype S:

S'Scale denotes the scale of the subtype S, defined as the value
N such that S'Delta = 10.0**(-N). The scale indicates the
position of the point relative to the rightmost significant
digits of values of subtype S. The value of this attribute is of
the type universal_integer. See 3.5.10.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "217" name = "Scaling" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S of a floating point type T:

S'Scaling denotes a function with the following specification:

function S'Scaling (X : T;
Adjustment : universal_integer)
return T

Let v be the value X x T'Machine_Radix(Adjustment). If v is a
machine number of the type T, or if |v| >= T'Model_Small, the
function yields v; otherwise, it yields either one of the
machine numbers of the type T adjacent to v. Constraint_Error is
optionally raised if v is outside the base range of S. A zero
result has the sign of X when S'Signed_Zeros is True. See
A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "221" name = "Signed_Zeros" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a floating point type T:

Yields the value True if the hardware representation for the
type T has the capability of representing both positively and
negatively signed zeros, these being generated and used by the
predefined operations of the type T as specified in IEC
:1989; yields the value False otherwise. The value of this
attribute is of the predefined type Boolean. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "223" name = "Size" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S:

If S is definite, denotes the size (in bits) that the
implementation would choose for the following objects of subtype
S:

A record component of subtype S when the record type is
packed.

The formal parameter of an instance of Unchecked_Conversion
that converts from subtype S to some other subtype.

If S is indefinite, the meaning is implementation defined. The
value of this attribute is of the type universal_integer. See
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "228/1" name = "Size" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix X that denotes an object:

Denotes the size in bits of the representation of the object.
The value of this attribute is of the type universal_integer.
See 13.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Small" origin = "GNAT RM" category = "variable">
      <DOC>
The `Small' attribute is defined in Ada 95 (and Ada 2005) only for
fixed-point types.  GNAT also allows this attribute to be applied to
floating-point types for compatibility with Ada 83.  See the Ada 83
reference manual for an exact description of the semantics of this
attribute when applied to floating-point types.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "230" name = "Small" origin = "Ada RM" category = "variable">
      <DOC>
For every fixed point subtype S:

S'Small denotes the small of the type of S. The value of this
attribute is of the type universal_real. See 3.5.10.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "232" name = "Storage_Pool" origin = "Ada RM" category = "variable">
      <DOC>
For every access-to-object subtype S:

Denotes the storage pool of the type of S. The type of this
attribute is Root_Storage_Pool'Class. See 13.11.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "234" name = "Storage_Size" origin = "Ada RM" category = "variable">
      <DOC>
For every access-to-object subtype S:

Yields the result of calling Storage_Size(S'Storage_Pool), which
is intended to be a measure of the number of storage elements
reserved for the pool. The type of this attribute is
universal_integer. See 13.11.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "236/1" name = "Storage_Size" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix T that denotes a task object (after any implicit
dereference):

Denotes the number of storage elements reserved for the task.
The value of this attribute is of the type universal_integer.
The Storage_Size includes the size of the task's stack, if any.
The language does not specify whether or not it includes other
storage associated with the task (such as the "task control
block" used by some implementations.) See 13.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Storage_Unit" origin = "GNAT RM" category = "variable">
      <DOC>
`Standard'Storage_Unit' (`Standard' is the only permissible prefix)
provides the same value as `System.Storage_Unit'.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "237.1/2" name = "Stream_Size" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of an elementary type T:

Denotes the number of bits occupied in a stream by items of
subtype S. Hence, the number of stream elements required per
item of elementary type T is:

T'Stream_Size / Ada.Streams.Stream_Element'Size

The value of this attribute is of type universal_integer and
is a multiple of Stream_Element'Size. See 13.13.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Stub_Type" origin = "GNAT RM" category = "type">
      <DOC>
The GNAT implementation of remote access-to-classwide types is
organized as described in AARM section E.4 (20.t): a value of an RACW
type (designating a remote object) is represented as a normal access
value, pointing to a "stub" object which in turn contains the necessary
information to contact the designated remote object. A call on any
dispatching operation of such a stub object does the remote call, if
necessary, using the information in the stub object to locate the
target partition, etc.

For a prefix `T' that denotes a remote access-to-classwide type,
`T'Stub_Type' denotes the type of the corresponding stub objects.

By construction, the layout of `T'Stub_Type' is identical to that of
type `RACW_Stub_Type' declared in the internal implementation-defined
unit `System.Partition_Interface'. Use of this attribute will create an
implicit dependency on this unit.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "238" name = "Succ" origin = "Ada RM" category = "function">
      <DOC>
For every scalar subtype S:

S'Succ denotes a function with the following specification:

function S'Succ(Arg : S'Base)
return S'Base

For an enumeration type, the function returns the value whose
position number is one more than that of the value of Arg;
Constraint_Error is raised if there is no such value of the
type. For an integer type, the function returns the result of
adding one to the value of Arg. For a fixed point type, the
function returns the result of adding small to the value of Arg.
For a floating point type, the function returns the machine
number (as defined in 3.5.7) immediately above the value of Arg;
Constraint_Error is raised if there is no such machine number.
See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "242" name = "Tag" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix X that is of a class-wide tagged type (after any
implicit dereference):

X'Tag denotes the tag of X. The value of this attribute is of
type Tag. See 3.9.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "244" name = "Tag" origin = "Ada RM" category = "variable">
      <DOC>
For every subtype S of a tagged type T (specific or class-wide):

S'Tag denotes the tag of the type T (or if T is class-wide, the
tag of the root type of the corresponding class). The value of
this attribute is of type Tag. See 3.9.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Target_Name" origin = "GNAT RM" category = "variable">
      <DOC>
`Standard'Target_Name' (`Standard' is the only permissible prefix)
provides a static string value that identifies the target for the
current compilation. For GCC implementations, this is the standard gcc
target name without the terminating slash (for example, GNAT 5.0 on
windows yields "i586-pc-mingw32msv").
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "246" name = "Terminated" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix T that is of a task type (after any implicit
dereference):

Yields the value True if the task denoted by T is terminated,
and False otherwise. The value of this attribute is of the
predefined type Boolean. See 9.9.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Tick" origin = "GNAT RM" category = "variable">
      <DOC>
`Standard'Tick' (`Standard' is the only permissible prefix) provides
the same value as `System.Tick',
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "To_Address" origin = "GNAT RM" category = "variable">
      <DOC>
The `System'To_Address' (`System' is the only permissible prefix)
denotes a function identical to `System.Storage_Elements.To_Address'
except that it is a static attribute.  This means that if its argument
is a static expression, then the result of the attribute is a static
expression.  The result is that such an expression can be used in
contexts (e.g. preelaborable packages) which require a static
expression and where the function call could not be used (since the
function call is always non-static, even if its argument is static).
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "248" name = "Truncation" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S of a floating point type T:

S'Truncation denotes a function with the following
specification:

function S'Truncation (X : T)
return T

The function yields the value Ceiling(X) when X is negative, and
Floor(X) otherwise. A zero result has the sign of X when
S'Signed_Zeros is True. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Type_Class" origin = "GNAT RM" category = "variable">
      <DOC>
`TYPE'Type_Class' for any type or subtype TYPE yields the value of the
type class for the full type of TYPE.  If TYPE is a generic formal
type, the value is the value for the corresponding actual subtype.  The
value of this attribute is of type `System.Aux_DEC.Type_Class', which
has the following definition:

type Type_Class is
(Type_Class_Enumeration,
Type_Class_Integer,
Type_Class_Fixed_Point,
Type_Class_Floating_Point,
Type_Class_Array,
Type_Class_Record,
Type_Class_Access,
Type_Class_Task,
Type_Class_Address);

Protected types yield the value `Type_Class_Task', which thus applies
to all concurrent types.  This attribute is designed to be compatible
with the DEC Ada 83 attribute of the same name.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "UET_Address" origin = "GNAT RM" category = "variable">
      <DOC>
The `UET_Address' attribute can only be used for a prefix which denotes
a library package.  It yields the address of the unit exception table
when zero cost exception handling is used.  This attribute is intended
only for use within the GNAT implementation.  See the unit
`Ada.Exceptions' in files `a-except.ads' and `a-except.adb' for details
on how this attribute is used in the implementation.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "252" name = "Unbiased_Rounding" origin = "Ada RM" category = "function">
      <DOC>
For every subtype S of a floating point type T:

S'Unbiased_Rounding denotes a function with the following
specification:

function S'Unbiased_Rounding (X : T)
return T

The function yields the integral value nearest to X, rounding
toward the even integer if X lies exactly halfway between two
integers. A zero result has the sign of X when S'Signed_Zeros is
True. See A.5.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "256" name = "Unchecked_Access" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix X that denotes an aliased view of an object:

All rules and semantics that apply to X'Access (see 3.10.2)
apply also to X'Unchecked_Access, except that, for the purposes
of accessibility rules and checks, it is as if X were declared
immediately within a library package. See 13.10.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Unconstrained_Array" origin = "GNAT RM" category = "variable">
      <DOC>
The `Unconstrained_Array' attribute can be used with a prefix that
denotes any type or subtype. It is a static attribute that yields
`True' if the prefix designates an unconstrained array, and `False'
otherwise. In a generic instance, the result is still static, and
yields the result of applying this test to the generic actual.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Universal_Literal_String" origin = "GNAT RM" category = "variable">
      <DOC>
The prefix of `Universal_Literal_String' must be a named number.  The
static result is the string consisting of the characters of the number
as defined in the original source.  This allows the user program to
access the actual text of named numbers without intermediate
conversions and without the need to enclose the strings in quotes (which
would preclude their use as numbers).

For example, the following program prints the first 50 digits of pi:

with Text_IO; use Text_IO;
with Ada.Numerics;
procedure Pi is
begin
Put (Ada.Numerics.Pi'Universal_Literal_String);
end;
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Unrestricted_Access" origin = "GNAT RM" category = "variable">
      <DOC>
The `Unrestricted_Access' attribute is similar to `Access' except that
all accessibility and aliased view checks are omitted.  This is a
user-beware attribute.  It is similar to `Address', for which it is a
desirable replacement where the value desired is an access type.  In
other words, its effect is identical to first applying the `Address'
attribute and then doing an unchecked conversion to a desired access
type.  In GNAT, but not necessarily in other implementations, the use
of static chains for inner level subprograms means that
`Unrestricted_Access' applied to a subprogram yields a value that can
be called as long as the subprogram is in scope (normal Ada
accessibility rules restrict this usage).

It is possible to use `Unrestricted_Access' for any type, but care
must be exercised if it is used to create pointers to unconstrained
objects. In this case, the resulting pointer has the same scope as the
context of the attribute, and may not be returned to some enclosing
scope. For instance, a function cannot use `Unrestricted_Access' to
create a unconstrained pointer and then return that value to the caller.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "VADS_Size" origin = "GNAT RM" category = "variable">
      <DOC>
The `'VADS_Size' attribute is intended to make it easier to port legacy
code which relies on the semantics of `'Size' as implemented by the
VADS Ada 83 compiler.  GNAT makes a best effort at duplicating the same
semantic interpretation.  In particular, `'VADS_Size' applied to a
predefined or other primitive type with no Size clause yields the
Object_Size (for example, `Natural'Size' is 32 rather than 31 on
typical machines).  In addition `'VADS_Size' applied to an object gives
the result that would be obtained by applying the attribute to the
corresponding type.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "258" name = "Val" origin = "Ada RM" category = "function">
      <DOC>
For every discrete subtype S:

S'Val denotes a function with the following specification:

function S'Val(Arg : universal_integer)
return S'Base

This function returns a value of the type of S whose position
number equals the value of Arg. See 3.5.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "262" name = "Valid" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix X that denotes a scalar object (after any implicit
dereference):

Yields True if and only if the object denoted by X is normal and
has a valid representation. The value of this attribute is of
the predefined type Boolean. See 13.9.2.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "264" name = "Value" origin = "Ada RM" category = "function">
      <DOC>
For every scalar subtype S:

S'Value denotes a function with the following specification:

function S'Value(Arg : String)
return S'Base

This function returns a value given an image of the value as a
String, ignoring any leading or trailing spaces. See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Value_Size" origin = "GNAT RM" category = "variable">
      <DOC>
`TYPE'Value_Size' is the number of bits required to represent a value
of the given subtype.  It is the same as `TYPE'Size', but, unlike
`Size', may be set for non-first subtypes.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "268/1" name = "Version" origin = "Ada RM" category = "variable">
      <DOC>
For a prefix P that statically denotes a program unit:

Yields a value of the predefined type String that identifies the
version of the compilation unit that contains the declaration of
the program unit. See E.3.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Wchar_T_Size" origin = "GNAT RM" category = "variable">
      <DOC>
`Standard'Wchar_T_Size' (`Standard' is the only permissible prefix)
provides the size in bits of the C `wchar_t' type primarily for
constructing the definition of this type in package `Interfaces.C'.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "270" name = "Wide_Image" origin = "Ada RM" category = "function">
      <DOC>
For every scalar subtype S:

S'Wide_Image denotes a function with the following
specification:

function S'Wide_Image(Arg : S'Base)
return Wide_String

The function returns an image of the value of Arg as a
Wide_String. See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "274" name = "Wide_Value" origin = "Ada RM" category = "function">
      <DOC>
For every scalar subtype S:

S'Wide_Value denotes a function with the following
specification:

function S'Wide_Value(Arg : Wide_String)
return S'Base

This function returns a value given an image of the value as a
Wide_String, ignoring any leading or trailing spaces. See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "277.1/2" name = "Wide_Wide_Image" origin = "Ada RM" category = "function">
      <DOC>
For every scalar subtype S:

S'Wide_Wide_Image denotes a function with the following
specification:

function S'Wide_Wide_Image(Arg : S'Base)
return Wide_Wide_String

The function returns an image of the value of Arg, that is, a
sequence of characters representing the value in display form.
See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "277.5/2" name = "Wide_Wide_Value" origin = "Ada RM" category = "function">
      <DOC>
For every scalar subtype S:

S'Wide_Wide_Value denotes a function with the following
specification:

function S'Wide_Wide_Value(Arg : Wide_Wide_String)
return S'Base

This function returns a value given an image of the value as a
Wide_Wide_String, ignoring any leading or trailing spaces. See
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "277.9/2" name = "Wide_Wide_Width" origin = "Ada RM" category = "variable">
      <DOC>
For every scalar subtype S:

S'Wide_Wide_Width denotes the maximum length of a
Wide_Wide_String returned by S'Wide_Wide_Image over all values
of the subtype S. It denotes zero for a subtype that has a null
range. Its type is universal_integer. See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "278" name = "Wide_Width" origin = "Ada RM" category = "variable">
      <DOC>
For every scalar subtype S:

S'Wide_Width denotes the maximum length of a Wide_String
returned by S'Wide_Image over all values of the subtype S. It
denotes zero for a subtype that has a null range. Its type is
universal_integer. See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "280" name = "Width" origin = "Ada RM" category = "variable">
      <DOC>
For every scalar subtype S:

S'Width denotes the maximum length of a String returned by
S'Image over all values of the subtype S. It denotes zero for a
subtype that has a null range. Its type is universal_integer.
See 3.5.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "0" name = "Word_Size" origin = "GNAT RM" category = "variable">
      <DOC>
`Standard'Word_Size' (`Standard' is the only permissible prefix)
provides the value `System.Word_Size'.
      </DOC>
   </ATTRIBUTE>

   <ATTRIBUTE id = "286" name = "Write" origin = "Ada RM" category = "procedure">
      <DOC>
For every subtype S of a specific type T:

S'Write denotes a procedure with the following specification:

procedure S'Write(
Stream : not null access Ada.Streams.Root_Stream_Type'Class;
Item : in T)

S'Write writes the value of Item to Stream. See 13.13.2.
      </DOC>
   </ATTRIBUTE>

   <PRAGMA id = "0" name = "Abort_Defer" origin = "GNAT RM">
      <DOC>
Syntax:
pragma Abort_Defer;

This pragma must appear at the start of the statement sequence of a
handled sequence of statements (right after the `begin').  It has the
effect of deferring aborts for the sequence of statements (but not for
the declarations or handlers, if any, associated with this statement
sequence).
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Ada_05" origin = "GNAT RM">
      <DOC>
Syntax:
pragma Ada_05;

A configuration pragma that establishes Ada 2005 mode for the unit to
which it applies, regardless of the mode set by the command line
switches.  This pragma is useful when writing a reusable component that
itself uses Ada 2005 features, but which is intended to be usable from
either Ada 83 or Ada 95 programs.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Ada_12" origin = "GNAT RM">
      <DOC>
Syntax:
pragma Ada_12;

A configuration pragma that establishes Ada 2012 mode for the unit to
which it applies, regardless of the mode set by the command line
switches.  This mode is set automatically for the `Ada' and `System'
packages and their children, so you need not specify it in these
contexts.  This pragma is useful when writing a reusable component that
itself uses Ada 2012 features, but which is intended to be usable from
Ada 83, Ada 95, or Ada 2005 programs.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Ada_2005" origin = "GNAT RM">
      <DOC>
Syntax:
pragma Ada_2005;

This configuration pragma is a synonym for pragma Ada_05 and has the
same syntax and effect.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Ada_2012" origin = "GNAT RM">
      <DOC>
Syntax:
pragma Ada_2012;

This configuration pragma is a synonym for pragma Ada_12 and has the
same syntax and effect.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Ada_83" origin = "GNAT RM">
      <DOC>
Syntax:
pragma Ada_83;

A configuration pragma that establishes Ada 83 mode for the unit to
which it applies, regardless of the mode set by the command line
switches.  In Ada 83 mode, GNAT attempts to be as compatible with the
syntax and semantics of Ada 83, as defined in the original Ada 83
Reference Manual as possible.  In particular, the keywords added by Ada
95 and Ada 2005 are not recognized, optional package bodies are allowed,
and generics may name types with unknown discriminants without using
the `(&lt;&gt;)' notation.  In addition, some but not all of the additional
restrictions of Ada 83 are enforced.

Ada 83 mode is intended for two purposes.  Firstly, it allows
existing Ada 83 code to be compiled and adapted to GNAT with less
effort.  Secondly, it aids in keeping code backwards compatible with
Ada 83.  However, there is no guarantee that code that is processed
correctly by GNAT in Ada 83 mode will in fact compile and execute with
an Ada 83 compiler, since GNAT does not enforce all the additional
checks required by Ada 83.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Ada_95" origin = "GNAT RM">
      <DOC>
Syntax:
pragma Ada_95;

A configuration pragma that establishes Ada 95 mode for the unit to
which it applies, regardless of the mode set by the command line
switches.  This mode is set automatically for the `Ada' and `System'
packages and their children, so you need not specify it in these
contexts.  This pragma is useful when writing a reusable component that
itself uses Ada 95 features, but which is intended to be usable from
either Ada 83 or Ada 95 programs.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "All_Calls_Remote" origin = "Ada RM">
      <DOC>
Syntax:

pragma All_Calls_Remote [(library_unit_name)];
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Annotate" origin = "GNAT RM">
      <DOC>
Syntax:
pragma Annotate (IDENTIFIER [,IDENTIFIER] {, ARG});

ARG ::= NAME | EXPRESSION

This pragma is used to annotate programs.  IDENTIFIER identifies the
type of annotation.  GNAT verifies that it is an identifier, but does
not otherwise analyze it. The second optional identifier is also left
unanalyzed, and by convention is used to control the action of the tool
to which the annotation is addressed.  The remaining ARG arguments can
be either string literals or more generally expressions.  String
literals are assumed to be either of type `Standard.String' or else
`Wide_String' or `Wide_Wide_String' depending on the character literals
they contain.  All other kinds of arguments are analyzed as
expressions, and must be unambiguous.

The analyzed pragma is retained in the tree, but not otherwise
processed by any part of the GNAT compiler.  This pragma is intended
for use by external tools, including ASIS.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Assert" origin = "Ada RM">
      <DOC>
Syntax:
pragma Assert (
boolean_EXPRESSION
[, string_EXPRESSION]);

The effect of this pragma depends on whether the corresponding command
line switch is set to activate assertions.  The pragma expands into code
equivalent to the following:

if assertions-enabled then
if not boolean_EXPRESSION then
System.Assertions.Raise_Assert_Failure
(string_EXPRESSION);
end if;
end if;

The string argument, if given, is the message that will be associated
with the exception occurrence if the exception is raised.  If no second
argument is given, the default message is `FILE:NNN', where FILE is the
name of the source file containing the assert, and NNN is the line
number of the assert.  A pragma is not a statement, so if a statement
sequence contains nothing but a pragma assert, then a null statement is
required in addition, as in:


if J &gt; 3 then
pragma Assert (K &gt; 3, "Bad value for K");
null;
end if;

Note that, as with the `if' statement to which it is equivalent, the
type of the expression is either `Standard.Boolean', or any type derived
from this standard type.

If assertions are disabled (switch `-gnata' not used), then there is
no run-time effect (and in particular, any side effects from the
expression will not occur at run time).  (The expression is still
analyzed at compile time, and may cause types to be frozen if they are
mentioned here for the first time).

If assertions are enabled, then the given expression is tested, and
if it is `False' then `System.Assertions.Raise_Assert_Failure' is called
which results in the raising of `Assert_Failure' with the given message.

You should generally avoid side effects in the expression arguments
of this pragma, because these side effects will turn on and off with the
setting of the assertions mode, resulting in assertions that have an
effect on the program.  However, the expressions are analyzed for
semantic correctness whether or not assertions are enabled, so turning
assertions on and off cannot affect the legality of a program.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Assertion_Policy" origin = "Ada RM">
      <DOC>
Syntax:

pragma Assertion_Policy (policy_identifier);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Assume_No_Invalid_Values" origin = "GNAT RM">
      <DOC>
Syntax:
pragma Assume_No_Invalid_Values (On | Off);

This is a configuration pragma that controls the assumptions made by the
compiler about the occurrence of invalid representations (invalid
values) in the code.

The default behavior (corresponding to an Off argument for this
pragma), is to assume that values may in general be invalid unless the
compiler can prove they are valid. Consider the following example:

V1 : Integer range 1 .. 10;
V2 : Integer range 11 .. 20;

for J in V2 .. V1 loop

end loop;

if V1 and V2 have valid values, then the loop is known at compile time
not to execute since the lower bound must be greater than the upper
bound. However in default mode, no such assumption is made, and the
loop may execute. If `Assume_No_Invalid_Values (On)' is given, the
compiler will assume that any occurrence of a variable other than in an
explicit `'Valid' test always has a valid value, and the loop above
will be optimized away.

The use of `Assume_No_Invalid_Values (On)' is appropriate if you
know your code is free of uninitialized variables and other possible
sources of invalid representations, and may result in more efficient
code. A program that accesses an invalid representation with this
pragma in effect is erroneous, so no guarantees can be made about its
behavior.

It is peculiar though permissible to use this pragma in conjunction
with validity checking (-gnatVa). In such cases, accessing invalid
values will generally give an exception, though formally the program is
erroneous so there are no guarantees that this will always be the case,
and it is recommended that these two options not be used together.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Ast_Entry" origin = "GNAT RM">
      <DOC>
Syntax:
pragma AST_Entry (entry_IDENTIFIER);

This pragma is implemented only in the OpenVMS implementation of GNAT.
The argument is the simple name of a single entry; at most one
`AST_Entry' pragma is allowed for any given entry.  This pragma must be
used in conjunction with the `AST_Entry' attribute, and is only allowed
after the entry declaration and in the same task type specification or
single task as the entry to which it applies.  This pragma specifies
that the given entry may be used to handle an OpenVMS asynchronous
system trap (`AST') resulting from an OpenVMS system service call.  The
pragma does not affect normal use of the entry.  For further details on
this pragma, see the DEC Ada Language Reference Manual, section 9.12a.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Asynchronous" origin = "Ada RM">
      <DOC>
Syntax:

pragma Asynchronous (local_name);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Atomic" origin = "Ada RM">
      <DOC>
Syntax:

pragma Atomic (local_name);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Atomic_Components" origin = "Ada RM">
      <DOC>
Syntax:

pragma Atomic_Components (array_local_name);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Attach_Handler" origin = "Ada RM">
      <DOC>
Syntax:

pragma Attach_Handler (handler_name, expression);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "CPP_Class" origin = "GNAT RM">
      <DOC>
Syntax:

pragma CPP_Class ([Entity =&gt;] LOCAL_NAME);

The argument denotes an entity in the current declarative region that is
declared as a record type. It indicates that the type corresponds to an
externally declared C++ class type, and is to be laid out the same way
that C++ would lay out the type. If the C++ class has virtual primitives
then the record must be declared as a tagged record type.

Types for which `CPP_Class' is specified do not have assignment or
equality operators defined (such operations can be imported or declared
as subprograms as required). Initialization is allowed only by
constructor functions (see pragma `CPP_Constructor'). Such types are
implicitly limited if not explicitly declared as limited or derived
from a limited type, and an error is issued in that case.

Pragma `CPP_Class' is intended primarily for automatic generation
using an automatic binding generator tool.  See *Note Interfacing to
C++:: for related information.

Note: Pragma `CPP_Class' is currently obsolete. It is supported for
backward compatibility but its functionality is available using pragma
`Import' with `Convention' = `CPP'.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "CPP_Constructor" origin = "GNAT RM">
      <DOC>
Syntax:

pragma CPP_Constructor ([Entity =&gt;] LOCAL_NAME
[, [External_Name =&gt;] static_string_EXPRESSION ]
[, [Link_Name     =&gt;] static_string_EXPRESSION ]);

This pragma identifies an imported function (imported in the usual way
with pragma `Import') as corresponding to a C++ constructor. If
`External_Name' and `Link_Name' are not specified then the `Entity'
argument is a name that must have been previously mentioned in a pragma
`Import' with `Convention' = `CPP'. Such name must be of one of the
following forms:

* `function FNAME return T'

* `function FNAME return T'Class'

* `function FNAME (...) return T'

* `function FNAME (...) return T'Class'

where T is a limited record type imported from C++ with pragma `Import'
and `Convention' = `CPP'.

The first two forms import the default constructor, used when an
object of type T is created on the Ada side with no explicit
constructor.  The latter two forms cover all the non-default
constructors of the type.  See the GNAT users guide for details.

If no constructors are imported, it is impossible to create any
objects on the Ada side and the type is implicitly declared abstract.

Pragma `CPP_Constructor' is intended primarily for automatic
generation using an automatic binding generator tool.  See *Note
Interfacing to C++:: for more related information.

Note: The use of functions returning class-wide types for
constructors is currently obsolete. They are supported for backward
compatibility. The use of functions returning the type T leave the Ada
sources more clear because the imported C++ constructors always return
an object of type T; that is, they never return an object whose type is
a descendant of type T.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "CPP_Virtual" origin = "GNAT RM">
      <DOC>
This pragma is now obsolete has has no effect because GNAT generates
the same object layout than the G++ compiler.

See *Note Interfacing to C++:: for related information.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "CPP_Vtable" origin = "GNAT RM">
      <DOC>
This pragma is now obsolete has has no effect because GNAT generates
the same object layout than the G++ compiler.

See *Note Interfacing to C++:: for related information.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "C_Pass_By_Copy" origin = "GNAT RM">
      <DOC>
Syntax:
pragma C_Pass_By_Copy
([Max_Size =&gt;] static_integer_EXPRESSION);

Normally the default mechanism for passing C convention records to C
convention subprograms is to pass them by reference, as suggested by RM
B.3(69).  Use the configuration pragma `C_Pass_By_Copy' to change this
default, by requiring that record formal parameters be passed by copy
if all of the following conditions are met:

* The size of the record type does not exceed the value specified for
`Max_Size'.

* The record type has `Convention C'.

* The formal parameter has this record type, and the subprogram has a
foreign (non-Ada) convention.

If these conditions are met the argument is passed by copy, i.e. in a
manner consistent with what C expects if the corresponding formal in the
C prototype is a struct (rather than a pointer to a struct).

You can also pass records by copy by specifying the convention
`C_Pass_By_Copy' for the record type, or by using the extended `Import'
and `Export' pragmas, which allow specification of passing mechanisms
on a parameter by parameter basis.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Check" origin = "GNAT RM">
      <DOC>
Syntax:
pragma Check (
[Name    =&gt;] Identifier,
[Check   =&gt;] Boolean_EXPRESSION
[, [Message =&gt;] string_EXPRESSION] );

This pragma is similar to the predefined pragma `Assert' except that an
extra identifier argument is present. In conjunction with pragma
`Check_Policy', this can be used to define groups of assertions that can
be independently controlled. The identifier `Assertion' is special, it
refers to the normal set of pragma `Assert' statements. The identifiers
`Precondition' and `Postcondition' correspond to the pragmas of these
names, so these three names would normally not be used directly in a
pragma `Check'.

Checks introduced by this pragma are normally deactivated by
default. They can be activated either by the command line option
`-gnata', which turns on all checks, or individually controlled using
pragma `Check_Policy'.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Check_Name" origin = "GNAT RM">
      <DOC>
Syntax:
pragma Check_Name (check_name_IDENTIFIER);

This is a configuration pragma that defines a new implementation
defined check name (unless IDENTIFIER matches one of the predefined
check names, in which case the pragma has no effect). Check names are
global to a partition, so if two or more configuration pragmas are
present in a partition mentioning the same name, only one new check
name is introduced.

An implementation defined check name introduced with this pragma may
be used in only three contexts: `pragma Suppress', `pragma Unsuppress',
and as the prefix of a `Check_Name'Enabled' attribute reference. For
any of these three cases, the check name must be visible. A check name
is visible if it is in the configuration pragmas applying to the
current unit, or if it appears at the start of any unit that is part of
the dependency set of the current unit (e.g., units that are mentioned
in `with' clauses).
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Check_Policy" origin = "GNAT RM">
      <DOC>
Syntax:
pragma Check_Policy
([Name   =&gt;] Identifier,
[Policy =&gt;] POLICY_IDENTIFIER);

POLICY_IDENTIFIER ::= On | Off | Check | Ignore

This pragma is similar to the predefined pragma `Assertion_Policy',
except that it controls sets of named assertions introduced using the
`Check' pragmas. It can be used as a configuration pragma or (unlike
`Assertion_Policy') can be used within a declarative part, in which case
it controls the status to the end of the corresponding construct (in a
manner identical to pragma `Suppress)'.

The identifier given as the first argument corresponds to a name
used in associated `Check' pragmas. For example, if the pragma:

pragma Check_Policy (Critical_Error, Off);

is given, then subsequent `Check' pragmas whose first argument is also
`Critical_Error' will be disabled. The special identifier `Assertion'
controls the behavior of normal `Assert' pragmas (thus a pragma
`Check_Policy' with this identifier is similar to the normal
`Assertion_Policy' pragma except that it can appear within a
declarative part).

The special identifiers `Precondition' and `Postcondition' control
the status of preconditions and postconditions. If a `Precondition'
pragma is encountered, it is ignored if turned off by a `Check_Policy'
specifying that `Precondition' checks are `Off' or `Ignored'. Similarly
use of the name `Postcondition' controls whether `Postcondition' pragmas
are recognized.

The check policy is `Off' to turn off corresponding checks, and `On'
to turn on corresponding checks. The default for a set of checks for
which no `Check_Policy' is given is `Off' unless the compiler switch
`-gnata' is given, which turns on all checks by default.

The check policy settings `Check' and `Ignore' are also recognized
as synonyms for `On' and `Off'. These synonyms are provided for
compatibility with the standard `Assertion_Policy' pragma.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Comment" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Comment (static_string_EXPRESSION);

This is almost identical in effect to pragma `Ident'.  It allows the
placement of a comment into the object file and hence into the
executable file if the operating system permits such usage.  The
difference is that `Comment', unlike `Ident', has no limitations on
placement of the pragma (it can be placed anywhere in the main source
unit), and if more than one pragma is used, all comments are retained.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Common_Object" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Common_Object (
[Internal =&gt;] LOCAL_NAME
[, [External =&gt;] EXTERNAL_SYMBOL]
[, [Size     =&gt;] EXTERNAL_SYMBOL] );

EXTERNAL_SYMBOL ::=
IDENTIFIER
| static_string_EXPRESSION

This pragma enables the shared use of variables stored in overlaid
linker areas corresponding to the use of `COMMON' in Fortran.  The
single object LOCAL_NAME is assigned to the area designated by the
EXTERNAL argument.  You may define a record to correspond to a series
of fields.  The SIZE argument is syntax checked in GNAT, but otherwise
ignored.

`Common_Object' is not supported on all platforms.  If no support is
available, then the code generator will issue a message indicating that
the necessary attribute for implementation of this pragma is not
available.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Compile_Time_Error" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Compile_Time_Error
(boolean_EXPRESSION, static_string_EXPRESSION);

This pragma can be used to generate additional compile time error
messages. It is particularly useful in generics, where errors can be
issued for specific problematic instantiations. The first parameter is
a boolean expression. The pragma is effective only if the value of this
expression is known at compile time, and has the value True. The set of
expressions whose values are known at compile time includes all static
boolean expressions, and also other values which the compiler can
determine at compile time (e.g., the size of a record type set by an
explicit size representation clause, or the value of a variable which
was initialized to a constant and is known not to have been modified).
If these conditions are met, an error message is generated using the
value given as the second argument. This string value may contain
embedded ASCII.LF characters to break the message into multiple lines.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Compile_Time_Warning" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Compile_Time_Warning
(boolean_EXPRESSION, static_string_EXPRESSION);

Same as pragma Compile_Time_Error, except a warning is issued instead
of an error message. Note that if this pragma is used in a package that
is with'ed by a client, the client will get the warning even though it
is issued by a with'ed package (normally warnings in with'ed units are
suppressed, but this is a special exception to that rule).

One typical use is within a generic where compile time known
characteristics of formal parameters are tested, and warnings given
appropriately. Another use with a first parameter of True is to warn a
client about use of a package, for example that it is not fully
implemented.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Compiler_Unit" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Compiler_Unit;

This pragma is intended only for internal use in the GNAT run-time
library.  It indicates that the unit is used as part of the compiler
build. The effect is to disallow constructs (raise with message,
conditional expressions etc) that would cause trouble when
bootstrapping using an older version of GNAT.  For the exact list of
restrictions, see the compiler sources and references to
Is_Compiler_Unit.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Complete_Representation" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Complete_Representation;

This pragma must appear immediately within a record representation
clause. Typical placements are before the first component clause or
after the last component clause. The effect is to give an error message
if any component is missing a component clause. This pragma may be used
to ensure that a record representation clause is complete, and that
this invariant is maintained if fields are added to the record in the
future.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Complex_Representation" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Complex_Representation
([Entity =&gt;] LOCAL_NAME);

The ENTITY argument must be the name of a record type which has two
fields of the same floating-point type.  The effect of this pragma is
to force gcc to use the special internal complex representation form for
this record, which may be more efficient.  Note that this may result in
the code for this type not conforming to standard ABI (application
binary interface) requirements for the handling of record types.  For
example, in some environments, there is a requirement for passing
records by pointer, and the use of this pragma may result in passing
this type in floating-point registers.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Component_Alignment" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Component_Alignment (
[Form =&gt;] ALIGNMENT_CHOICE
[, [Name =&gt;] type_LOCAL_NAME]);

ALIGNMENT_CHOICE ::=
Component_Size
| Component_Size_4
| Storage_Unit
| Default

Specifies the alignment of components in array or record types.  The
meaning of the FORM argument is as follows:

`Component_Size'
Aligns scalar components and subcomponents of the array or record
type on boundaries appropriate to their inherent size (naturally
aligned).  For example, 1-byte components are aligned on byte
boundaries, 2-byte integer components are aligned on 2-byte
boundaries, 4-byte integer components are aligned on 4-byte
boundaries and so on.  These alignment rules correspond to the
normal rules for C compilers on all machines except the VAX.

`Component_Size_4'
Naturally aligns components with a size of four or fewer bytes.
Components that are larger than 4 bytes are placed on the next
-byte boundary.

`Storage_Unit'
Specifies that array or record components are byte aligned, i.e.
aligned on boundaries determined by the value of the constant
`System.Storage_Unit'.

`Default'
Specifies that array or record components are aligned on default
boundaries, appropriate to the underlying hardware or operating
system or both.  For OpenVMS VAX systems, the `Default' choice is
the same as the `Storage_Unit' choice (byte alignment).  For all
other systems, the `Default' choice is the same as
`Component_Size' (natural alignment).

If the `Name' parameter is present, TYPE_LOCAL_NAME must refer to a
local record or array type, and the specified alignment choice applies
to the specified type.  The use of `Component_Alignment' together with
a pragma `Pack' causes the `Component_Alignment' pragma to be ignored.
The use of `Component_Alignment' together with a record representation
clause is only effective for fields not specified by the representation
clause.

If the `Name' parameter is absent, the pragma can be used as either
a configuration pragma, in which case it applies to one or more units in
accordance with the normal rules for configuration pragmas, or it can be
used within a declarative part, in which case it applies to types that
are declared within this declarative part, or within any nested scope
within this declarative part.  In either case it specifies the alignment
to be applied to any record or array type which has otherwise standard
representation.

If the alignment for a record or array type is not specified (using
pragma `Pack', pragma `Component_Alignment', or a record rep clause),
the GNAT uses the default alignment as described previously.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Controlled" origin = "Ada RM">
      <DOC>
Syntax:

pragma Controlled (first_subtype_local_name);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Convention" origin = "Ada RM">
      <DOC>
Syntax:

pragma Convention ([Convention=>]convention_identifier,[Entity=>]local_name);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Convention_Identifier" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Convention_Identifier (
[Name =&gt;]       IDENTIFIER,
[Convention =&gt;] convention_IDENTIFIER);

This pragma provides a mechanism for supplying synonyms for existing
convention identifiers. The `Name' identifier can subsequently be used
as a synonym for the given convention in other pragmas (including for
example pragma `Import' or another `Convention_Identifier' pragma). As
an example of the use of this, suppose you had legacy code which used
Fortran77 as the identifier for Fortran. Then the pragma:

pragma Convention_Identifier (Fortran77, Fortran);

would allow the use of the convention identifier `Fortran77' in
subsequent code, avoiding the need to modify the sources. As another
example, you could use this to parameterize convention requirements
according to systems. Suppose you needed to use `Stdcall' on windows
systems, and `C' on some other system, then you could define a
convention identifier `Library' and use a single
`Convention_Identifier' pragma to specify which convention would be
used system-wide.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Debug" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Debug ([CONDITION, ]PROCEDURE_CALL_WITHOUT_SEMICOLON);

PROCEDURE_CALL_WITHOUT_SEMICOLON ::=
PROCEDURE_NAME
| PROCEDURE_PREFIX ACTUAL_PARAMETER_PART

The procedure call argument has the syntactic form of an expression,
meeting the syntactic requirements for pragmas.

If debug pragmas are not enabled or if the condition is present and
evaluates to False, this pragma has no effect. If debug pragmas are
enabled, the semantics of the pragma is exactly equivalent to the
procedure call statement corresponding to the argument with a
terminating semicolon. Pragmas are permitted in sequences of
declarations, so you can use pragma `Debug' to intersperse calls to
debug procedures in the middle of declarations. Debug pragmas can be
enabled either by use of the command line switch `-gnata' or by use of
the configuration pragma `Debug_Policy'.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Debug_Policy" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Debug_Policy (CHECK | IGNORE);

If the argument is `CHECK', then pragma `DEBUG' is enabled.  If the
argument is `IGNORE', then pragma `DEBUG' is ignored.  This pragma
overrides the effect of the `-gnata' switch on the command line.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Detect_Blocking" origin = "Ada RM">
      <DOC>
Syntax:

pragma Detect_Blocking;

This is a configuration pragma that forces the detection of potentially
blocking operations within a protected operation, and to raise
Program_Error if that happens.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Discard_Names" origin = "Ada RM">
      <DOC>
Syntax:

pragma Discard_Names [([On => ] local_name)];
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Elaborate" origin = "Ada RM">
      <DOC>
Syntax:

pragma Elaborate (library_unit_name{, library_unit_name});
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Elaborate_All" origin = "Ada RM">
      <DOC>
Syntax:

pragma Elaborate_All (library_unit_name{, library_unit_name});
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Elaborate_Body" origin = "Ada RM">
      <DOC>
Syntax:

pragma Elaborate_Body [(library_unit_name)];
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Elaboration_Checks" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Elaboration_Checks (Dynamic | Static);

This is a configuration pragma that provides control over the
elaboration model used by the compilation affected by the pragma.  If
the parameter is `Dynamic', then the dynamic elaboration model
described in the Ada Reference Manual is used, as though the `-gnatE'
switch had been specified on the command line.  If the parameter is
`Static', then the default GNAT static model is used.  This
configuration pragma overrides the setting of the command line.  For
full details on the elaboration models used by the GNAT compiler, see
*Note Elaboration Order Handling in GNAT: (gnat_ugn)Elaboration Order
Handling in GNAT.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Eliminate" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Eliminate (UNIT_NAME, ENTITY, Source_Location =&gt; SOURCE_TRACE)

UNIT_NAME        ::= IDENTIFIER |
SELECTED_COMPONENT,

ENTITY           ::= IDENTIFIER |
SELECTED_COMPONENT,

SOURCE_TRACE     ::= SOURCE_REFERENCE |
SOURCE_REFERENCE LBRACKET SOURCE_TRACE RBRACKET

LBRACKET         ::= [
RBRACKET         ::= ]

SOURCE_REFERENCE ::= FILE_NAME : LINE_NUMBER

FILE_NAME        ::= STRING_LITERAL
LINE_NUMBER      ::= INTEGER_LITERAL

This pragma indicates that the given entity is not used in the program
to be compiled and built. The entity must be an explicitly declared
subprogram; this includes generic subprogram instances and subprograms
declared in generic package instances. `Unit_Name' must be the name of
the compilation unit in which the entity is declared.

The `Source_Location' argument is used to resolve overloading in
case more then one callable entity with the same name is declared in
the given compilation unit. Each file name must be the short name of the
source file (with no directory information).  If an entity is not
declared in a generic instantiation (this includes generic subprogram
instances), the source trace includes only one source reference. If an
entity is declared inside a generic instantiation, its source trace
starts from the source location in the instantiation and ends with the
source location of the declaration of the corresponding entity in the
generic unit. This approach is recursively used in case of nested
instantiations: the leftmost element of the source trace is the
location of the outermost instantiation, the next element is the
location of the next (first nested) instantiation in the code of the
corresponding generic unit, and so on.

The effect of the pragma is to allow the compiler to eliminate the
code or data associated with the named entity.  Any reference to an
eliminated entity outside the compilation unit where it is defined
causes a compile-time or link-time error.

The intention of pragma `Eliminate' is to allow a program to be
compiled in a system-independent manner, with unused entities
eliminated, without needing to modify the source text.  Normally the
required set of `Eliminate' pragmas is constructed automatically using
the gnatelim tool. Elimination of unused entities local to a
compilation unit is automatic, without requiring the use of pragma
`Eliminate'.

Any source file change that removes, splits, or adds lines may make
the set of Eliminate pragmas invalid because their `Source_Location'
argument values may get out of date.

Pragma Eliminate may be used where the referenced entity is a
dispatching operation. In this case all the subprograms to which the
given operation can dispatch are considered to be unused (are never
called as a result of a direct or a dispatching call).
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Export" origin = "Ada RM">
      <DOC>
Syntax:

pragma Export ([Convention=>]convention_identifier,[Entity=>]local_name;
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Export_Exception" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Export_Exception (
[Internal =&gt;] LOCAL_NAME
[, [External =&gt;] EXTERNAL_SYMBOL]
[, [Form     =&gt;] Ada | VMS]
[, [Code     =&gt;] static_integer_EXPRESSION]);

EXTERNAL_SYMBOL ::=
IDENTIFIER
| static_string_EXPRESSION

This pragma is implemented only in the OpenVMS implementation of GNAT.
It causes the specified exception to be propagated outside of the Ada
program, so that it can be handled by programs written in other OpenVMS
languages.  This pragma establishes an external name for an Ada
exception and makes the name available to the OpenVMS Linker as a
global symbol.  For further details on this pragma, see the DEC Ada
Language Reference Manual, section 13.9a3.2.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Export_Function" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Export_Function (
[Internal         =&gt;] LOCAL_NAME
[, [External         =&gt;] EXTERNAL_SYMBOL]
[, [Parameter_Types  =&gt;] PARAMETER_TYPES]
[, [Result_Type      =&gt;] result_SUBTYPE_MARK]
[, [Mechanism        =&gt;] MECHANISM]
[, [Result_Mechanism =&gt;] MECHANISM_NAME]);

EXTERNAL_SYMBOL ::=
IDENTIFIER
| static_string_EXPRESSION
| ""

PARAMETER_TYPES ::=
null
| TYPE_DESIGNATOR {, TYPE_DESIGNATOR}

TYPE_DESIGNATOR ::=
subtype_NAME
| subtype_Name ' Access

MECHANISM ::=
MECHANISM_NAME
| (MECHANISM_ASSOCIATION {, MECHANISM_ASSOCIATION})

MECHANISM_ASSOCIATION ::=
[formal_parameter_NAME =&gt;] MECHANISM_NAME

MECHANISM_NAME ::=
Value
| Reference
| Descriptor [([Class =&gt;] CLASS_NAME)]
| Short_Descriptor [([Class =&gt;] CLASS_NAME)]

CLASS_NAME ::= ubs | ubsb | uba | s | sb | a

Use this pragma to make a function externally callable and optionally
provide information on mechanisms to be used for passing parameter and
result values.  We recommend, for the purposes of improving portability,
this pragma always be used in conjunction with a separate pragma
`Export', which must precede the pragma `Export_Function'.  GNAT does
not require a separate pragma `Export', but if none is present,
`Convention Ada' is assumed, which is usually not what is wanted, so it
is usually appropriate to use this pragma in conjunction with a
`Export' or `Convention' pragma that specifies the desired foreign
convention.  Pragma `Export_Function' (and `Export', if present) must
appear in the same declarative region as the function to which they
apply.

INTERNAL_NAME must uniquely designate the function to which the
pragma applies.  If more than one function name exists of this name in
the declarative part you must use the `Parameter_Types' and
`Result_Type' parameters is mandatory to achieve the required unique
designation.  SUBTYPE_MARKs in these parameters must exactly match the
subtypes in the corresponding function specification, using positional
notation to match parameters with subtype marks.  The form with an
`'Access' attribute can be used to match an anonymous access parameter.

Passing by descriptor is supported only on the OpenVMS ports of GNAT.
The default behavior for Export_Function is to accept either 64bit or
32bit descriptors unless short_descriptor is specified, then only 32bit
descriptors are accepted.

Special treatment is given if the EXTERNAL is an explicit null
string or a static string expressions that evaluates to the null
string. In this case, no external name is generated. This form still
allows the specification of parameter mechanisms.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Export_Object" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Export_Object
[Internal =&gt;] LOCAL_NAME
[, [External =&gt;] EXTERNAL_SYMBOL]
[, [Size     =&gt;] EXTERNAL_SYMBOL]

EXTERNAL_SYMBOL ::=
IDENTIFIER
| static_string_EXPRESSION

This pragma designates an object as exported, and apart from the
extended rules for external symbols, is identical in effect to the use
of the normal `Export' pragma applied to an object.  You may use a
separate Export pragma (and you probably should from the point of view
of portability), but it is not required.  SIZE is syntax checked, but
otherwise ignored by GNAT.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Export_Procedure" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Export_Procedure (
[Internal        =&gt;] LOCAL_NAME
[, [External        =&gt;] EXTERNAL_SYMBOL]
[, [Parameter_Types =&gt;] PARAMETER_TYPES]
[, [Mechanism       =&gt;] MECHANISM]);

EXTERNAL_SYMBOL ::=
IDENTIFIER
| static_string_EXPRESSION
| ""

PARAMETER_TYPES ::=
null
| TYPE_DESIGNATOR {, TYPE_DESIGNATOR}

TYPE_DESIGNATOR ::=
subtype_NAME
| subtype_Name ' Access

MECHANISM ::=
MECHANISM_NAME
| (MECHANISM_ASSOCIATION {, MECHANISM_ASSOCIATION})

MECHANISM_ASSOCIATION ::=
[formal_parameter_NAME =&gt;] MECHANISM_NAME

MECHANISM_NAME ::=
Value
| Reference
| Descriptor [([Class =&gt;] CLASS_NAME)]
| Short_Descriptor [([Class =&gt;] CLASS_NAME)]

CLASS_NAME ::= ubs | ubsb | uba | s | sb | a

This pragma is identical to `Export_Function' except that it applies to
a procedure rather than a function and the parameters `Result_Type' and
`Result_Mechanism' are not permitted.  GNAT does not require a separate
pragma `Export', but if none is present, `Convention Ada' is assumed,
which is usually not what is wanted, so it is usually appropriate to
use this pragma in conjunction with a `Export' or `Convention' pragma
that specifies the desired foreign convention.

Passing by descriptor is supported only on the OpenVMS ports of GNAT.
The default behavior for Export_Procedure is to accept either 64bit or
32bit descriptors unless short_descriptor is specified, then only 32bit
descriptors are accepted.

Special treatment is given if the EXTERNAL is an explicit null
string or a static string expressions that evaluates to the null
string. In this case, no external name is generated. This form still
allows the specification of parameter mechanisms.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Export_Value" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Export_Value (
[Value     =&gt;] static_integer_EXPRESSION,
[Link_Name =&gt;] static_string_EXPRESSION);

This pragma serves to export a static integer value for external use.
The first argument specifies the value to be exported. The Link_Name
argument specifies the symbolic name to be associated with the integer
value. This pragma is useful for defining a named static value in Ada
that can be referenced in assembly language units to be linked with the
application. This pragma is currently supported only for the AAMP
target and is ignored for other targets.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Export_Valued_Procedure" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Export_Valued_Procedure (
[Internal        =&gt;] LOCAL_NAME
[, [External        =&gt;] EXTERNAL_SYMBOL]
[, [Parameter_Types =&gt;] PARAMETER_TYPES]
[, [Mechanism       =&gt;] MECHANISM]);

EXTERNAL_SYMBOL ::=
IDENTIFIER
| static_string_EXPRESSION
| ""

PARAMETER_TYPES ::=
null
| TYPE_DESIGNATOR {, TYPE_DESIGNATOR}

TYPE_DESIGNATOR ::=
subtype_NAME
| subtype_Name ' Access

MECHANISM ::=
MECHANISM_NAME
| (MECHANISM_ASSOCIATION {, MECHANISM_ASSOCIATION})

MECHANISM_ASSOCIATION ::=
[formal_parameter_NAME =&gt;] MECHANISM_NAME

MECHANISM_NAME ::=
Value
| Reference
| Descriptor [([Class =&gt;] CLASS_NAME)]
| Short_Descriptor [([Class =&gt;] CLASS_NAME)]

CLASS_NAME ::= ubs | ubsb | uba | s | sb | a

This pragma is identical to `Export_Procedure' except that the first
parameter of LOCAL_NAME, which must be present, must be of mode `OUT',
and externally the subprogram is treated as a function with this
parameter as the result of the function.  GNAT provides for this
capability to allow the use of `OUT' and `IN OUT' parameters in
interfacing to external functions (which are not permitted in Ada
functions).  GNAT does not require a separate pragma `Export', but if
none is present, `Convention Ada' is assumed, which is almost certainly
not what is wanted since the whole point of this pragma is to interface
with foreign language functions, so it is usually appropriate to use
this pragma in conjunction with a `Export' or `Convention' pragma that
specifies the desired foreign convention.

Passing by descriptor is supported only on the OpenVMS ports of GNAT.
The default behavior for Export_Valued_Procedure is to accept either
64bit or 32bit descriptors unless short_descriptor is specified, then
only 32bit descriptors are accepted.

Special treatment is given if the EXTERNAL is an explicit null
string or a static string expressions that evaluates to the null
string. In this case, no external name is generated. This form still
allows the specification of parameter mechanisms.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Extend_System" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Extend_System ([Name =&gt;] IDENTIFIER);

This pragma is used to provide backwards compatibility with other
implementations that extend the facilities of package `System'.  In
GNAT, `System' contains only the definitions that are present in the
Ada RM.  However, other implementations, notably the DEC Ada 83
implementation, provide many extensions to package `System'.

For each such implementation accommodated by this pragma, GNAT
provides a package `Aux_XXX', e.g. `Aux_DEC' for the DEC Ada 83
implementation, which provides the required additional definitions.  You
can use this package in two ways.  You can `with' it in the normal way
and access entities either by selection or using a `use' clause.  In
this case no special processing is required.

However, if existing code contains references such as `System.XXX'
where XXX is an entity in the extended definitions provided in package
`System', you may use this pragma to extend visibility in `System' in a
non-standard way that provides greater compatibility with the existing
code.  Pragma `Extend_System' is a configuration pragma whose single
argument is the name of the package containing the extended definition
(e.g. `Aux_DEC' for the DEC Ada case).  A unit compiled under control
of this pragma will be processed using special visibility processing
that looks in package `System.Aux_XXX' where `Aux_XXX' is the pragma
argument for any entity referenced in package `System', but not found
in package `System'.

You can use this pragma either to access a predefined `System'
extension supplied with the compiler, for example `Aux_DEC' or you can
construct your own extension unit following the above definition.  Note
that such a package is a child of `System' and thus is considered part
of the implementation.  To compile it you will have to use the
appropriate switch for compiling system units.  *Note GNAT Pro User's
Guide: (gnat_ugn)Top, for details.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Extensions_Allowed" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Extensions_Allowed (On | Off);

This configuration pragma enables or disables the implementation
extension mode (the use of Off as a parameter cancels the effect of the
`-gnatX' command switch).

In extension mode, the latest version of the Ada language is
implemented (currently Ada 2012), and in addition a small number of
GNAT specific extensions are recognized as follows:

Constrained attribute for generic objects
The `Constrained' attribute is permitted for objects of generic
types. The result indicates if the corresponding actual is
constrained.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "External" origin = "GNAT RM">
      <DOC>
Syntax:

pragma External (
[   Convention    =&gt;] convention_IDENTIFIER,
[   Entity        =&gt;] LOCAL_NAME
[, [External_Name =&gt;] static_string_EXPRESSION ]
[, [Link_Name     =&gt;] static_string_EXPRESSION ]);

This pragma is identical in syntax and semantics to pragma `Export' as
defined in the Ada Reference Manual.  It is provided for compatibility
with some Ada 83 compilers that used this pragma for exactly the same
purposes as pragma `Export' before the latter was standardized.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "External_Name_Casing" origin = "GNAT RM">
      <DOC>
Syntax:

pragma External_Name_Casing (
Uppercase | Lowercase
[, Uppercase | Lowercase | As_Is]);

This pragma provides control over the casing of external names
associated with Import and Export pragmas.  There are two cases to
consider:

Implicit external names
Implicit external names are derived from identifiers.  The most
common case arises when a standard Ada Import or Export pragma is
used with only two arguments, as in:

pragma Import (C, C_Routine);

Since Ada is a case-insensitive language, the spelling of the
identifier in the Ada source program does not provide any
information on the desired casing of the external name, and so a
convention is needed.  In GNAT the default treatment is that such
names are converted to all lower case letters.  This corresponds
to the normal C style in many environments.  The first argument of
pragma `External_Name_Casing' can be used to control this
treatment.  If `Uppercase' is specified, then the name will be
forced to all uppercase letters.  If `Lowercase' is specified,
then the normal default of all lower case letters will be used.

This same implicit treatment is also used in the case of extended
DEC Ada 83 compatible Import and Export pragmas where an external
name is explicitly specified using an identifier rather than a
string.

Explicit external names
Explicit external names are given as string literals.  The most
common case arises when a standard Ada Import or Export pragma is
used with three arguments, as in:

pragma Import (C, C_Routine, "C_routine");

In this case, the string literal normally provides the exact
casing required for the external name.  The second argument of
pragma `External_Name_Casing' may be used to modify this behavior.
If `Uppercase' is specified, then the name will be forced to all
uppercase letters.  If `Lowercase' is specified, then the name
will be forced to all lowercase letters.  A specification of
`As_Is' provides the normal default behavior in which the casing is
taken from the string provided.

This pragma may appear anywhere that a pragma is valid.  In particular,
it can be used as a configuration pragma in the `gnat.adc' file, in
which case it applies to all subsequent compilations, or it can be used
as a program unit pragma, in which case it only applies to the current
unit, or it can be used more locally to control individual
Import/Export pragmas.

It is primarily intended for use with OpenVMS systems, where many
compilers convert all symbols to upper case by default.  For
interfacing to such compilers (e.g. the DEC C compiler), it may be
convenient to use the pragma:

pragma External_Name_Casing (Uppercase, Uppercase);

to enforce the upper casing of all external symbols.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Fast_Math" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Fast_Math;

This is a configuration pragma which activates a mode in which speed is
considered more important for floating-point operations than absolutely
accurate adherence to the requirements of the standard. Currently the
following operations are affected:

Complex Multiplication
The normal simple formula for complex multiplication can result in
intermediate overflows for numbers near the end of the range. The
Ada standard requires that this situation be detected and
corrected by scaling, but in Fast_Math mode such cases will simply
result in overflow. Note that to take advantage of this you must
instantiate your own version of
`Ada.Numerics.Generic_Complex_Types' under control of the pragma,
rather than use the preinstantiated versions.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Favor_Top_Level" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Favor_Top_Level (type_NAME);

The named type must be an access-to-subprogram type. This pragma is an
efficiency hint to the compiler, regarding the use of 'Access or
'Unrestricted_Access on nested (non-library-level) subprograms. The
pragma means that nested subprograms are not used with this type, or
are rare, so that the generated code should be efficient in the
top-level case. When this pragma is used, dynamically generated
trampolines may be used on some targets for nested subprograms.  See
also the No_Implicit_Dynamic_Code restriction.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Finalize_Storage_Only" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Finalize_Storage_Only (first_subtype_LOCAL_NAME);

This pragma allows the compiler not to emit a Finalize call for objects
defined at the library level.  This is mostly useful for types where
finalization is only used to deal with storage reclamation since in most
environments it is not necessary to reclaim memory just before
terminating execution, hence the name.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Float_Representation" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Float_Representation (FLOAT_REP[, float_type_LOCAL_NAME]);

FLOAT_REP ::= VAX_Float | IEEE_Float

In the one argument form, this pragma is a configuration pragma which
allows control over the internal representation chosen for the
predefined floating point types declared in the packages `Standard' and
`System'. On all systems other than OpenVMS, the argument must be
`IEEE_Float' and the pragma has no effect. On OpenVMS, the argument may
be `VAX_Float' to specify the use of the VAX float format for the
floating-point types in Standard. This requires that the standard
runtime libraries be recompiled.

The two argument form specifies the representation to be used for
the specified floating-point type. On all systems other than OpenVMS,
the argument must be `IEEE_Float' and the pragma has no effect. On
OpenVMS, the argument may be `VAX_Float' to specify the use of the VAX
float format, as follows:

* For digits values up to 6, F float format will be used.

* For digits values from 7 to 9, D float format will be used.

* For digits values from 10 to 15, G float format will be used.

* Digits values above 15 are not allowed.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Ident" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Ident (static_string_EXPRESSION);

This pragma provides a string identification in the generated object
file, if the system supports the concept of this kind of identification
string.  This pragma is allowed only in the outermost declarative part
or declarative items of a compilation unit. If more than one `Ident'
pragma is given, only the last one processed is effective.  On OpenVMS
systems, the effect of the pragma is identical to the effect of the DEC
Ada 83 pragma of the same name. Note that in DEC Ada 83, the maximum
allowed length is 31 characters, so if it is important to maintain
compatibility with this compiler, you should obey this length limit.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Implemented" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Implemented (procedure_LOCAL_NAME, implementation_kind);

implementation_kind ::= By_Entry | By_Protected_Procedure | By_Any

This is an Ada 2012 representation pragma which applies to protected,
task and synchronized interface primitives. The use of pragma
Implemented provides a way to impose a static requirement on the
overriding opreration by adhering to one of the three implementation
kids: entry, protected procedure or any of the above.

type Synch_Iface is synchronized interface;
procedure Prim_Op (Obj : in out Iface) is abstract;
pragma Implemented (Prim_Op, By_Protected_Procedure);

protected type Prot_1 is new Synch_Iface with
procedure Prim_Op;  --  Legal
end Prot_1;

protected type Prot_2 is new Synch_Iface with
entry Prim_Op;      --  Illegal
end Prot_2;

task type Task_Typ is new Synch_Iface with
entry Prim_Op;      --  Illegal
end Task_Typ;

When applied to the procedure_or_entry_NAME of a requeue statement,
pragma Implemented determines the runtime behavior of the requeue.
Implementation kind By_Entry guarantees that the action of requeueing
will procede from an entry to another entry. Implementation kind
By_Protected_Procedure transforms the requeue into a dispatching call,
thus eliminating the chance of blocking. Kind By_Any shares the
behavior of By_Entry and By_Protected_Procedure depending on the
target's overriding subprogram kind.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Implicit_Packing" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Implicit_Packing;

This is a configuration pragma that requests implicit packing for packed
arrays for which a size clause is given but no explicit pragma Pack or
specification of Component_Size is present. It also applies to records
where no record representation clause is present. Consider this example:

type R is array (0 .. 7) of Boolean;
for R'Size use 8;

In accordance with the recommendation in the RM (RM 13.3(53)), a Size
clause does not change the layout of a composite object. So the Size
clause in the above example is normally rejected, since the default
layout of the array uses 8-bit components, and thus the array requires
a minimum of 64 bits.

If this declaration is compiled in a region of code covered by an
occurrence of the configuration pragma Implicit_Packing, then the Size
clause in this and similar examples will cause implicit packing and
thus be accepted. For this implicit packing to occur, the type in
question must be an array of small components whose size is known at
compile time, and the Size clause must specify the exact size that
corresponds to the length of the array multiplied by the size in bits
of the component type.

Similarly, the following example shows the use in the record case

type r is record
a, b, c, d, e, f, g, h : boolean;
chr                    : character;
end record;
for r'size use 16;

Without a pragma Pack, each Boolean field requires 8 bits, so the
minimum size is 72 bits, but with a pragma Pack, 16 bits would be
sufficient. The use of pragma Implciit_Packing allows this record
declaration to compile without an explicit pragma Pack.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Import" origin = "Ada RM">
      <DOC>
Syntax:

pragma Import ([Convention=>]convention_identifier,[Entity=>]local_name;
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Import_Exception" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Import_Exception (
[Internal =&gt;] LOCAL_NAME
[, [External =&gt;] EXTERNAL_SYMBOL]
[, [Form     =&gt;] Ada | VMS]
[, [Code     =&gt;] static_integer_EXPRESSION]);

EXTERNAL_SYMBOL ::=
IDENTIFIER
| static_string_EXPRESSION

This pragma is implemented only in the OpenVMS implementation of GNAT.
It allows OpenVMS conditions (for example, from OpenVMS system services
or other OpenVMS languages) to be propagated to Ada programs as Ada
exceptions.  The pragma specifies that the exception associated with an
exception declaration in an Ada program be defined externally (in
non-Ada code).  For further details on this pragma, see the DEC Ada
Language Reference Manual, section 13.9a.3.1.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Import_Function" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Import_Function (
[Internal                 =&gt;] LOCAL_NAME,
[, [External                 =&gt;] EXTERNAL_SYMBOL]
[, [Parameter_Types          =&gt;] PARAMETER_TYPES]
[, [Result_Type              =&gt;] SUBTYPE_MARK]
[, [Mechanism                =&gt;] MECHANISM]
[, [Result_Mechanism         =&gt;] MECHANISM_NAME]
[, [First_Optional_Parameter =&gt;] IDENTIFIER]);

EXTERNAL_SYMBOL ::=
IDENTIFIER
| static_string_EXPRESSION

PARAMETER_TYPES ::=
null
| TYPE_DESIGNATOR {, TYPE_DESIGNATOR}

TYPE_DESIGNATOR ::=
subtype_NAME
| subtype_Name ' Access

MECHANISM ::=
MECHANISM_NAME
| (MECHANISM_ASSOCIATION {, MECHANISM_ASSOCIATION})

MECHANISM_ASSOCIATION ::=
[formal_parameter_NAME =&gt;] MECHANISM_NAME

MECHANISM_NAME ::=
Value
| Reference
| Descriptor [([Class =&gt;] CLASS_NAME)]
| Short_Descriptor [([Class =&gt;] CLASS_NAME)]

CLASS_NAME ::= ubs | ubsb | uba | s | sb | a | nca

This pragma is used in conjunction with a pragma `Import' to specify
additional information for an imported function.  The pragma `Import'
(or equivalent pragma `Interface') must precede the `Import_Function'
pragma and both must appear in the same declarative part as the
function specification.

The INTERNAL argument must uniquely designate the function to which
the pragma applies.  If more than one function name exists of this name
in the declarative part you must use the `Parameter_Types' and
RESULT_TYPE parameters to achieve the required unique designation.
Subtype marks in these parameters must exactly match the subtypes in
the corresponding function specification, using positional notation to
match parameters with subtype marks.  The form with an `'Access'
attribute can be used to match an anonymous access parameter.

You may optionally use the MECHANISM and RESULT_MECHANISM parameters
to specify passing mechanisms for the parameters and result.  If you
specify a single mechanism name, it applies to all parameters.
Otherwise you may specify a mechanism on a parameter by parameter basis
using either positional or named notation.  If the mechanism is not
specified, the default mechanism is used.

Passing by descriptor is supported only on the OpenVMS ports of GNAT.
The default behavior for Import_Function is to pass a 64bit descriptor
unless short_descriptor is specified, then a 32bit descriptor is passed.

`First_Optional_Parameter' applies only to OpenVMS ports of GNAT.
It specifies that the designated parameter and all following parameters
are optional, meaning that they are not passed at the generated code
level (this is distinct from the notion of optional parameters in Ada
where the parameters are passed anyway with the designated optional
parameters).  All optional parameters must be of mode `IN' and have
default parameter values that are either known at compile time
expressions, or uses of the `'Null_Parameter' attribute.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Import_Object" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Import_Object
[Internal =&gt;] LOCAL_NAME
[, [External =&gt;] EXTERNAL_SYMBOL]
[, [Size     =&gt;] EXTERNAL_SYMBOL]);

EXTERNAL_SYMBOL ::=
IDENTIFIER
| static_string_EXPRESSION

This pragma designates an object as imported, and apart from the
extended rules for external symbols, is identical in effect to the use
of the normal `Import' pragma applied to an object.  Unlike the
subprogram case, you need not use a separate `Import' pragma, although
you may do so (and probably should do so from a portability point of
view).  SIZE is syntax checked, but otherwise ignored by GNAT.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Import_Procedure" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Import_Procedure (
[Internal                 =&gt;] LOCAL_NAME
[, [External                 =&gt;] EXTERNAL_SYMBOL]
[, [Parameter_Types          =&gt;] PARAMETER_TYPES]
[, [Mechanism                =&gt;] MECHANISM]
[, [First_Optional_Parameter =&gt;] IDENTIFIER]);

EXTERNAL_SYMBOL ::=
IDENTIFIER
| static_string_EXPRESSION

PARAMETER_TYPES ::=
null
| TYPE_DESIGNATOR {, TYPE_DESIGNATOR}

TYPE_DESIGNATOR ::=
subtype_NAME
| subtype_Name ' Access

MECHANISM ::=
MECHANISM_NAME
| (MECHANISM_ASSOCIATION {, MECHANISM_ASSOCIATION})

MECHANISM_ASSOCIATION ::=
[formal_parameter_NAME =&gt;] MECHANISM_NAME

MECHANISM_NAME ::=
Value
| Reference
| Descriptor [([Class =&gt;] CLASS_NAME)]
| Short_Descriptor [([Class =&gt;] CLASS_NAME)]

CLASS_NAME ::= ubs | ubsb | uba | s | sb | a | nca

This pragma is identical to `Import_Function' except that it applies to
a procedure rather than a function and the parameters `Result_Type' and
`Result_Mechanism' are not permitted.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Import_Valued_Procedure" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Import_Valued_Procedure (
[Internal                 =&gt;] LOCAL_NAME
[, [External                 =&gt;] EXTERNAL_SYMBOL]
[, [Parameter_Types          =&gt;] PARAMETER_TYPES]
[, [Mechanism                =&gt;] MECHANISM]
[, [First_Optional_Parameter =&gt;] IDENTIFIER]);

EXTERNAL_SYMBOL ::=
IDENTIFIER
| static_string_EXPRESSION

PARAMETER_TYPES ::=
null
| TYPE_DESIGNATOR {, TYPE_DESIGNATOR}

TYPE_DESIGNATOR ::=
subtype_NAME
| subtype_Name ' Access

MECHANISM ::=
MECHANISM_NAME
| (MECHANISM_ASSOCIATION {, MECHANISM_ASSOCIATION})

MECHANISM_ASSOCIATION ::=
[formal_parameter_NAME =&gt;] MECHANISM_NAME

MECHANISM_NAME ::=
Value
| Reference
| Descriptor [([Class =&gt;] CLASS_NAME)]
| Short_Descriptor [([Class =&gt;] CLASS_NAME)]

CLASS_NAME ::= ubs | ubsb | uba | s | sb | a | nca

This pragma is identical to `Import_Procedure' except that the first
parameter of LOCAL_NAME, which must be present, must be of mode `OUT',
and externally the subprogram is treated as a function with this
parameter as the result of the function.  The purpose of this
capability is to allow the use of `OUT' and `IN OUT' parameters in
interfacing to external functions (which are not permitted in Ada
functions).  You may optionally use the `Mechanism' parameters to
specify passing mechanisms for the parameters.  If you specify a single
mechanism name, it applies to all parameters.  Otherwise you may
specify a mechanism on a parameter by parameter basis using either
positional or named notation.  If the mechanism is not specified, the
default mechanism is used.

Note that it is important to use this pragma in conjunction with a
separate pragma Import that specifies the desired convention, since
otherwise the default convention is Ada, which is almost certainly not
what is required.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Initialize_Scalars" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Initialize_Scalars;

This pragma is similar to `Normalize_Scalars' conceptually but has two
important differences.  First, there is no requirement for the pragma
to be used uniformly in all units of a partition, in particular, it is
fine to use this just for some or all of the application units of a
partition, without needing to recompile the run-time library.

In the case where some units are compiled with the pragma, and some
without, then a declaration of a variable where the type is defined in
package Standard or is locally declared will always be subject to
initialization, as will any declaration of a scalar variable.  For
composite variables, whether the variable is initialized may also
depend on whether the package in which the type of the variable is
declared is compiled with the pragma.

The other important difference is that you can control the value used
for initializing scalar objects.  At bind time, you can select several
options for initialization. You can initialize with invalid values
(similar to Normalize_Scalars, though for Initialize_Scalars it is not
always possible to determine the invalid values in complex cases like
signed component fields with non-standard sizes). You can also
initialize with high or low values, or with a specified bit pattern.
See the users guide for binder options for specifying these cases.

This means that you can compile a program, and then without having to
recompile the program, you can run it with different values being used
for initializing otherwise uninitialized values, to test if your program
behavior depends on the choice.  Of course the behavior should not
change, and if it does, then most likely you have an erroneous
reference to an uninitialized value.

It is even possible to change the value at execution time
eliminating even the need to rebind with a different switch using an
environment variable.  See the GNAT users guide for details.

Note that pragma `Initialize_Scalars' is particularly useful in
conjunction with the enhanced validity checking that is now provided in
GNAT, which checks for invalid values under more conditions.  Using
this feature (see description of the `-gnatV' flag in the users guide)
in conjunction with pragma `Initialize_Scalars' provides a powerful new
tool to assist in the detection of problems caused by uninitialized
variables.

Note: the use of `Initialize_Scalars' has a fairly extensive effect
on the generated code. This may cause your code to be substantially
larger. It may also cause an increase in the amount of stack required,
so it is probably a good idea to turn on stack checking (see
description of stack checking in the GNAT users guide) when using this
pragma.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Inline" origin = "Ada RM">
      <DOC>
Syntax:

pragma Inline (name {, name});
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Inline_Always" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Inline_Always (NAME [, NAME]);

Similar to pragma `Inline' except that inlining is not subject to the
use of option `-gnatn' and the inlining happens regardless of whether
this option is used.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Inline_Generic" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Inline_Generic (generic_package_NAME);

This is implemented for compatibility with DEC Ada 83 and is recognized,
but otherwise ignored, by GNAT.  All generic instantiations are inlined
by default when using GNAT.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Inspection_Point" origin = "Ada RM">
      <DOC>
Syntax:

pragma Inspection_Point [(object_name {, object_name})];
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Interface" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Interface (
[Convention    =&gt;] convention_identifier,
[Entity        =&gt;] local_NAME
[, [External_Name =&gt;] static_string_expression]
[, [Link_Name     =&gt;] static_string_expression]);

This pragma is identical in syntax and semantics to the standard Ada
pragma `Import'.  It is provided for compatibility with Ada 83.  The
definition is upwards compatible both with pragma `Interface' as
defined in the Ada 83 Reference Manual, and also with some extended
implementations of this pragma in certain Ada 83 implementations.  The
only difference between pragma `Interface' and pragma `Import' is that
there is special circuitry to allow both pragmas to appear for the same
subprogram entity (normally it is illegal to have multiple `Import'
pragmas. This is useful in maintaining Ada 83/Ada 95 compatibility and
is compatible with other Ada 83 compilers.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Interface_Name" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Interface_Name (
[Entity        =&gt;] LOCAL_NAME
[, [External_Name =&gt;] static_string_EXPRESSION]
[, [Link_Name     =&gt;] static_string_EXPRESSION]);

This pragma provides an alternative way of specifying the interface name
for an interfaced subprogram, and is provided for compatibility with Ada
83 compilers that use the pragma for this purpose.  You must provide at
least one of EXTERNAL_NAME or LINK_NAME.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Interrupt_Handler" origin = "Ada RM">
      <DOC>
Syntax:

pragma Interrupt_Handler (procedure_LOCAL_NAME);

This program unit pragma is supported for parameterless protected
procedures as described in Annex C of the Ada Reference Manual. On the
AAMP target the pragma can also be specified for nonprotected
parameterless procedures that are declared at the library level (which
includes procedures declared at the top level of a library package). In
the case of AAMP, when this pragma is applied to a nonprotected
procedure, the instruction `IERET' is generated for returns from the
procedure, enabling maskable interrupts, in place of the normal return
instruction.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Interrupt_Priority" origin = "Ada RM">
      <DOC>
Syntax:

pragma Interrupt_Priority [(expression)];
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Interrupt_State" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Interrupt_State
([Name  =&gt;] value,
[State =&gt;] SYSTEM | RUNTIME | USER);

Normally certain interrupts are reserved to the implementation.  Any
attempt to attach an interrupt causes Program_Error to be raised, as
described in RM C.3.2(22).  A typical example is the `SIGINT' interrupt
used in many systems for an `Ctrl-C' interrupt.  Normally this
interrupt is reserved to the implementation, so that `Ctrl-C' can be
used to interrupt execution.  Additionally, signals such as `SIGSEGV',
`SIGABRT', `SIGFPE' and `SIGILL' are often mapped to specific Ada
exceptions, or used to implement run-time functions such as the `abort'
statement and stack overflow checking.

Pragma `Interrupt_State' provides a general mechanism for overriding
such uses of interrupts.  It subsumes the functionality of pragma
`Unreserve_All_Interrupts'.  Pragma `Interrupt_State' is not available
on Windows or VMS.  On all other platforms than VxWorks, it applies to
signals; on VxWorks, it applies to vectored hardware interrupts and may
be used to mark interrupts required by the board support package as
reserved.

Interrupts can be in one of three states:
* System

The interrupt is reserved (no Ada handler can be installed), and
the Ada run-time may not install a handler. As a result you are
guaranteed standard system default action if this interrupt is
raised.

* Runtime

The interrupt is reserved (no Ada handler can be installed). The
run time is allowed to install a handler for internal control
purposes, but is not required to do so.

* User

The interrupt is unreserved.  The user may install a handler to
provide some other action.

These states are the allowed values of the `State' parameter of the
pragma.  The `Name' parameter is a value of the type
`Ada.Interrupts.Interrupt_ID'.  Typically, it is a name declared in
`Ada.Interrupts.Names'.

This is a configuration pragma, and the binder will check that there
are no inconsistencies between different units in a partition in how a
given interrupt is specified. It may appear anywhere a pragma is legal.

The effect is to move the interrupt to the specified state.

By declaring interrupts to be SYSTEM, you guarantee the standard
system action, such as a core dump.

By declaring interrupts to be USER, you guarantee that you can
install a handler.

Note that certain signals on many operating systems cannot be caught
and handled by applications.  In such cases, the pragma is ignored.
See the operating system documentation, or the value of the array
`Reserved' declared in the spec of package `System.OS_Interface'.

Overriding the default state of signals used by the Ada runtime may
interfere with an application's runtime behavior in the cases of the
synchronous signals, and in the case of the signal used to implement
the `abort' statement.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Invariant" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Invariant
([Entity =&gt;]    private_type_LOCAL_NAME,
[Check  =&gt;]    EXPRESSION
[,[Message =&gt;] String_Expression]);

This pragma provides exactly the same capabilities as the Invariant
aspect defined in AI05-0146-1, and in the Ada 2012 Reference Manual.
The Invariant aspect is fully implemented in Ada 2012 mode, but since
it requires the use of the aspect syntax, which is not available
exception in 2012 mode, it is not possible to use the Invariant aspect
in earlier versions of Ada. However the Invariant pragma may be used in
any version of Ada.

The pragma must appear within the visible part of the package
specification, after the type to which its Entity argument appears. As
with the Invariant aspect, the Check expression is not analyzed until
the end of the visible part of the package, so it may contain forward
references. The Message argument, if present, provides the exception
message used if the invariant is violated. If no Message parameter is
provided, a default message that identifies the line on which the
pragma appears is used.

It is permissible to have multiple Invariants for the same type
entity, in which case they are and'ed together. It is permissible to
use this pragma in Ada 2012 mode, but you cannot have both an invariant
aspect and an invariant pragma for the same entity.

For further details on the use of this pragma, see the Ada 2012
documentation of the Invariant aspect.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Keep_Names" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Keep_Names ([On =&gt;] enumeration_first_subtype_LOCAL_NAME);

The LOCAL_NAME argument must refer to an enumeration first subtype in
the current declarative part. The effect is to retain the enumeration
literal names for use by `Image' and `Value' even if a global
`Discard_Names' pragma applies. This is useful when you want to
generally suppress enumeration literal names and for example you
therefore use a `Discard_Names' pragma in the `gnat.adc' file, but you
want to retain the names for specific enumeration types.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "License" origin = "GNAT RM">
      <DOC>
Syntax:

pragma License (Unrestricted | GPL | Modified_GPL | Restricted);

This pragma is provided to allow automated checking for appropriate
license conditions with respect to the standard and modified GPL.  A
pragma `License', which is a configuration pragma that typically
appears at the start of a source file or in a separate `gnat.adc' file,
specifies the licensing conditions of a unit as follows:

* Unrestricted This is used for a unit that can be freely used with
no license restrictions.  Examples of such units are public domain
units, and units from the Ada Reference Manual.

* GPL This is used for a unit that is licensed under the unmodified
GPL, and which therefore cannot be `with''ed by a restricted unit.

* Modified_GPL This is used for a unit licensed under the GNAT
modified GPL that includes a special exception paragraph that
specifically permits the inclusion of the unit in programs without
requiring the entire program to be released under the GPL.

* Restricted This is used for a unit that is restricted in that it
is not permitted to depend on units that are licensed under the
GPL.  Typical examples are proprietary code that is to be released
under more restrictive license conditions.  Note that restricted
units are permitted to `with' units which are licensed under the
modified GPL (this is the whole point of the modified GPL).


Normally a unit with no `License' pragma is considered to have an
unknown license, and no checking is done.  However, standard GNAT
headers are recognized, and license information is derived from them as
follows.

A GNAT license header starts with a line containing 78 hyphens.
The following comment text is searched for the appearance of any
of the following strings.

If the string "GNU General Public License" is found, then the unit
is assumed to have GPL license, unless the string "As a special
exception" follows, in which case the license is assumed to be
modified GPL.

If one of the strings "This specification is adapted from the Ada
Semantic Interface" or "This specification is derived from the Ada
Reference Manual" is found then the unit is assumed to be
unrestricted.

These default actions means that a program with a restricted license
pragma will automatically get warnings if a GPL unit is inappropriately
`with''ed.  For example, the program:

with Sem_Ch3;
with GNAT.Sockets;
procedure Secret_Stuff is

end Secret_Stuff

if compiled with pragma `License' (`Restricted') in a `gnat.adc' file
will generate the warning:

with Sem_Ch3;
|
&gt;&gt;&gt; license of withed unit "Sem_Ch3" is incompatible

with GNAT.Sockets;
procedure Secret_Stuff is

Here we get a warning on `Sem_Ch3' since it is part of the GNAT
compiler and is licensed under the GPL, but no warning for
`GNAT.Sockets' which is part of the GNAT run time, and is therefore
licensed under the modified GPL.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Link_With" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Link_With (static_string_EXPRESSION {,static_string_EXPRESSION});

This pragma is provided for compatibility with certain Ada 83 compilers.
It has exactly the same effect as pragma `Linker_Options' except that
spaces occurring within one of the string expressions are treated as
separators. For example, in the following case:

pragma Link_With ("-labc -ldef");

results in passing the strings `-labc' and `-ldef' as two separate
arguments to the linker. In addition pragma Link_With allows multiple
arguments, with the same effect as successive pragmas.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Linker_Alias" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Linker_Alias (
[Entity =&gt;] LOCAL_NAME,
[Target =&gt;] static_string_EXPRESSION);

LOCAL_NAME must refer to an object that is declared at the library
level. This pragma establishes the given entity as a linker alias for
the given target. It is equivalent to `__attribute__((alias))' in GNU C
and causes LOCAL_NAME to be emitted as an alias for the symbol
STATIC_STRING_EXPRESSION in the object file, that is to say no space is
reserved for LOCAL_NAME by the assembler and it will be resolved to the
same address as STATIC_STRING_EXPRESSION by the linker.

The actual linker name for the target must be used (e.g. the fully
encoded name with qualification in Ada, or the mangled name in C++), or
it must be declared using the C convention with `pragma Import' or
`pragma Export'.

Not all target machines support this pragma. On some of them it is
accepted only if `pragma Weak_External' has been applied to LOCAL_NAME.

--  Example of the use of pragma Linker_Alias

package p is
i : Integer := 1;
pragma Export (C, i);

new_name_for_i : Integer;
pragma Linker_Alias (new_name_for_i, "i");
end p;
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Linker_Constructor" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Linker_Constructor (procedure_LOCAL_NAME);

PROCEDURE_LOCAL_NAME must refer to a parameterless procedure that is
declared at the library level. A procedure to which this pragma is
applied will be treated as an initialization routine by the linker.  It
is equivalent to `__attribute__((constructor))' in GNU C and causes
PROCEDURE_LOCAL_NAME to be invoked before the entry point of the
executable is called (or immediately after the shared library is loaded
if the procedure is linked in a shared library), in particular before
the Ada run-time environment is set up.

Because of these specific contexts, the set of operations such a
procedure can perform is very limited and the type of objects it can
manipulate is essentially restricted to the elementary types. In
particular, it must only contain code to which pragma Restrictions
(No_Elaboration_Code) applies.

This pragma is used by GNAT to implement auto-initialization of
shared Stand Alone Libraries, which provides a related capability
without the restrictions listed above. Where possible, the use of Stand
Alone Libraries is preferable to the use of this pragma.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Linker_Destructor" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Linker_Destructor (procedure_LOCAL_NAME);

PROCEDURE_LOCAL_NAME must refer to a parameterless procedure that is
declared at the library level. A procedure to which this pragma is
applied will be treated as a finalization routine by the linker.  It is
equivalent to `__attribute__((destructor))' in GNU C and causes
PROCEDURE_LOCAL_NAME to be invoked after the entry point of the
executable has exited (or immediately before the shared library is
unloaded if the procedure is linked in a shared library), in particular
after the Ada run-time environment is shut down.

See `pragma Linker_Constructor' for the set of restrictions that
apply because of these specific contexts.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Linker_Options" origin = "Ada RM">
      <DOC>
Syntax:

pragma Linker_Options (string_expression);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Linker_Section" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Linker_Section (
[Entity  =&gt;] LOCAL_NAME,
[Section =&gt;] static_string_EXPRESSION);

LOCAL_NAME must refer to an object that is declared at the library
level. This pragma specifies the name of the linker section for the
given entity. It is equivalent to `__attribute__((section))' in GNU C
and causes LOCAL_NAME to be placed in the STATIC_STRING_EXPRESSION
section of the executable (assuming the linker doesn't rename the
section).

The compiler normally places library-level objects in standard
sections depending on their type: procedures and functions generally go
in the `.text' section, initialized variables in the `.data' section
and uninitialized variables in the `.bss' section.

Other, special sections may exist on given target machines to map
special hardware, for example I/O ports or flash memory. This pragma is
a means to defer the final layout of the executable to the linker, thus
fully working at the symbolic level with the compiler.

Some file formats do not support arbitrary sections so not all target
machines support this pragma. The use of this pragma may cause a program
execution to be erroneous if it is used to place an entity into an
inappropriate section (e.g. a modified variable into the `.text'
section). See also `pragma Persistent_BSS'.

--  Example of the use of pragma Linker_Section

package IO_Card is
Port_A : Integer;
pragma Volatile (Port_A);
pragma Linker_Section (Port_A, ".bss.port_a");

Port_B : Integer;
pragma Volatile (Port_B);
pragma Linker_Section (Port_B, ".bss.port_b");
end IO_Card;
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "List" origin = "Ada RM">
      <DOC>
Syntax:

pragma List (identifier);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Locking_Policy" origin = "Ada RM">
      <DOC>
Syntax:

pragma Locking_Policy (policy_identifier);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Long_Float" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Long_Float (FLOAT_FORMAT);

FLOAT_FORMAT ::= D_Float | G_Float

This pragma is implemented only in the OpenVMS implementation of GNAT.
It allows control over the internal representation chosen for the
predefined type `Long_Float' and for floating point type
representations with `digits' specified in the range 7 through 15.  For
further details on this pragma, see the `DEC Ada Language Reference
Manual', section 3.5.7b.  Note that to use this pragma, the standard
runtime libraries must be recompiled.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Machine_Attribute" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Machine_Attribute (
[Entity         =&gt;] LOCAL_NAME,
[Attribute_Name =&gt;] static_string_EXPRESSION
[, [Info           =&gt;] static_EXPRESSION] );

Machine-dependent attributes can be specified for types and/or
declarations.  This pragma is semantically equivalent to
`__attribute__((ATTRIBUTE_NAME))' (if INFO is not specified) or
`__attribute__((ATTRIBUTE_NAME(INFO)))' in GNU C, where
`ATTRIBUTE_NAME' is recognized by the compiler middle-end or the
`TARGET_ATTRIBUTE_TABLE' machine specific macro.  A string literal for
the optional parameter INFO is transformed into an identifier, which
may make this pragma unusable for some attributes.  *Note Defining
target-specific uses of `__attribute__': (gccint)Target Attributes,
further information.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Main" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Main
(MAIN_OPTION [, MAIN_OPTION]);

MAIN_OPTION ::=
[Stack_Size              =&gt;] static_integer_EXPRESSION
| [Task_Stack_Size_Default =&gt;] static_integer_EXPRESSION
| [Time_Slicing_Enabled    =&gt;] static_boolean_EXPRESSION

This pragma is provided for compatibility with OpenVMS VAX Systems.  It
has no effect in GNAT, other than being syntax checked.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Main_Storage" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Main_Storage
(MAIN_STORAGE_OPTION [, MAIN_STORAGE_OPTION]);

MAIN_STORAGE_OPTION ::=
[WORKING_STORAGE =&gt;] static_SIMPLE_EXPRESSION
| [TOP_GUARD       =&gt;] static_SIMPLE_EXPRESSION

This pragma is provided for compatibility with OpenVMS VAX Systems.  It
has no effect in GNAT, other than being syntax checked.  Note that the
pragma also has no effect in DEC Ada 83 for OpenVMS Alpha Systems.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "No_Body" origin = "GNAT RM">
      <DOC>
Syntax:

pragma No_Body;

There are a number of cases in which a package spec does not require a
body, and in fact a body is not permitted. GNAT will not permit the
spec to be compiled if there is a body around. The pragma No_Body
allows you to provide a body file, even in a case where no body is
allowed. The body file must contain only comments and a single No_Body
pragma. This is recognized by the compiler as indicating that no body
is logically present.

This is particularly useful during maintenance when a package is
modified in such a way that a body needed before is no longer needed.
The provision of a dummy body with a No_Body pragma ensures that there
is no interference from earlier versions of the package body.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "No_Return" origin = "Ada RM">
      <DOC>
Syntax:

pragma No_Return (procedure_LOCAL_NAME {, procedure_LOCAL_NAME});

Each PROCEDURE_LOCAL_NAME argument must refer to one or more procedure
declarations in the current declarative part.  A procedure to which this
pragma is applied may not contain any explicit `return' statements.  In
addition, if the procedure contains any implicit returns from falling
off the end of a statement sequence, then execution of that implicit
return will cause Program_Error to be raised.

One use of this pragma is to identify procedures whose only purpose
is to raise an exception. Another use of this pragma is to suppress
incorrect warnings about missing returns in functions, where the last
statement of a function statement sequence is a call to such a
procedure.

Note that in Ada 2005 mode, this pragma is part of the language, and
is identical in effect to the pragma as implemented in Ada 95 mode.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "No_Strict_Aliasing" origin = "GNAT RM">
      <DOC>
Syntax:

pragma No_Strict_Aliasing [([Entity =&gt;] type_LOCAL_NAME)];

TYPE_LOCAL_NAME must refer to an access type declaration in the current
declarative part.  The effect is to inhibit strict aliasing
optimization for the given type.  The form with no arguments is a
configuration pragma which applies to all access types declared in
units to which the pragma applies. For a detailed description of the
strict aliasing optimization, and the situations in which it must be
suppressed, see *Note Optimization and Strict Aliasing:
(gnat_ugn)Optimization and Strict Aliasing.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Normalize_Scalars" origin = "Ada RM">
      <DOC>
Syntax:

pragma Normalize_Scalars;

This is a language defined pragma which is fully implemented in GNAT.
The effect is to cause all scalar objects that are not otherwise
initialized to be initialized.  The initial values are implementation
dependent and are as follows:

`Standard.Character'
Objects whose root type is Standard.Character are initialized to
Character'Last unless the subtype range excludes NUL (in which case
NUL is used). This choice will always generate an invalid value if
one exists.

`Standard.Wide_Character'
Objects whose root type is Standard.Wide_Character are initialized
to Wide_Character'Last unless the subtype range excludes NUL (in
which case NUL is used). This choice will always generate an
invalid value if one exists.

`Standard.Wide_Wide_Character'
Objects whose root type is Standard.Wide_Wide_Character are
initialized to the invalid value 16#FFFF_FFFF# unless the subtype
range excludes NUL (in which case NUL is used). This choice will
always generate an invalid value if one exists.

`Integer types'
Objects of an integer type are treated differently depending on
whether negative values are present in the subtype. If no negative
values are present, then all one bits is used as the initial value
except in the special case where zero is excluded from the
subtype, in which case all zero bits are used. This choice will
always generate an invalid value if one exists.

For subtypes with negative values present, the largest negative
number is used, except in the unusual case where this largest
negative number is in the subtype, and the largest positive number
is not, in which case the largest positive value is used. This
choice will always generate an invalid value if one exists.

`Floating-Point Types'
Objects of all floating-point types are initialized to all 1-bits.
For standard IEEE format, this corresponds to a NaN (not a number)
which is indeed an invalid value.

`Fixed-Point Types'
Objects of all fixed-point types are treated as described above
for integers, with the rules applying to the underlying integer
value used to represent the fixed-point value.

`Modular types'
Objects of a modular type are initialized to all one bits, except
in the special case where zero is excluded from the subtype, in
which case all zero bits are used. This choice will always
generate an invalid value if one exists.

`Enumeration types'
Objects of an enumeration type are initialized to all one-bits,
i.e. to the value `2 ** typ'Size - 1' unless the subtype excludes
the literal whose Pos value is zero, in which case a code of zero
is used. This choice will always generate an invalid value if one
exists.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Obsolescent" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Obsolescent;

pragma Obsolescent (
[Message =&gt;] static_string_EXPRESSION
[,[Version =&gt;] Ada_05]]);

pragma Obsolescent (
[Entity  =&gt;] NAME
[,[Message =&gt;] static_string_EXPRESSION
[,[Version =&gt;] Ada_05]] );

This pragma can occur immediately following a declaration of an entity,
including the case of a record component. If no Entity argument is
present, then this declaration is the one to which the pragma applies.
If an Entity parameter is present, it must either match the name of the
entity in this declaration, or alternatively, the pragma can
immediately follow an enumeration type declaration, where the Entity
argument names one of the enumeration literals.

This pragma is used to indicate that the named entity is considered
obsolescent and should not be used. Typically this is used when an API
must be modified by eventually removing or modifying existing
subprograms or other entities. The pragma can be used at an
intermediate stage when the entity is still present, but will be
removed later.

The effect of this pragma is to output a warning message on a
reference to an entity thus marked that the subprogram is obsolescent
if the appropriate warning option in the compiler is activated. If the
Message parameter is present, then a second warning message is given
containing this text. In addition, a reference to the eneity is
considered to be a violation of pragma Restrictions
(No_Obsolescent_Features).

This pragma can also be used as a program unit pragma for a package,
in which case the entity name is the name of the package, and the
pragma indicates that the entire package is considered obsolescent. In
this case a client `with''ing such a package violates the restriction,
and the `with' statement is flagged with warnings if the warning option
is set.

If the Version parameter is present (which must be exactly the
identifier Ada_05, no other argument is allowed), then the indication
of obsolescence applies only when compiling in Ada 2005 mode. This is
primarily intended for dealing with the situations in the predefined
library where subprograms or packages have become defined as
obsolescent in Ada 2005 (e.g. in Ada.Characters.Handling), but may be
used anywhere.

The following examples show typical uses of this pragma:

package p is
pragma Obsolescent (p, Message =&gt; "use pp instead of p");
end p;

package q is
procedure q2;
pragma Obsolescent ("use q2new instead");

type R is new integer;
pragma Obsolescent
(Entity  =&gt; R,
Message =&gt; "use RR in Ada 2005",
Version =&gt; Ada_05);

type M is record
F1 : Integer;
F2 : Integer;
pragma Obsolescent;
F3 : Integer;
end record;

type E is (a, bc, 'd', quack);
pragma Obsolescent (Entity =&gt; bc)
pragma Obsolescent (Entity =&gt; 'd')

function "+"
(a, b : character) return character;
pragma Obsolescent (Entity =&gt; "+");
end;

Note that, as for all pragmas, if you use a pragma argument identifier,
then all subsequent parameters must also use a pragma argument
identifier.  So if you specify "Entity =&gt;" for the Entity argument, and
a Message argument is present, it must be preceded by "Message =&gt;".
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Optimize" origin = "Ada RM">
      <DOC>
Syntax:

pragma Optimize (identifier);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Optimize_Alignment" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Optimize_Alignment (TIME | SPACE | OFF);

This is a configuration pragma which affects the choice of default
alignments for types where no alignment is explicitly specified. There
is a time/space trade-off in the selection of these values. Large
alignments result in more efficient code, at the expense of larger data
space, since sizes have to be increased to match these alignments.
Smaller alignments save space, but the access code is slower. The
normal choice of default alignments (which is what you get if you do
not use this pragma, or if you use an argument of OFF), tries to
balance these two requirements.

Specifying SPACE causes smaller default alignments to be chosen in
two cases.  First any packed record is given an alignment of 1. Second,
if a size is given for the type, then the alignment is chosen to avoid
increasing this size. For example, consider:

type R is record
X : Integer;
Y : Character;
end record;

for R'Size use 5*8;

In the default mode, this type gets an alignment of 4, so that access
to the Integer field X are efficient. But this means that objects of
the type end up with a size of 8 bytes. This is a valid choice, since
sizes of objects are allowed to be bigger than the size of the type,
but it can waste space if for example fields of type R appear in an
enclosing record. If the above type is compiled in `Optimize_Alignment
(Space)' mode, the alignment is set to 1.

Specifying TIME causes larger default alignments to be chosen in the
case of small types with sizes that are not a power of 2. For example,
consider:

type R is record
A : Character;
B : Character;
C : Boolean;
end record;

pragma Pack (R);
for R'Size use 17;

The default alignment for this record is normally 1, but if this type is
compiled in `Optimize_Alignment (Time)' mode, then the alignment is set
to 4, which wastes space for objects of the type, since they are now 4
bytes long, but results in more efficient access when the whole record
is referenced.

As noted above, this is a configuration pragma, and there is a
requirement that all units in a partition be compiled with a consistent
setting of the optimization setting. This would normally be achieved by
use of a configuration pragma file containing the appropriate setting.
The exception to this rule is that units with an explicit configuration
pragma in the same file as the source unit are excluded from the
consistency check, as are all predefined units. The latter are compiled
by default in pragma Optimize_Alignment (Off) mode if no pragma appears
at the start of the file.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Ordered" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Ordered (enumeration_first_subtype_LOCAL_NAME);

Most enumeration types are from a conceptual point of view unordered.
For example, consider:

type Color is (Red, Blue, Green, Yellow);

By Ada semantics `Blue &gt; Red' and `Green &gt; Blue', but really these
relations make no sense; the enumeration type merely specifies a set of
possible colors, and the order is unimportant.

For unordered enumeration types, it is generally a good idea if
clients avoid comparisons (other than equality or inequality) and
explicit ranges. (A _client_ is a unit where the type is referenced,
other than the unit where the type is declared, its body, and its
subunits.)  For example, if code buried in some client says:

if Current_Color &lt; Yellow then ...
if Current_Color in Blue .. Green then ...

then the client code is relying on the order, which is undesirable.  It
makes the code hard to read and creates maintenance difficulties if
entries have to be added to the enumeration type. Instead, the code in
the client should list the possibilities, or an appropriate subtype
should be declared in the unit that declares the original enumeration
type. E.g., the following subtype could be declared along with the type
`Color':

subtype RBG is Color range Red .. Green;

and then the client could write:

if Current_Color in RBG then ...
if Current_Color = Blue or Current_Color = Green then ...

However, some enumeration types are legitimately ordered from a
conceptual point of view. For example, if you declare:

type Day is (Mon, Tue, Wed, Thu, Fri, Sat, Sun);

then the ordering imposed by the language is reasonable, and clients
can depend on it, writing for example:

if D in Mon .. Fri then ...
if D &lt; Wed then ...

The pragma `Ordered' is provided to mark enumeration types that are
conceptually ordered, alerting the reader that clients may depend on
the ordering. GNAT provides a pragma to mark enumerations as ordered
rather than one to mark them as unordered, since in our experience, the
great majority of enumeration types are conceptually unordered.

The types `Boolean', `Character', `Wide_Character', and
`Wide_Wide_Character' are considered to be ordered types, so each is
declared with a pragma `Ordered' in package `Standard'.

Normally pragma `Ordered' serves only as documentation and a guide
for coding standards, but GNAT provides a warning switch `-gnatw.u' that
requests warnings for inappropriate uses (comparisons and explicit
subranges) for unordered types. If this switch is used, then any
enumeration type not marked with pragma `Ordered' will be considered as
unordered, and will generate warnings for inappropriate uses.

For additional information please refer to the description of the
`-gnatw.u' switch in the GNAT Pro User's Guide.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Pack" origin = "Ada RM">
      <DOC>
Syntax:

pragma Pack (first_subtype_local_name);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Page" origin = "Ada RM">
      <DOC>
Syntax:

pragma Page;
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Partition_Elaboration_Policy" origin = "Ada RM">
      <DOC>
Syntax:

pragma Partition_Elaboration_Policy;
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Passive" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Passive [(Semaphore | No)];

Syntax checked, but otherwise ignored by GNAT.  This is recognized for
compatibility with DEC Ada 83 implementations, where it is used within a
task definition to request that a task be made passive.  If the argument
`Semaphore' is present, or the argument is omitted, then DEC Ada 83
treats the pragma as an assertion that the containing task is passive
and that optimization of context switch with this task is permitted and
desired.  If the argument `No' is present, the task must not be
optimized.  GNAT does not attempt to optimize any tasks in this manner
(since protected objects are available in place of passive tasks).
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Persistent_BSS" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Persistent_BSS [(LOCAL_NAME)]

This pragma allows selected objects to be placed in the
`.persistent_bss' section. On some targets the linker and loader
provide for special treatment of this section, allowing a program to be
reloaded without affecting the contents of this data (hence the name
persistent).

There are two forms of usage. If an argument is given, it must be the
local name of a library level object, with no explicit initialization
and whose type is potentially persistent. If no argument is given, then
the pragma is a configuration pragma, and applies to all library level
objects with no explicit initialization of potentially persistent types.

A potentially persistent type is a scalar type, or a non-tagged,
non-discriminated record, all of whose components have no explicit
initialization and are themselves of a potentially persistent type, or
an array, all of whose constraints are static, and whose component type
is potentially persistent.

If this pragma is used on a target where this feature is not
supported, then the pragma will be ignored. See also `pragma
Linker_Section'.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Polling" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Polling (ON | OFF);

This pragma controls the generation of polling code.  This is normally
off.  If `pragma Polling (ON)' is used then periodic calls are
generated to the routine `Ada.Exceptions.Poll'.  This routine is a
separate unit in the runtime library, and can be found in file
`a-excpol.adb'.

Pragma `Polling' can appear as a configuration pragma (for example it
can be placed in the `gnat.adc' file) to enable polling globally, or it
can be used in the statement or declaration sequence to control polling
more locally.

A call to the polling routine is generated at the start of every
loop and at the start of every subprogram call.  This guarantees that
the `Poll' routine is called frequently, and places an upper bound
(determined by the complexity of the code) on the period between two
`Poll' calls.

The primary purpose of the polling interface is to enable
asynchronous aborts on targets that cannot otherwise support it (for
example Windows NT), but it may be used for any other purpose requiring
periodic polling.  The standard version is null, and can be replaced by
a user program.  This will require re-compilation of the
`Ada.Exceptions' package that can be found in files `a-except.ads' and
`a-except.adb'.

A standard alternative unit (in file `4wexcpol.adb' in the standard
GNAT distribution) is used to enable the asynchronous abort capability
on targets that do not normally support the capability.  The version of
`Poll' in this file makes a call to the appropriate runtime routine to
test for an abort condition.

Note that polling can also be enabled by use of the `-gnatP' switch.
*Note Switches for gcc: (gnat_ugn)Switches for gcc, for details.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Postcondition" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Postcondition (
[Check   =&gt;] Boolean_Expression
[,[Message =&gt;] String_Expression]);

The `Postcondition' pragma allows specification of automatic
postcondition checks for subprograms. These checks are similar to
assertions, but are automatically inserted just prior to the return
statements of the subprogram with which they are associated (including
implicit returns at the end of procedure bodies and associated
exception handlers).

In addition, the boolean expression which is the condition which
must be true may contain references to function'Result in the case of a
function to refer to the returned value.

`Postcondition' pragmas may appear either immediate following the
(separate) declaration of a subprogram, or at the start of the
declarations of a subprogram body. Only other pragmas may intervene
(that is appear between the subprogram declaration and its
postconditions, or appear before the postcondition in the declaration
sequence in a subprogram body). In the case of a postcondition
appearing after a subprogram declaration, the formal arguments of the
subprogram are visible, and can be referenced in the postcondition
expressions.

The postconditions are collected and automatically tested just
before any return (implicit or explicit) in the subprogram body.  A
postcondition is only recognized if postconditions are active at the
time the pragma is encountered. The compiler switch `gnata' turns on
all postconditions by default, and pragma `Check_Policy' with an
identifier of `Postcondition' can also be used to control whether
postconditions are active.

The general approach is that postconditions are placed in the spec
if they represent functional aspects which make sense to the client.
For example we might have:

function Direction return Integer;
pragma Postcondition
(Direction'Result = +1
or else
Direction'Result = -1);

which serves to document that the result must be +1 or -1, and will
test that this is the case at run time if postcondition checking is
active.

Postconditions within the subprogram body can be used to check that
some internal aspect of the implementation, not visible to the client,
is operating as expected.  For instance if a square root routine keeps
an internal counter of the number of times it is called, then we might
have the following postcondition:

Sqrt_Calls : Natural := 0;

function Sqrt (Arg : Float) return Float is
pragma Postcondition
(Sqrt_Calls = Sqrt_Calls'Old + 1);

end Sqrt

As this example, shows, the use of the `Old' attribute is often useful
in postconditions to refer to the state on entry to the subprogram.

Note that postconditions are only checked on normal returns from the
subprogram. If an abnormal return results from raising an exception,
then the postconditions are not checked.

If a postcondition fails, then the exception
`System.Assertions.Assert_Failure' is raised. If a message argument was
supplied, then the given string will be used as the exception message.
If no message argument was supplied, then the default message has the
form "Postcondition failed at file:line". The exception is raised in
the context of the subprogram body, so it is possible to catch
postcondition failures within the subprogram body itself.

Within a package spec, normal visibility rules in Ada would prevent
forward references within a postcondition pragma to functions defined
later in the same package. This would introduce undesirable ordering
constraints. To avoid this problem, all postcondition pragmas are
analyzed at the end of the package spec, allowing forward references.

The following example shows that this even allows mutually recursive
postconditions as in:

package Parity_Functions is
function Odd  (X : Natural) return Boolean;
pragma Postcondition
(Odd'Result =
(x = 1
or else
(x /= 0 and then Even (X - 1))));

function Even (X : Natural) return Boolean;
pragma Postcondition
(Even'Result =
(x = 0
or else
(x /= 1 and then Odd (X - 1))));

end Parity_Functions;

There are no restrictions on the complexity or form of conditions used
within `Postcondition' pragmas.  The following example shows that it is
even possible to verify performance behavior.

package Sort is

Performance : constant Float;
--  Performance constant set by implementation
--  to match target architecture behavior.

procedure Treesort (Arg : String);
--  Sorts characters of argument using N*logN sort
pragma Postcondition
(Float (Clock - Clock'Old) &lt;=
Float (Arg'Length) *
log (Float (Arg'Length)) *
Performance);
end Sort;

Note: postcondition pragmas associated with subprograms that are marked
as Inline_Always, or those marked as Inline with front-end inlining
(-gnatN option set) are accepted and legality-checked by the compiler,
but are ignored at run-time even if postcondition checking is enabled.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Precondition" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Precondition (
[Check   =&gt;] Boolean_Expression
[,[Message =&gt;] String_Expression]);

The `Precondition' pragma is similar to `Postcondition' except that the
corresponding checks take place immediately upon entry to the
subprogram, and if a precondition fails, the exception is raised in the
context of the caller, and the attribute 'Result cannot be used within
the precondition expression.

Otherwise, the placement and visibility rules are identical to those
described for postconditions. The following is an example of use within
a package spec:

package Math_Functions is

function Sqrt (Arg : Float) return Float;
pragma Precondition (Arg &gt;= 0.0)

end Math_Functions;

`Precondition' pragmas may appear either immediate following the
(separate) declaration of a subprogram, or at the start of the
declarations of a subprogram body. Only other pragmas may intervene
(that is appear between the subprogram declaration and its
postconditions, or appear before the postcondition in the declaration
sequence in a subprogram body).

Note: postcondition pragmas associated with subprograms that are
marked as Inline_Always, or those marked as Inline with front-end
inlining (-gnatN option set) are accepted and legality-checked by the
compiler, but are ignored at run-time even if postcondition checking is
enabled.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Preelaborable_Initialization" origin = "Ada RM">
      <DOC>
Syntax:

pragma Preelaborable_Initialization (direct_name);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Preelaborate" origin = "Ada RM">
      <DOC>
Syntax:

pragma Preelaborate [(library_unit_name)];
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Priority" origin = "Ada RM">
      <DOC>
Syntax:

pragma Priority (expression);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Priority_Specific_Dispatching" origin = "Ada RM">
      <DOC>
Syntax:

pragma Priority_Specific_Dispatching;
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Profile" origin = "Ada RM">
      <DOC>
Syntax:

pragma Profile;
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Profile (Ravenscar)" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Profile (Ravenscar);

A configuration pragma that establishes the following set of
configuration pragmas:

`Task_Dispatching_Policy (FIFO_Within_Priorities)'
[RM D.2.2] Tasks are dispatched following a preemptive
priority-ordered scheduling policy.

`Locking_Policy (Ceiling_Locking)'
[RM D.3] While tasks and interrupts execute a protected action,
they inherit the ceiling priority of the corresponding protected
object.
plus the following set of restrictions:

`Max_Entry_Queue_Length = 1'
Defines the maximum number of calls that are queued on a
(protected) entry.  Note that this restrictions is checked at run
time. Violation of this restriction results in the raising of
Program_Error exception at the point of the call. For the Profile
(Ravenscar) the value of Max_Entry_Queue_Length is always 1 and
hence no task can be queued on a protected entry.

`Max_Protected_Entries = 1'
[RM D.7] Specifies the maximum number of entries per protected
type. The bounds of every entry family of a protected unit shall
be static, or shall be defined by a discriminant of a subtype
whose corresponding bound is static.  For the Profile (Ravenscar)
the value of Max_Protected_Entries is always 1.

`Max_Task_Entries = 0'
[RM D.7] Specifies the maximum number of entries per task.  The
bounds of every entry family of a task unit shall be static, or
shall be defined by a discriminant of a subtype whose
corresponding bound is static.  A value of zero indicates that no
rendezvous are possible.  For the Profile (Ravenscar), the value
of Max_Task_Entries is always 0 (zero).

`No_Abort_Statements'
[RM D.7] There are no abort_statements, and there are no calls to
Task_Identification.Abort_Task.

`No_Asynchronous_Control'
There are no semantic dependences on the package
Asynchronous_Task_Control.

`No_Calendar'
There are no semantic dependencies on the package Ada.Calendar.

`No_Dynamic_Attachment'
There is no call to any of the operations defined in package
Ada.Interrupts (Is_Reserved, Is_Attached, Current_Handler,
Attach_Handler, Exchange_Handler, Detach_Handler, and Reference).

`No_Dynamic_Priorities'
[RM D.7] There are no semantic dependencies on the package
Dynamic_Priorities.

`No_Implicit_Heap_Allocations'
[RM D.7] No constructs are allowed to cause implicit heap
allocation.

`No_Local_Protected_Objects'
Protected objects and access types that designate such objects
shall be declared only at library level.

`No_Local_Timing_Events'
[RM D.7] All objects of type Ada.Timing_Events.Timing_Event are
declared at the library level.

`No_Protected_Type_Allocators'
There are no allocators for protected types or types containing
protected subcomponents.

`No_Relative_Delay'
There are no delay_relative statements.

`No_Requeue_Statements'
Requeue statements are not allowed.

`No_Select_Statements'
There are no select_statements.

`No_Specific_Termination_Handlers'
[RM D.7] There are no calls to
Ada.Task_Termination.Set_Specific_Handler or to
Ada.Task_Termination.Specific_Handler.

`No_Task_Allocators'
[RM D.7] There are no allocators for task types or types
containing task subcomponents.

`No_Task_Attributes_Package'
There are no semantic dependencies on the Ada.Task_Attributes
package.

`No_Task_Hierarchy'
[RM D.7] All (non-environment) tasks depend directly on the
environment task of the partition.

`No_Task_Termination'
Tasks which terminate are erroneous.

`No_Unchecked_Conversion'
There are no semantic dependencies on the Ada.Unchecked_Conversion
package.

`No_Unchecked_Deallocation'
There are no semantic dependencies on the
Ada.Unchecked_Deallocation package.

`Simple_Barriers'
Entry barrier condition expressions shall be either static boolean
expressions or boolean objects which are declared in the protected
type which contains the entry.

This set of configuration pragmas and restrictions correspond to the
definition of the "Ravenscar Profile" for limited tasking, devised and
published by the `International Real-Time Ada Workshop', 1997, and
whose most recent description is available at
`http://www-users.cs.york.ac.uk/~burns/ravenscar.ps'.

The original definition of the profile was revised at subsequent
IRTAW meetings. It has been included in the ISO `Guide for the Use of
the Ada Programming Language in High Integrity Systems', and has been
approved by ISO/IEC/SC22/WG9 for inclusion in the next revision of the
standard. The formal definition given by the Ada Rapporteur Group (ARG)
can be found in two Ada Issues (AI-249 and AI-305) available at
`http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00249.TXT' and
`http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00305.TXT'
respectively.

The above set is a superset of the restrictions provided by pragma
`Profile (Restricted)', it includes six additional restrictions
(`Simple_Barriers', `No_Select_Statements', `No_Calendar',
`No_Implicit_Heap_Allocations', `No_Relative_Delay' and
`No_Task_Termination').  This means that pragma `Profile (Ravenscar)',
like the pragma `Profile (Restricted)', automatically causes the use of
a simplified, more efficient version of the tasking run-time system.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Profile (Restricted)" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Profile (Restricted);

A configuration pragma that establishes the following set of
restrictions:

* No_Abort_Statements

* No_Entry_Queue

* No_Task_Hierarchy

* No_Task_Allocators

* No_Dynamic_Priorities

* No_Terminate_Alternatives

* No_Dynamic_Attachment

* No_Protected_Type_Allocators

* No_Local_Protected_Objects

* No_Requeue_Statements

* No_Task_Attributes_Package

* Max_Asynchronous_Select_Nesting =  0

* Max_Task_Entries =  0

* Max_Protected_Entries = 1

* Max_Select_Alternatives = 0

This set of restrictions causes the automatic selection of a simplified
version of the run time that provides improved performance for the
limited set of tasking functionality permitted by this set of
restrictions.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Psect_Object" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Psect_Object (
[Internal =&gt;] LOCAL_NAME,
[, [External =&gt;] EXTERNAL_SYMBOL]
[, [Size     =&gt;] EXTERNAL_SYMBOL]);

EXTERNAL_SYMBOL ::=
IDENTIFIER
| static_string_EXPRESSION

This pragma is identical in effect to pragma `Common_Object'.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Pure" origin = "Ada RM">
      <DOC>
Syntax:

pragma Pure [(library_unit_name)];
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Pure_Function" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Pure_Function ([Entity =&gt;] function_LOCAL_NAME);

This pragma appears in the same declarative part as a function
declaration (or a set of function declarations if more than one
overloaded declaration exists, in which case the pragma applies to all
entities).  It specifies that the function `Entity' is to be considered
pure for the purposes of code generation.  This means that the compiler
can assume that there are no side effects, and in particular that two
calls with identical arguments produce the same result.  It also means
that the function can be used in an address clause.

Note that, quite deliberately, there are no static checks to try to
ensure that this promise is met, so `Pure_Function' can be used with
functions that are conceptually pure, even if they do modify global
variables.  For example, a square root function that is instrumented to
count the number of times it is called is still conceptually pure, and
can still be optimized, even though it modifies a global variable (the
count).  Memo functions are another example (where a table of previous
calls is kept and consulted to avoid re-computation).

Note also that the normal rules excluding optimization of subprograms
in pure units (when parameter types are descended from System.Address,
or when the full view of a parameter type is limited), do not apply for
the Pure_Function case. If you explicitly specify Pure_Function, the
compiler may optimize away calls with identical arguments, and if that
results in unexpected behavior, the proper action is not to use the
pragma for subprograms that are not (conceptually) pure.

Note: Most functions in a `Pure' package are automatically pure, and
there is no need to use pragma `Pure_Function' for such functions.  One
exception is any function that has at least one formal of type
`System.Address' or a type derived from it.  Such functions are not
considered pure by default, since the compiler assumes that the
`Address' parameter may be functioning as a pointer and that the
referenced data may change even if the address value does not.
Similarly, imported functions are not considered to be pure by default,
since there is no way of checking that they are in fact pure.  The use
of pragma `Pure_Function' for such a function will override these
default assumption, and cause the compiler to treat a designated
subprogram as pure in these cases.

Note: If pragma `Pure_Function' is applied to a renamed function, it
applies to the underlying renamed function.  This can be used to
disambiguate cases of overloading where some but not all functions in a
set of overloaded functions are to be designated as pure.

If pragma `Pure_Function' is applied to a library level function, the
function is also considered pure from an optimization point of view,
but the unit is not a Pure unit in the categorization sense. So for
example, a function thus marked is free to `with' non-pure units.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Queuing_Policy" origin = "Ada RM">
      <DOC>
Syntax:

pragma Queuing_Policy (policy_identifier);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Relative_Deadline" origin = "Ada RM">
      <DOC>
Syntax:

pragma Relative_Deadline;
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Remote_Call_Interface" origin = "Ada RM">
      <DOC>
Syntax:

pragma Remote_Call_Interface [(library_unit_name)];
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Remote_Types" origin = "Ada RM">
      <DOC>
Syntax:

pragma Remote_Types [(library_unit_name)];
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Restriction_Warnings" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Restriction_Warnings
(restriction_IDENTIFIER {, restriction_IDENTIFIER});

This pragma allows a series of restriction identifiers to be specified
(the list of allowed identifiers is the same as for pragma
`Restrictions'). For each of these identifiers the compiler checks for
violations of the restriction, but generates a warning message rather
than an error message if the restriction is violated.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Restrictions" origin = "Ada RM">
      <DOC>
Syntax:

pragma Restrictions (restriction{, restriction});
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Reviewable" origin = "Ada RM">
      <DOC>
Syntax:

pragma Reviewable;
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Shared" origin = "GNAT RM">
      <DOC>
This pragma is provided for compatibility with Ada 83. The syntax and
semantics are identical to pragma Atomic.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Shared_Passive" origin = "Ada RM">
      <DOC>
Syntax:

pragma Shared_Passive [(library_unit_name)];
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Short_Circuit_And_Or" origin = "GNAT RM">
      <DOC>
This configuration pragma causes any occurrence of the AND operator
applied to operands of type Standard.Boolean to be short-circuited
(i.e. the AND operator is treated as if it were AND THEN). Or is
similarly treated as OR ELSE. This may be useful in the context of
certification protocols requiring the use of short-circuited logical
operators. If this configuration pragma occurs locally within the file
being compiled, it applies only to the file being compiled.  There is
no requirement that all units in a partition use this option.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Short_Descriptors" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Short_Descriptors

In VMS versions of the compiler, this configuration pragma causes all
occurrences of the mechanism types Descriptor[_xxx] to be treated as
Short_Descriptor[_xxx]. This is helpful in porting legacy applications
from a 32-bit environment to a 64-bit environment. This pragma is
ignored for non-VMS versions.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Source_File_Name" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Source_File_Name (
[Unit_Name   =&gt;] unit_NAME,
Spec_File_Name =&gt;  STRING_LITERAL,
[Index =&gt; INTEGER_LITERAL]);

pragma Source_File_Name (
[Unit_Name   =&gt;] unit_NAME,
Body_File_Name =&gt;  STRING_LITERAL,
[Index =&gt; INTEGER_LITERAL]);

Use this to override the normal naming convention.  It is a
configuration pragma, and so has the usual applicability of
configuration pragmas (i.e. it applies to either an entire partition,
or to all units in a compilation, or to a single unit, depending on how
it is used.  UNIT_NAME is mapped to FILE_NAME_LITERAL.  The identifier
for the second argument is required, and indicates whether this is the
file name for the spec or for the body.

The optional Index argument should be used when a file contains
multiple units, and when you do not want to use `gnatchop' to separate
then into multiple files (which is the recommended procedure to limit
the number of recompilations that are needed when some sources change).
For instance, if the source file `source.ada' contains

package B is

end B;

with B;
procedure A is
begin

end A;

you could use the following configuration pragmas:

pragma Source_File_Name
(B, Spec_File_Name =&gt; "source.ada", Index =&gt; 1);
pragma Source_File_Name
(A, Body_File_Name =&gt; "source.ada", Index =&gt; 2);

Note that the `gnatname' utility can also be used to generate those
configuration pragmas.

Another form of the `Source_File_Name' pragma allows the
specification of patterns defining alternative file naming schemes to
apply to all files.

pragma Source_File_Name
(  [Spec_File_Name  =&gt;] STRING_LITERAL
[,[Casing          =&gt;] CASING_SPEC]
[,[Dot_Replacement =&gt;] STRING_LITERAL]);

pragma Source_File_Name
(  [Body_File_Name  =&gt;] STRING_LITERAL
[,[Casing          =&gt;] CASING_SPEC]
[,[Dot_Replacement =&gt;] STRING_LITERAL]);

pragma Source_File_Name
(  [Subunit_File_Name =&gt;] STRING_LITERAL
[,[Casing            =&gt;] CASING_SPEC]
[,[Dot_Replacement   =&gt;] STRING_LITERAL]);

CASING_SPEC ::= Lowercase | Uppercase | Mixedcase

The first argument is a pattern that contains a single asterisk
indicating the point at which the unit name is to be inserted in the
pattern string to form the file name.  The second argument is optional.
If present it specifies the casing of the unit name in the resulting
file name string.  The default is lower case.  Finally the third
argument allows for systematic replacement of any dots in the unit name
by the specified string literal.

A pragma Source_File_Name cannot appear after a *Note Pragma
Source_File_Name_Project::.

For more details on the use of the `Source_File_Name' pragma, *Note
Using Other File Names: (gnat_ugn)Using Other File Names, and *Note
Alternative File Naming Schemes: (gnat_ugn)Alternative File Naming
Schemes.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Source_File_Name_Project" origin = "GNAT RM">
      <DOC>
This pragma has the same syntax and semantics as pragma
Source_File_Name.  It is only allowed as a stand alone configuration
pragma.  It cannot appear after a *Note Pragma Source_File_Name::, and
most importantly, once pragma Source_File_Name_Project appears, no
further Source_File_Name pragmas are allowed.

The intention is that Source_File_Name_Project pragmas are always
generated by the Project Manager in a manner consistent with the naming
specified in a project file, and when naming is controlled in this
manner, it is not permissible to attempt to modify this naming scheme
using Source_File_Name pragmas (which would not be known to the project
manager).
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Source_Reference" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Source_Reference (INTEGER_LITERAL, STRING_LITERAL);

This pragma must appear as the first line of a source file.
INTEGER_LITERAL is the logical line number of the line following the
pragma line (for use in error messages and debugging information).
STRING_LITERAL is a static string constant that specifies the file name
to be used in error messages and debugging information.  This is most
notably used for the output of `gnatchop' with the `-r' switch, to make
sure that the original unchopped source file is the one referred to.

The second argument must be a string literal, it cannot be a static
string expression other than a string literal.  This is because its
value is needed for error messages issued by all phases of the compiler.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Storage_Size" origin = "Ada RM">
      <DOC>
Syntax:

pragma Storage_Size (expression);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Stream_Convert" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Stream_Convert (
[Entity =&gt;] type_LOCAL_NAME,
[Read   =&gt;] function_NAME,
[Write  =&gt;] function_NAME);

This pragma provides an efficient way of providing stream functions for
types defined in packages.  Not only is it simpler to use than declaring
the necessary functions with attribute representation clauses, but more
significantly, it allows the declaration to made in such a way that the
stream packages are not loaded unless they are needed.  The use of the
Stream_Convert pragma adds no overhead at all, unless the stream
attributes are actually used on the designated type.

The first argument specifies the type for which stream functions are
provided.  The second parameter provides a function used to read values
of this type.  It must name a function whose argument type may be any
subtype, and whose returned type must be the type given as the first
argument to the pragma.

The meaning of the READ parameter is that if a stream attribute
directly or indirectly specifies reading of the type given as the first
parameter, then a value of the type given as the argument to the Read
function is read from the stream, and then the Read function is used to
convert this to the required target type.

Similarly the WRITE parameter specifies how to treat write attributes
that directly or indirectly apply to the type given as the first
parameter.  It must have an input parameter of the type specified by
the first parameter, and the return type must be the same as the input
type of the Read function.  The effect is to first call the Write
function to convert to the given stream type, and then write the result
type to the stream.

The Read and Write functions must not be overloaded subprograms.  If
necessary renamings can be supplied to meet this requirement.  The
usage of this attribute is best illustrated by a simple example, taken
from the GNAT implementation of package Ada.Strings.Unbounded:

function To_Unbounded (S : String)
return Unbounded_String
renames To_Unbounded_String;

pragma Stream_Convert
(Unbounded_String, To_Unbounded, To_String);

The specifications of the referenced functions, as given in the Ada
Reference Manual are:

function To_Unbounded_String (Source : String)
return Unbounded_String;

function To_String (Source : Unbounded_String)
return String;

The effect is that if the value of an unbounded string is written to a
stream, then the representation of the item in the stream is in the
same format that would be used for `Standard.String'Output', and this
same representation is expected when a value of this type is read from
the stream. Note that the value written always includes the bounds,
even for Unbounded_String'Write, since Unbounded_String is not an array
type.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Style_Checks" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Style_Checks (string_LITERAL | ALL_CHECKS |
On | Off [, LOCAL_NAME]);

This pragma is used in conjunction with compiler switches to control the
built in style checking provided by GNAT.  The compiler switches, if
set, provide an initial setting for the switches, and this pragma may
be used to modify these settings, or the settings may be provided
entirely by the use of the pragma.  This pragma can be used anywhere
that a pragma is legal, including use as a configuration pragma
(including use in the `gnat.adc' file).

The form with a string literal specifies which style options are to
be activated.  These are additive, so they apply in addition to any
previously set style check options.  The codes for the options are the
same as those used in the `-gnaty' switch to `gcc' or `gnatmake'.  For
example the following two methods can be used to enable layout checking:

*      pragma Style_Checks ("l");

*      gcc -c -gnatyl ...

The form ALL_CHECKS activates all standard checks (its use is equivalent
to the use of the `gnaty' switch with no options.  *Note GNAT Pro
User's Guide: (gnat_ugn)Top, for details.)

Note: the behavior is slightly different in GNAT mode (`-gnatg'
used).  In this case, ALL_CHECKS implies the standard set of GNAT mode
style check options (i.e. equivalent to -gnatyg).

The forms with `Off' and `On' can be used to temporarily disable
style checks as shown in the following example:

pragma Style_Checks ("k"); -- requires keywords in lower case
pragma Style_Checks (Off); -- turn off style checks
NULL;                      -- this will not generate an error message
pragma Style_Checks (On);  -- turn style checks back on
NULL;                      -- this will generate an error message

Finally the two argument form is allowed only if the first argument is
`On' or `Off'.  The effect is to turn of semantic style checks for the
specified entity, as shown in the following example:

pragma Style_Checks ("r"); -- require consistency of identifier casing
Arg : Integer;
Rf1 : Integer := ARG;      -- incorrect, wrong case
pragma Style_Checks (Off, Arg);
Rf2 : Integer := ARG;      -- OK, no error
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Subtitle" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Subtitle ([Subtitle =&gt;] STRING_LITERAL);

This pragma is recognized for compatibility with other Ada compilers
but is ignored by GNAT.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Suppress" origin = "Ada RM">
      <DOC>
Syntax:

pragma Suppress (Identifier [, [On =&gt;] Name]);

This is a standard pragma, and supports all the check names required in
the RM. It is included here because GNAT recognizes one additional check
name: `Alignment_Check' which can be used to suppress alignment checks
on addresses used in address clauses. Such checks can also be suppressed
by suppressing range checks, but the specific use of `Alignment_Check'
allows suppression of alignment checks without suppressing other range
checks.

Note that pragma Suppress gives the compiler permission to omit
checks, but does not require the compiler to omit checks. The compiler
will generate checks if they are essentially free, even when they are
suppressed. In particular, if the compiler can prove that a certain
check will necessarily fail, it will generate code to do an
unconditional "raise", even if checks are suppressed. The compiler
warns in this case.

Of course, run-time checks are omitted whenever the compiler can
prove that they will not fail, whether or not checks are suppressed.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Suppress_All" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Suppress_All;

This pragma can appear anywhere within a unit.  The effect is to apply
`Suppress (All_Checks)' to the unit in which it appears.  This pragma
is implemented for compatibility with DEC Ada 83 usage where it appears
at the end of a unit, and for compatibility with Rational Ada, where it
appears as a program unit pragma.  The use of the standard Ada pragma
`Suppress (All_Checks)' as a normal configuration pragma is the
preferred usage in GNAT.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Suppress_Exception_Locations" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Suppress_Exception_Locations;

In normal mode, a raise statement for an exception by default generates
an exception message giving the file name and line number for the
location of the raise. This is useful for debugging and logging
purposes, but this entails extra space for the strings for the
messages. The configuration pragma `Suppress_Exception_Locations' can
be used to suppress the generation of these strings, with the result
that space is saved, but the exception message for such raises is null.
This configuration pragma may appear in a global configuration pragma
file, or in a specific unit as usual. It is not required that this
pragma be used consistently within a partition, so it is fine to have
some units within a partition compiled with this pragma and others
compiled in normal mode without it.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Suppress_Initialization" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Suppress_Initialization ([Entity =&gt;] type_Name);

This pragma suppresses any implicit or explicit initialization
associated with the given type name for all variables of this type.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Task_Dispatching_Policy" origin = "Ada RM">
      <DOC>
Syntax:

pragma Task_Dispatching_Policy (policy_identifier);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Task_Info" origin = "GNAT RM">
      <DOC>
Syntax

pragma Task_Info (EXPRESSION);

This pragma appears within a task definition (like pragma `Priority')
and applies to the task in which it appears.  The argument must be of
type `System.Task_Info.Task_Info_Type'.  The `Task_Info' pragma
provides system dependent control over aspects of tasking
implementation, for example, the ability to map tasks to specific
processors.  For details on the facilities available for the version of
GNAT that you are using, see the documentation in the spec of package
System.Task_Info in the runtime library.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Task_Name" origin = "GNAT RM">
      <DOC>
Syntax

pragma Task_Name (string_EXPRESSION);

This pragma appears within a task definition (like pragma `Priority')
and applies to the task in which it appears.  The argument must be of
type String, and provides a name to be used for the task instance when
the task is created.  Note that this expression is not required to be
static, and in particular, it can contain references to task
discriminants.  This facility can be used to provide different names
for different tasks as they are created, as illustrated in the example
below.

The task name is recorded internally in the run-time structures and
is accessible to tools like the debugger.  In addition the routine
`Ada.Task_Identification.Image' will return this string, with a unique
task address appended.

--  Example of the use of pragma Task_Name

with Ada.Task_Identification;
use Ada.Task_Identification;
with Text_IO; use Text_IO;
procedure t3 is

type Astring is access String;

task type Task_Typ (Name : access String) is
pragma Task_Name (Name.all);
end Task_Typ;

task body Task_Typ is
Nam : constant String := Image (Current_Task);
begin
Put_Line ("--&gt;" &amp; Nam (1 .. 14) &amp; "&lt;--");
end Task_Typ;

type Ptr_Task is access Task_Typ;
Task_Var : Ptr_Task;

begin
Task_Var :=
new Task_Typ (new String'("This is task 1"));
Task_Var :=
new Task_Typ (new String'("This is task 2"));
end;
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Task_Storage" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Task_Storage (
[Task_Type =&gt;] LOCAL_NAME,
[Top_Guard =&gt;] static_integer_EXPRESSION);

This pragma specifies the length of the guard area for tasks.  The guard
area is an additional storage area allocated to a task.  A value of zero
means that either no guard area is created or a minimal guard area is
created, depending on the target.  This pragma can appear anywhere a
`Storage_Size' attribute definition clause is allowed for a task type.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Thread_Local_Storage" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Thread_Local_Storage ([Entity =&gt;] LOCAL_NAME);

This pragma specifies that the specified entity, which must be a
variable declared in a library level package, is to be marked as
"Thread Local Storage" (`TLS'). On systems supporting this (which
include Solaris, GNU/Linux and VxWorks 6), this causes each thread (and
hence each Ada task) to see a distinct copy of the variable.

The variable may not have default initialization, and if there is an
explicit initialization, it must be either `null' for an access
variable, or a static expression for a scalar variable.  This provides
a low level mechanism similar to that provided by the
`Ada.Task_Attributes' package, but much more efficient and is also
useful in writing interface code that will interact with foreign
threads.

If this pragma is used on a system where `TLS' is not supported,
then an error message will be generated and the program will be
rejected.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Time_Slice" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Time_Slice (static_duration_EXPRESSION);

For implementations of GNAT on operating systems where it is possible
to supply a time slice value, this pragma may be used for this purpose.
It is ignored if it is used in a system that does not allow this
control, or if it appears in other than the main program unit.  Note
that the effect of this pragma is identical to the effect of the DEC
Ada 83 pragma of the same name when operating under OpenVMS systems.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Title" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Title (TITLING_OPTION [, TITLING OPTION]);

TITLING_OPTION ::=
[Title    =&gt;] STRING_LITERAL,
| [Subtitle =&gt;] STRING_LITERAL

Syntax checked but otherwise ignored by GNAT.  This is a listing control
pragma used in DEC Ada 83 implementations to provide a title and/or
subtitle for the program listing.  The program listing generated by GNAT
does not have titles or subtitles.

Unlike other pragmas, the full flexibility of named notation is
allowed for this pragma, i.e. the parameters may be given in any order
if named notation is used, and named and positional notation can be
mixed following the normal rules for procedure calls in Ada.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Unchecked_Union" origin = "Ada RM">
      <DOC>
Syntax:

pragma Unchecked_Union (first_subtype_LOCAL_NAME);

This pragma is used to specify a representation of a record type that is
equivalent to a C union. It was introduced as a GNAT implementation
defined pragma in the GNAT Ada 95 mode. Ada 2005 includes an extended
version of this pragma, making it language defined, and GNAT fully
implements this extended version in all language modes (Ada 83, Ada 95,
and Ada 2005). For full details, consult the Ada 2005 Reference Manual,
section B.3.3.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Unimplemented_Unit" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Unimplemented_Unit;

If this pragma occurs in a unit that is processed by the compiler, GNAT
aborts with the message `XXX not implemented', where XXX is the name of
the current compilation unit.  This pragma is intended to allow the
compiler to handle unimplemented library units in a clean manner.

The abort only happens if code is being generated.  Thus you can use
specs of unimplemented packages in syntax or semantic checking mode.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Universal_Aliasing" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Universal_Aliasing [([Entity =&gt;] type_LOCAL_NAME)];

TYPE_LOCAL_NAME must refer to a type declaration in the current
declarative part.  The effect is to inhibit strict type-based aliasing
optimization for the given type.  In other words, the effect is as
though access types designating this type were subject to pragma
No_Strict_Aliasing.  For a detailed description of the strict aliasing
optimization, and the situations in which it must be suppressed, *Note
Optimization and Strict Aliasing: (gnat_ugn)Optimization and Strict
Aliasing.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Universal_Data" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Universal_Data [(library_unit_Name)];

This pragma is supported only for the AAMP target and is ignored for
other targets. The pragma specifies that all library-level objects
(Counter 0 data) associated with the library unit are to be accessed
and updated using universal addressing (24-bit addresses for AAMP5)
rather than the default of 16-bit Data Environment (DENV) addressing.
Use of this pragma will generally result in less efficient code for
references to global data associated with the library unit, but allows
such data to be located anywhere in memory. This pragma is a library
unit pragma, but can also be used as a configuration pragma (including
use in the `gnat.adc' file). The functionality of this pragma is also
available by applying the -univ switch on the compilations of units
where universal addressing of the data is desired.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Unmodified" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Unmodified (LOCAL_NAME {, LOCAL_NAME});

This pragma signals that the assignable entities (variables, `out'
parameters, `in out' parameters) whose names are listed are
deliberately not assigned in the current source unit. This suppresses
warnings about the entities being referenced but not assigned, and in
addition a warning will be generated if one of these entities is in
fact assigned in the same unit as the pragma (or in the corresponding
body, or one of its subunits).

This is particularly useful for clearly signaling that a particular
parameter is not modified, even though the spec suggests that it might
be.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Unreferenced" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Unreferenced (LOCAL_NAME {, LOCAL_NAME});
pragma Unreferenced (library_unit_NAME {, library_unit_NAME});

This pragma signals that the entities whose names are listed are
deliberately not referenced in the current source unit. This suppresses
warnings about the entities being unreferenced, and in addition a
warning will be generated if one of these entities is in fact
referenced in the same unit as the pragma (or in the corresponding
body, or one of its subunits).

This is particularly useful for clearly signaling that a particular
parameter is not referenced in some particular subprogram implementation
and that this is deliberate. It can also be useful in the case of
objects declared only for their initialization or finalization side
effects.

If `LOCAL_NAME' identifies more than one matching homonym in the
current scope, then the entity most recently declared is the one to
which the pragma applies. Note that in the case of accept formals, the
pragma Unreferenced may appear immediately after the keyword `do' which
allows the indication of whether or not accept formals are referenced
or not to be given individually for each accept statement.

The left hand side of an assignment does not count as a reference
for the purpose of this pragma. Thus it is fine to assign to an entity
for which pragma Unreferenced is given.

Note that if a warning is desired for all calls to a given
subprogram, regardless of whether they occur in the same unit as the
subprogram declaration, then this pragma should not be used (calls from
another unit would not be flagged); pragma Obsolescent can be used
instead for this purpose, see *Note Pragma Obsolescent::.

The second form of pragma `Unreferenced' is used within a context
clause. In this case the arguments must be unit names of units
previously mentioned in `with' clauses (similar to the usage of pragma
`Elaborate_All'. The effect is to suppress warnings about unreferenced
units and unreferenced entities within these units.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Unreferenced_Objects" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Unreferenced_Objects (local_subtype_NAME {, local_subtype_NAME});

This pragma signals that for the types or subtypes whose names are
listed, objects which are declared with one of these types or subtypes
may not be referenced, and if no references appear, no warnings are
given.

This is particularly useful for objects which are declared solely
for their initialization and finalization effect. Such variables are
sometimes referred to as RAII variables (Resource Acquisition Is
Initialization). Using this pragma on the relevant type (most typically
a limited controlled type), the compiler will automatically suppress
unwanted warnings about these variables not being referenced.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Unreserve_All_Interrupts" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Unreserve_All_Interrupts;

Normally certain interrupts are reserved to the implementation.  Any
attempt to attach an interrupt causes Program_Error to be raised, as
described in RM C.3.2(22).  A typical example is the `SIGINT' interrupt
used in many systems for a `Ctrl-C' interrupt.  Normally this interrupt
is reserved to the implementation, so that `Ctrl-C' can be used to
interrupt execution.

If the pragma `Unreserve_All_Interrupts' appears anywhere in any
unit in a program, then all such interrupts are unreserved.  This
allows the program to handle these interrupts, but disables their
standard functions.  For example, if this pragma is used, then pressing
`Ctrl-C' will not automatically interrupt execution.  However, a
program can then handle the `SIGINT' interrupt as it chooses.

For a full list of the interrupts handled in a specific
implementation, see the source code for the spec of
`Ada.Interrupts.Names' in file `a-intnam.ads'.  This is a target
dependent file that contains the list of interrupts recognized for a
given target.  The documentation in this file also specifies what
interrupts are affected by the use of the `Unreserve_All_Interrupts'
pragma.

For a more general facility for controlling what interrupts can be
handled, see pragma `Interrupt_State', which subsumes the functionality
of the `Unreserve_All_Interrupts' pragma.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Unsuppress" origin = "Ada RM">
      <DOC>
Syntax:

pragma Unsuppress (IDENTIFIER [, [On =&gt;] NAME]);

This pragma undoes the effect of a previous pragma `Suppress'.  If
there is no corresponding pragma `Suppress' in effect, it has no
effect.  The range of the effect is the same as for pragma `Suppress'.
The meaning of the arguments is identical to that used in pragma
`Suppress'.

One important application is to ensure that checks are on in cases
where code depends on the checks for its correct functioning, so that
the code will compile correctly even if the compiler switches are set
to suppress checks.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Use_VADS_Size" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Use_VADS_Size;

This is a configuration pragma.  In a unit to which it applies, any use
of the 'Size attribute is automatically interpreted as a use of the
'VADS_Size attribute.  Note that this may result in incorrect semantic
processing of valid Ada 95 or Ada 2005 programs.  This is intended to
aid in the handling of existing code which depends on the
interpretation of Size as implemented in the VADS compiler.  See
description of the VADS_Size attribute for further details.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Validity_Checks" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Validity_Checks (string_LITERAL | ALL_CHECKS | On | Off);

This pragma is used in conjunction with compiler switches to control the
built-in validity checking provided by GNAT.  The compiler switches, if
set provide an initial setting for the switches, and this pragma may be
used to modify these settings, or the settings may be provided entirely
by the use of the pragma.  This pragma can be used anywhere that a
pragma is legal, including use as a configuration pragma (including use
in the `gnat.adc' file).

The form with a string literal specifies which validity options are
to be activated.  The validity checks are first set to include only the
default reference manual settings, and then a string of letters in the
string specifies the exact set of options required.  The form of this
string is exactly as described for the `-gnatVx' compiler switch (see
the GNAT users guide for details).  For example the following two
methods can be used to enable validity checking for mode `in' and `in
out' subprogram parameters:

*      pragma Validity_Checks ("im");

*      gcc -c -gnatVim ...

The form ALL_CHECKS activates all standard checks (its use is equivalent
to the use of the `gnatva' switch.

The forms with `Off' and `On' can be used to temporarily disable
validity checks as shown in the following example:

pragma Validity_Checks ("c"); -- validity checks for copies
pragma Validity_Checks (Off); -- turn off validity checks
A := B;                       -- B will not be validity checked
pragma Validity_Checks (On);  -- turn validity checks back on
A := C;                       -- C will be validity checked
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Volatile" origin = "Ada RM">
      <DOC>
Syntax:

pragma Volatile (LOCAL_NAME);

This pragma is defined by the Ada Reference Manual, and the GNAT
implementation is fully conformant with this definition.  The reason it
is mentioned in this section is that a pragma of the same name was
supplied in some Ada 83 compilers, including DEC Ada 83.  The Ada 95 /
Ada 2005 implementation of pragma Volatile is upwards compatible with
the implementation in DEC Ada 83.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Volatile_Components" origin = "Ada RM">
      <DOC>
Syntax:

pragma Volatile_Components (array_local_name);
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Warnings" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Warnings (On | Off);
pragma Warnings (On | Off, LOCAL_NAME);
pragma Warnings (static_string_EXPRESSION);
pragma Warnings (On | Off, static_string_EXPRESSION);

Normally warnings are enabled, with the output being controlled by the
command line switch.  Warnings (`Off') turns off generation of warnings
until a Warnings (`On') is encountered or the end of the current unit.
If generation of warnings is turned off using this pragma, then no
warning messages are output, regardless of the setting of the command
line switches.

The form with a single argument may be used as a configuration
pragma.

If the LOCAL_NAME parameter is present, warnings are suppressed for
the specified entity.  This suppression is effective from the point
where it occurs till the end of the extended scope of the variable
(similar to the scope of `Suppress').

The form with a single static_string_EXPRESSION argument provides
more precise control over which warnings are active. The string is a
list of letters specifying which warnings are to be activated and which
deactivated. The code for these letters is the same as the string used
in the command line switch controlling warnings. For a brief summary,
use the gnatmake command with no arguments, which will generate usage
information containing the list of warnings switches supported. For
full details see *Note Warning Message Control: (gnat_ugn)Warning
Message Control.

The specified warnings will be in effect until the end of the program
or another pragma Warnings is encountered. The effect of the pragma is
cumulative. Initially the set of warnings is the standard default set
as possibly modified by compiler switches. Then each pragma Warning
modifies this set of warnings as specified. This form of the pragma may
also be used as a configuration pragma.

The fourth form, with an On|Off parameter and a string, is used to
control individual messages, based on their text. The string argument
is a pattern that is used to match against the text of individual
warning messages (not including the initial "warning: " tag).

The pattern may contain asterisks, which match zero or more
characters in the message. For example, you can use `pragma Warnings
(Off, "*bits of*unused")' to suppress the warning message `warning: 960
bits of "a" unused'. No other regular expression notations are
permitted. All characters other than asterisk in these three specific
cases are treated as literal characters in the match.

There are two ways to use this pragma. The OFF form can be used as a
configuration pragma. The effect is to suppress all warnings (if any)
that match the pattern string throughout the compilation.

The second usage is to suppress a warning locally, and in this case,
two pragmas must appear in sequence:

pragma Warnings (Off, Pattern);
code where given warning is to be suppressed
pragma Warnings (On, Pattern);

In this usage, the pattern string must match in the Off and On pragmas,
and at least one matching warning must be suppressed.

Note: the debug flag -gnatd.i (`/NOWARNINGS_PRAGMAS' in VMS) can be
used to cause the compiler to entirely ignore all WARNINGS pragmas.
This can be useful in checking whether obsolete pragmas in existing
programs are hiding real problems.

Note: pragma Warnings does not affect the processing of style
messages. See separate entry for pragma Style_Checks for control of
style messages.
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Weak_External" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Weak_External ([Entity =&gt;] LOCAL_NAME);

LOCAL_NAME must refer to an object that is declared at the library
level. This pragma specifies that the given entity should be marked as a
weak symbol for the linker. It is equivalent to `__attribute__((weak))'
in GNU C and causes LOCAL_NAME to be emitted as a weak symbol instead
of a regular symbol, that is to say a symbol that does not have to be
resolved by the linker if used in conjunction with a pragma Import.

When a weak symbol is not resolved by the linker, its address is set
to zero. This is useful in writing interfaces to external modules that
may or may not be linked in the final executable, for example depending
on configuration settings.

If a program references at run time an entity to which this pragma
has been applied, and the corresponding symbol was not resolved at link
time, then the execution of the program is erroneous. It is not
erroneous to take the Address of such an entity, for example to guard
potential references, as shown in the example below.

Some file formats do not support weak symbols so not all target
machines support this pragma.

--  Example of the use of pragma Weak_External

package External_Module is
key : Integer;
pragma Import (C, key);
pragma Weak_External (key);
function Present return boolean;
end External_Module;

with System; use System;
package body External_Module is
function Present return boolean is
begin
return key'Address /= System.Null_Address;
end Present;
end External_Module;
      </DOC>
   </PRAGMA>

   <PRAGMA id = "0" name = "Wide_Character_Encoding" origin = "GNAT RM">
      <DOC>
Syntax:

pragma Wide_Character_Encoding (IDENTIFIER | CHARACTER_LITERAL);

This pragma specifies the wide character encoding to be used in program
source text appearing subsequently. It is a configuration pragma, but
may also be used at any point that a pragma is allowed, and it is
permissible to have more than one such pragma in a file, allowing
multiple encodings to appear within the same file.

The argument can be an identifier or a character literal. In the
identifier case, it is one of `HEX', `UPPER', `SHIFT_JIS', `EUC',
`UTF8', or `BRACKETS'. In the character literal case it is
correspondingly one of the characters `h', `u', `s', `e', `8', or `b'.

Note that when the pragma is used within a file, it affects only the
encoding within that file, and does not affect withed units, specs, or
subunits.
      </DOC>
   </PRAGMA>

   <STANDARD name = "&quot;&amp;&quot;" category = "function"/>

   <STANDARD name = "&quot;&gt;&quot;" category = "function"/>

   <STANDARD name = "&quot;&gt;=&quot;" category = "function"/>

   <STANDARD name = "&quot;&lt;&quot;" category = "function"/>

   <STANDARD name = "&quot;&lt;=&quot;" category = "function"/>

   <STANDARD name = "&quot;*&quot;" category = "function"/>

   <STANDARD name = "&quot;**&quot;" category = "function"/>

   <STANDARD name = "&quot;+&quot;" category = "function"/>

   <STANDARD name = "&quot;-&quot;" category = "function"/>

   <STANDARD name = "&quot;/&quot;" category = "function"/>

   <STANDARD name = "&quot;/=&quot;" category = "function"/>

   <STANDARD name = "&quot;=&quot;" category = "function"/>

   <STANDARD name = "&quot;abs&quot;" category = "function"/>

   <STANDARD name = "&quot;and&quot;" category = "function"/>

   <STANDARD name = "&quot;mod&quot;" category = "function"/>

   <STANDARD name = "&quot;not&quot;" category = "function"/>

   <STANDARD name = "&quot;or&quot;" category = "function"/>

   <STANDARD name = "&quot;rem&quot;" category = "function"/>

   <STANDARD name = "&quot;xor&quot;" category = "function"/>

   <STANDARD name = "ASCII" category = "package">
      <FIELD name = "NUL" doc = "16#00#"/>
      <FIELD name = "SOH" doc = "16#01#"/>
      <FIELD name = "STX" doc = "16#02#"/>
      <FIELD name = "ETX" doc = "16#03#"/>
      <FIELD name = "EOT" doc = "16#04#"/>
      <FIELD name = "ENQ" doc = "16#05#"/>
      <FIELD name = "ACK" doc = "16#06#"/>
      <FIELD name = "BEL" doc = "16#07#"/>
      <FIELD name = "BS" doc = "16#08#"/>
      <FIELD name = "HT" doc = "16#09#"/>
      <FIELD name = "LF" doc = "16#0A#"/>
      <FIELD name = "VT" doc = "16#0B#"/>
      <FIELD name = "FF" doc = "16#0C#"/>
      <FIELD name = "CR" doc = "16#0D#"/>
      <FIELD name = "SO" doc = "16#0E#"/>
      <FIELD name = "SI" doc = "16#0F#"/>
      <FIELD name = "DLE" doc = "16#10#"/>
      <FIELD name = "DC1" doc = "16#11#"/>
      <FIELD name = "DC2" doc = "16#12#"/>
      <FIELD name = "DC3" doc = "16#13#"/>
      <FIELD name = "DC4" doc = "16#14#"/>
      <FIELD name = "NAK" doc = "16#15#"/>
      <FIELD name = "SYN" doc = "16#16#"/>
      <FIELD name = "ETB" doc = "16#17#"/>
      <FIELD name = "CAN" doc = "16#18#"/>
      <FIELD name = "EM" doc = "16#19#"/>
      <FIELD name = "SUB" doc = "16#1A#"/>
      <FIELD name = "ESC" doc = "16#1B#"/>
      <FIELD name = "FS" doc = "16#1C#"/>
      <FIELD name = "GS" doc = "16#1D#"/>
      <FIELD name = "RS" doc = "16#1E#"/>
      <FIELD name = "US" doc = "16#1F#"/>
      <FIELD name = "Exclam" doc = "16#21#"/>
      <FIELD name = "Quotation" doc = "16#22#"/>
      <FIELD name = "Sharp" doc = "16#23#"/>
      <FIELD name = "Dollar" doc = "16#24#"/>
      <FIELD name = "Percent" doc = "16#25#"/>
      <FIELD name = "Ampersand" doc = "16#26#"/>
      <FIELD name = "Colon" doc = "16#3A#"/>
      <FIELD name = "Semicolon" doc = "16#3B#"/>
      <FIELD name = "Query" doc = "16#3F#"/>
      <FIELD name = "At_Sign" doc = "16#40#"/>
      <FIELD name = "L_Bracket" doc = "16#5B#"/>
      <FIELD name = "Back_Slash" doc = "16#5C#"/>
      <FIELD name = "R_Bracket" doc = "16#5D#"/>
      <FIELD name = "Circumflex" doc = "16#5E#"/>
      <FIELD name = "Underline" doc = "16#5F#"/>
      <FIELD name = "Grave" doc = "16#60#"/>
      <FIELD name = "LC_A" doc = "16#61#"/>
      <FIELD name = "LC_B" doc = "16#62#"/>
      <FIELD name = "LC_C" doc = "16#63#"/>
      <FIELD name = "LC_D" doc = "16#64#"/>
      <FIELD name = "LC_E" doc = "16#65#"/>
      <FIELD name = "LC_F" doc = "16#66#"/>
      <FIELD name = "LC_G" doc = "16#67#"/>
      <FIELD name = "LC_H" doc = "16#68#"/>
      <FIELD name = "LC_I" doc = "16#69#"/>
      <FIELD name = "LC_J" doc = "16#6A#"/>
      <FIELD name = "LC_K" doc = "16#6B#"/>
      <FIELD name = "LC_L" doc = "16#6C#"/>
      <FIELD name = "LC_M" doc = "16#6D#"/>
      <FIELD name = "LC_N" doc = "16#6E#"/>
      <FIELD name = "LC_O" doc = "16#6F#"/>
      <FIELD name = "LC_P" doc = "16#70#"/>
      <FIELD name = "LC_Q" doc = "16#71#"/>
      <FIELD name = "LC_R" doc = "16#72#"/>
      <FIELD name = "LC_S" doc = "16#73#"/>
      <FIELD name = "LC_T" doc = "16#74#"/>
      <FIELD name = "LC_U" doc = "16#75#"/>
      <FIELD name = "LC_V" doc = "16#76#"/>
      <FIELD name = "LC_W" doc = "16#77#"/>
      <FIELD name = "LC_X" doc = "16#78#"/>
      <FIELD name = "LC_Y" doc = "16#79#"/>
      <FIELD name = "LC_Z" doc = "16#7A#"/>
      <FIELD name = "L_BRACE" doc = "16#7B#"/>
      <FIELD name = "BA" doc = "16#7C#"/>
      <FIELD name = "R_BRACE" doc = "16#7D#"/>
      <FIELD name = "TILDE" doc = "16#7E#"/>
      <FIELD name = "DEL" doc = "16#7F#"/>
   </STANDARD>

   <STANDARD name = "Boolean" category = "type"/>

   <STANDARD name = "Character" category = "type"/>

   <STANDARD name = "Constraint_Error" category = "variable"/>

   <STANDARD name = "Duration" category = "type"/>

   <STANDARD name = "False" category = "variable"/>

   <STANDARD name = "Float" category = "type"/>

   <STANDARD name = "Integer" category = "type"/>

   <STANDARD name = "Long_Float" category = "type"/>

   <STANDARD name = "Long_Integer" category = "type"/>

   <STANDARD name = "Long_Long_Float" category = "type"/>

   <STANDARD name = "Long_Long_Integer" category = "type"/>

   <STANDARD name = "Natural" category = "type"/>

   <STANDARD name = "Numeric_Error" category = "variable"/>

   <STANDARD name = "Positive" category = "type"/>

   <STANDARD name = "Program_Error" category = "variable"/>

   <STANDARD name = "Short_Float" category = "type"/>

   <STANDARD name = "Short_Integer" category = "type"/>

   <STANDARD name = "Short_Short_Integer" category = "type"/>

   <STANDARD name = "Storage_Error" category = "variable"/>

   <STANDARD name = "String" category = "type"/>

   <STANDARD name = "Tasking_Error" category = "variable"/>

   <STANDARD name = "True" category = "variable"/>

   <STANDARD name = "Wide_Character" category = "type"/>

   <STANDARD name = "Wide_String" category = "type"/>

   <STANDARD name = "Wide_Wide_Character" category = "type"/>

   <STANDARD name = "Wide_Wide_String" category = "type"/>
</PREDEFINED_ADA>
