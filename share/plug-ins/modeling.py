"""
This plug-in adds support for GMC (the GNAT Modeling Compiler) which generates
Ada (SPARK 2014?) and C code from Simulink models.

=========================================
THIS IS WORK IN PROGRESS
As it is this module does not perform anything useful. It defines
the Simulink language, which you can use in your project, but expects
.mdl files to be a JSON definition compatible with
GPS.Browsers.Diagram.load_json. The JSON is loaded into a browser when
you open a .mdl file, for instance from the Project view.
=========================================

"""

import GPS
import GPS.Browsers
import glob
import gps_utils
import modules
import os
import os.path
import os_utils
import re
import json

#############
# Constants #
#############

BLOCK_END = "End Block"
BLOCK_START = "Block"
# The prefixes of a block annotation

BLOCK_ANNOTATION = "(%(start)s|%(end)s) ((\w|_| )+(/(\w|_| )+)*)" % {
    "end": BLOCK_END,
    "start": BLOCK_START
}
# A regex pattern denoting a block annotation. Any changes to parenthesis must
# be reflected in BLOCK_ID and BLOCK_KIND.

BLOCK_ID = 2
BLOCK_KIND = 1
# The parenthesized groups which denote the block id and block kind in the
# BLOCK_ANNOTATION regex pattern.

COMPILE_MODEL_ACTION = "compile model"
# The name of the general action which triggers a GMC compilation

DESKTOP_ENABLED = "enabled"
DESKTOP_SCALE = "scale"
DESKTOP_TOPLEFT = "topleft"
# The names of various attributes used in saving/loading a GMC plug-in module

GMC_NAME = "gmc"
# The name of the GMC executable

GMC_EXEC = os_utils.locate_exec_on_path(GMC_NAME)
# The path to the GMC executable

GMC_HEADER = "Copyright \(C\) Project P"
# ??? "consortium" has different spelling in Ada and C headers ???
# A regex pattern denoting the predefined header which appears in every source
# code file generated by a GMC compilation. Note that special characters must
# be escaped.

JSON_FILE_EXTENSION = ".js"
# A regex pattern denoting the file extension of a JSON file

MDL_FILE_EXTENSION = ".mdl"
# A regex pattern denoting the file extension of a Simulink model file

MDL2JSON_NAME = "mdl2json"
# The name of the MDL2json executable

MDL2JSON_EXEC = os_utils.locate_exec_on_path(MDL2JSON_NAME)
# The path to the MDL2JSON executable

OPTION_CLEAN = "-c"
OPTION_FLATTEN = "--full-flattening"
OPTION_INCREMENTAL = "-i"
OPTION_LANGUAGE = "-l"
OPTION_LIBRARY = "-b"
OPTION_MATLAB = "-m"
OPTION_OUTPUT = "-o"
OPTION_TYPING = "-t"
# The names of various GMC and MDL2JSON options

OUTPUT_DIRECTORY = "Output_Dir"
# The name of the project attribute which denotes the output directory where a
# GMC compilation produces source code files.

SOURCE_MODEL = "Source_Model"
# The name of the project attribute which denotes the Simulink model

TARGET = "GMC for project"
# The name of the build target which describes a GMC compilation

###############
# Definitions #
###############

# Matlab and Simulink languages

LANGUAGE_DEFS = r"""<?xml version='1.0' ?>
  <GPS>
    <Language>
      <Name>Matlab</Name>
      <Body_Suffix>.m</Body_Suffix>
      <Obj_Suffix>-</Obj_Suffix>
    </Language>
    <Language>
      <Name>Simulink</Name>
      <Body_Suffix>.mdl</Body_Suffix>
      <Obj_Suffix>-</Obj_Suffix>
    </Language>
  </GPS>
"""

# The language definitions are parsed immediately to ensure that they are
# available at startup.

GPS.parse_xml(LANGUAGE_DEFS)

# Various project-related attributes

PROJECT_DEFS = """<?xml version='1.0' ?>
  <GPS>
    <project_attribute
     package="GMC"
     name="%(source_model)s"
     editor_page="GMC"
     label="Source model"
     description="The Simulink model to compile and view"
     hide_in="wizard library_wizard">
       <string type="file"/>
    </project_attribute>

    <project_attribute
     package="GMC"
     name="%(output_directory)s"
     editor_page="GMC"
     label="Output directory"
     description="The location of all generated source code files"
     hide_in="wizard library_wizard">
       <string type="directory"/>
    </project_attribute>

    <target-model name="GMC" category="">
      <description>Generic launch of GMC</description>
      <command-line>
        <arg>gmc</arg>
      </command-line>
      <switches/>
      <icon>gps-build-all</icon>
    </target-model>

    <target model="GMC" category="_Project_" name="%(target)s">
      <in-toolbar>FALSE</in-toolbar>
      <in-menu>FALSE</in-menu>
      <launch-mode>MANUALLY_WITH_NO_DIALOG</launch-mode>
      <read-only>TRUE</read-only>
      <command-line>
        <arg>gmc</arg>
      </command-line>
    </target>

    <tool
     name="GMC"
     package="GMC"
     index="Simulink">
      <language>Simulink</language>
      <switches lines="3">
        <title line="1">Files</title>
        <title line="2">Generation</title>
        <title line="3">Output</title>

        <field
         line="1"
         label="Matlab file"
         switch="%(option_matlab)s"
         separator=" "
         as-file="true"
         tip="Provides variable declarations of the Matlab workspace"/>
        <field
         line="1"
         label="Typing file"
         switch="%(option_typing)s"
         separator=" "
         as-file="true"
         tip="Provides Simulink block typing information"/>
        <field
         line="1"
         label="Library directory"
         switch="%(option_library)s"
         separator=" "
         as-directory="true"
         tip="Ask Matteo"/>

        <combo
         line="2"
         label="Target language"
         switch="%(option_language)s"
         separator=" "
         tip="The language used by GMC to produce the generated files">
           <combo-entry label="Ada" value="ada"/>
           <combo-entry label="C" value="c"/>
        </combo>
        <check
         line="2"
         label="Flatten model"
         switch="%(option_flatten)s"
         tip="Ask Matteo"/>

        <radio line="3">
          <radio-entry
           label="Delete"
           switch="%(option_clean)s"
           tip="Delete contents of output directory between compilations"/>
          <radio-entry
           label="Preserve"
           switch="%(option_incremental)s"
           tip="Preserve contents of output directory between compilations"/>
        </radio>
      </switches>
    </tool>
  </GPS>
""" % {
    "option_clean": OPTION_CLEAN,
    "option_flatten": OPTION_FLATTEN,
    "option_incremental": OPTION_INCREMENTAL,
    "option_language": OPTION_LANGUAGE,
    "option_library": OPTION_LIBRARY,
    "option_matlab": OPTION_MATLAB,
    "option_typing": OPTION_TYPING,
    "output_directory": OUTPUT_DIRECTORY,
    "source_model": SOURCE_MODEL,
    "target": TARGET
}

# The project attributes are parsed only when the GMC executable is available

if GMC_EXEC:
    GPS.parse_xml(PROJECT_DEFS)


class GMC_Diagram_Viewer(GPS.Browsers.View):

    # _gmc_module
    #    type: GMC_Module
    # The GMC module in charge of the diagram viewer

    def __init__(self, gmc_module):
        """
        Create a new instance of GMC_Diagram_Viewer.
        :param GMC_Module gmc_module: An instance of GMC_Module.
        """
        self._gmc_module = gmc_module

    def on_item_clicked(self, topitem, item, x, y, *args):
        pass

    def on_item_double_clicked(self, topitem, item, x, y, *args):
        self._gmc_module.handle_diagram_viewer_event(
            topitem, item, x, y, *args)


class GMC_Module(modules.Module):

    def __block_data(self, line):
        """
        Extract the block annotation data from a line.
        :param String line: A line to parse.
        :return: A tuple of the form (String, Boolean). The first element is
            the block id. The second element is a flag which is set to True
            when the annotation starts a block, False when it ends a block. If
            the line does not contain any block annotation data, the routine
            returns None.
        """
        result = re.search(pattern=BLOCK_ANNOTATION, string=line)

        if result:
            return (
                result.group(BLOCK_ID),
                result.group(BLOCK_KIND) == BLOCK_START)

        return None

    def __build_compilation_command(self, executable, file, switches):
        """
        Build a GMC/MDL2JSON compilation command.
        :param String executable: The executable to run.
        :param String file: A Simulink model or a JSON file.
        :param String switches: A sequence of switches.
        :return: The String representation of the command.
        """
        cmd = executable + " " + file + " " + OPTION_OUTPUT + " "\
            + self.__output_directory() + " " + switches

        # Ensure that the command has no leading spaces in the case where the
        # executable is missing.

        return cmd.strip()

    def __compile_model_to_json(self):
        """
        Compile a Simulink model with MDL2JSON to generate a JSON file.
        """
        switches = self.__switches()

        # Remove unwanted switches

        switches = re.sub(pattern=OPTION_FLATTEN, repl="", string=switches)

        # Construct the argument list and call MDL2JSON to compile the Simulink
        # model. Note that the compilation is executed without a build target
        # because the JSON machinery must remain hidden.

        GPS.Process(
            command=self.__build_compilation_command(
                executable=MDL2JSON_EXEC,
                file=self.__model_file(),
                switches=switches),
            on_exit=self.__handle_MDL2JSON_compilation_event
        )

    def __compile_model_to_source_code(self):
        """
        Compile a Simulink model with GMC to generate source code files in a
        particular target language.
        """
        if self.__project_file_ok():
            switches = self.__switches()

            # Handle a missing compilation behavior switch (-c/-i) by adding a
            # default.

            if not re.search(
                pattern=OPTION_CLEAN + "|" + OPTION_INCREMENTAL,
                string=switches
            ):
                switches = switches + " " + OPTION_INCREMENTAL

            # Handle a missing target language switch (-l) by adding a default

            if not re.search(pattern=OPTION_LANGUAGE, string=switches):
                switches = switches + " " + OPTION_LANGUAGE + " ada"

            # Construct the argument list and call GMC to compile the Simulink
            # model.

            targ = GPS.BuildTarget(TARGET)
            targ.execute(
                synchronous=False,
                extra_args=self.__build_compilation_command(
                    executable="",
                    file=self.__model_file(),
                    switches=switches))

    def __diagram_viewer(self):
        """
        Obtain the diagram viewer in charge of visualizing a Simulink model.
        :return: An instance of GMC_Diagram_Viewer.
        """
        window = GPS.MDI.get(os.path.basename(self.__model_file()))

        if hasattr(window, "_diagram_viewer"):
            return window._diagram_viewer

        return None

    def __find_graphical_item(self, block_id):
        """
        Obtain the graphical item which corresponds to a particular block id.
        :param String block_id: The block id to match against.
        :return GPS.Browsers.Item: The graphical item whose id matches bloc_id
            or None.
        """
        def find_graphical_item(item):
            """
            Inspect the children of a graphical item and try to match their ids
            against block_id.
            :param GPS.Browsers.Item item): The (parent) item.
            :return GPS.Browsers.Item: The graphical item whose id matches
                block_id or None.
            """
            # Check whether the current item's matches the block id. Note that
            # the item's id may contain an extra level of detail, therefore
            # perform the membership test against the item's id rather than the
            # other way around. To illustrate:

            #     A/B        block id
            #     A/B/C      item id

            # Note that the item may not even have the "id" attribute set

            if hasattr(item, "id"):
                item_id = item.id

                if item_id and item_id in block_id:
                    return item

            # Inspect any available children. Note that the item may not even
            # have the "children" attribute set or it may be None.

            if hasattr(item, "children"):
                graph_items = item.children

                if graph_items:
                    for graph_item in graph_items:
                        result = find_graphical_item(graph_item)

                        if result:
                            return result

            return None

        # Start of processing for __find_graphical_item

        # Inspect all the top level items of the diagram. Note that each top
        # level item may have children, grand children and so on. The search
        # favors roots over children.

        for graph_item in self.__diagram_viewer().diagram.items:
            result = find_graphical_item(graph_item)

            if result:
                return result

        return None

    def __handle_context_menu_event(self):
        """
        Process a contextual menu event and perform the appropriate navigation
        action.
        """
        pass

    def handle_diagram_viewer_event(self, topitem, item, x, y, *args):
        """
        Process a diagram viewer event and perform the appropriate navigation
        action.
        :param GPS.Browsers.Item item: The item being double clicked
        """
        def add_block_id_locations(file, item_id):
            """
            Examine the contents of a source code file and add a new location
            to the Locations viewer for eash starting block annotation which
            mentions item_id. Note that the file may lack such annotations.
            :param String file: The full path + name of a source code file.
            :param String item_id: The item id to search for.
            """
            phys_file = open(file)
            line_num = 0

            for line in phys_file:
                line_num = line_num + 1

                # Check whether the current line denotes a block annotation. If
                # it does, block_data[0] contains the block id, block_data[1]
                # is True when the annotation starts a block.

                block_data = self.__block_data(line)

                # The current line denotes a starting block annotation

                if block_data and block_data[0] and block_data[1]:
                    if block_data[0] == item_id:
                        print "Exact location: %s:%d:1" % (file, line_num)

                    elif item_id in block_data[0]:
                        print "First location: %s:%d:1" % (file, line_num)
                        break

        # Start of processing for handle_diagram_viewer_event

        # Open all files in the output directory and try to detect source code
        # files by matching their contents against a predefined GMC header.

        all_files = os.path.join(self.__output_directory(), "*")
        for cod_file in glob.glob(all_files):
            if self.__is_source_code_file(cod_file):

                # Note that the item may not even have the "id" attribute set

                if hasattr(item, "id"):
                    add_block_id_locations(file=cod_file, item_id=item.id)

    def __handle_editor_event(self, hookname, file, line, column):
        """
        Process an editor event and perform the appropriate navigation action.
        :param GPS.File file: The file being edited.
        :param Integer line: The line number of the cursor.
        :param Integer column: The column number of the cursor.
        """
        diag_view = self.__diagram_viewer()

        if self.__is_source_code_file(file.name()) and diag_view:
            editor = GPS.EditorBuffer.get(file)
            start = editor.at(line, 1)

            # Obtain the current line referenced by the cursor and determine
            # whether it denotes a block annotation. If it does, block_data[0]
            # contains the block id, block_data[1] is True when the annotation
            # starts a block.

            block_data = self.__block_data(
                editor.get_chars(start, start.end_of_line()))

            # Find the graphical item which corresponds to the selected block
            # id. If such a block exists, clear the current location within the
            # diagram and select the item.

            if block_data and block_data[0]:
                graph_item = self.__find_graphical_item(block_data[0])

                if graph_item:
                    diag = diag_view.diagram

                    diag.clear_selection()
                    diag.select(graph_item)

    def __handle_GMC_compilation_event(
        self,
        hook,
        category,
        target_name="",
        mode_name="",
        status=""
    ):
        """
        Process a compilation event and perform the appropriate action.
        """
        # GMC has finished compiling a Simulink model. Reload the project
        # explorer as the compilation generates new files which must be
        # displayed accordingly. Inspect the output directory and collect
        # all generated source code files in a list for further processing.
        # Create the navigation maps which establish a relation between a
        # source location and a graphical item.

        if target_name == TARGET:
            GPS.execute_action("reload project")

    def __handle_MDL2JSON_compilation_event(self, process, status, output):
        """
        Process a MDL2JSON compilation event and perform the appropriate action
        :param Integer status: The exit status of the call to MDL2JSON.
        :param String output: the output of the call to MDL2JSON.
        """
        if status == 0:
            if not self.__diagram_viewer():

                # Load the JSON file and display the diagram

                model_file = os.path.basename(self.__model_file())

                diags = GPS.Browsers.Diagram.load_json(self.__json_file())
                diag_view = GMC_Diagram_Viewer(self)
                diag_view.create(
                    diagram=diags[0],
                    title=model_file,
                    save_desktop=self.save_desktop
                )

                # Store the instance of the diagram viewer in the window in
                # charge of displaying it.

                window = GPS.MDI.get(model_file)
                window._diagram_viewer = diag_view

                # JSON files must never be exposed to the outside. Destroy the
                # file once the diagram has been displayed.

                os.remove(self.__json_file())

    def __handle_viewer_event(self):
        """
        Process a diagram viewer event and perform the appropriate navigation
        action.
        """
        pass

    def __is_source_code_file(self, file):
        """
        Determine whether a file is the byproduct of a GMC compilation.
        :param String file: The file to test.
        :return: The Boolean status of the test.
        """
        if os.path.isfile(file):
            phys_file = open(file)

            # A file is the byproduct of a GMC compilation when the first line
            # of its textual content denotes a GMC header.

            status = re.search(pattern=GMC_HEADER, string=phys_file.readline())
            phys_file.close()

            return status is not None

        # Otherwise parameter file denotes a directory

        else:
            return False

    def __json_file(self):
        """
        Obtain the JSON file produced by a MDL2JSON compilation.
        :return: The path + file name of the file as String.
        """
        # The JSON file resides in the output directory and shares the same
        # name as that of the related Simulink model, except for the file
        # extension.

        return os.path.abspath(os.path.join(
            self.__output_directory(),
            re.sub(
                pattern=MDL_FILE_EXTENSION + "$",
                repl=JSON_FILE_EXTENSION,
                string=os.path.basename(self.__model_file()))))

    def load_desktop(self, view, data):
        """
        Load the contents of a GMC plug-in module.
        """
        # try:
        #     info = json.loads(data)
        #     if not isinstance(info, dict):
        #         return None
        # except:
        #     return None

        # Recompile the Simulink model to JSON if the diagram viewer was
        # enabled when GPS close.

        # if info[DESKTOP_ENABLED] and self.__project_file_ok(report=False):
        #     self.__compile_model_to_json()

        #     diagram_viewer = self.__diagram_viewer()
        #     diagram_viewer.scale = info[DESKTOP_SCALE]
        #     diagram_viewer.topleft = info[DESKTOP_TOPLEFT]

        #     return GPS.MDI.get_by_child(diagram_viewer)

        # else:
        #     return None

        return None

    def __model_file(self):
        """
        Obtain the Simulink model used in a GMC/MDL2JSON compilation as
        specified in a GMC project.
        :return: The value of project attribute Source_Model as String.
        """
        return GPS.Project.root().get_attribute_as_string(
            package="GMC", attribute=SOURCE_MODEL)

    def __output_directory(self):
        """
        Obtain the output directory of a GMC/MDL2JSON compilation as specified
        in a GMC project.
        :return: The value of project attribute Output_Dir as String.
        """
        return GPS.Project.root().get_attribute_as_string(
            package="GMC", attribute=OUTPUT_DIRECTORY)

    def __present(self, file):
        """
        Determine whether a file is physically present on disk. If this is not
        the case, issue an error.
        :param GPS.File file: The file to be tested.
        :return: The Boolean outcome of the test.
        """
        file_name = file.name()

        if os.path.exists(file_name):
            return True

        # The file does not exist, issue an error

        else:
            GPS.Console("Messages").write(
                "file %s is missing" % file_name, mode="error")
            return False

    def __project_file_ok(self, report=True):
        """
        Determine whether key project attributes are present and if not, issue
        an error.
        :param Boolean report: Set to True to issue an error.
        :return: The Boolean status of the test.
        """
        status = True

        if not self.__model_file():
            if report:
                GPS.Console("Messages").write(
                    "missing project attribute Source_Model in package GMC",
                    mode="error")
            status = False

        if not self.__output_directory():
            if report:
                GPS.Console("Messages").write(
                    "missing project attribute Output_Dir in package GMC",
                    mode="error")
            status = False

        return status

    def save_desktop(self, child):
        """
        Save the contents of a GMC plug-in module.
        """
        # diagram_viewer = child.get_child()
        # info = {
        #     DESKTOP_ENABLED: True,
        #     DESKTOP_SCALE: diagram_viewer.scale,
        #     DESKTOP_TOPLEFT: diagram_viewer.topleft}
        # return json.dumps(info)

        return ""

    def setup(self):
        """
        Setup the GMC plug-in.
        """
        # The module is loaded only when GMC is available

        if GMC_EXEC:
            self.__setup_hooks()
            self.__setup_menus()

    def __setup_hooks(self):
        """
        Enable the GMC plug-in functionaliry by registering various actions
        with corresponding GPS event hooks.
        """
        GPS.Hook("compilation_finished").add(
            self.__handle_GMC_compilation_event, last=False)
        GPS.Hook("location_changed").add(
            self.__handle_editor_event, last=False)
        GPS.Hook("open_file_action_hook").add(
            self.__visualize_model, last=False)

    def __setup_menus(self):
        """
        Enable the GMC plug-in menus and buttons.
        """
        gps_utils.make_interactive(
            callback=self.__compile_model_to_source_code,
            name=COMPILE_MODEL_ACTION)

    def __switches(self):
        """
        Obtain the switches used in a GMC/MDL2JSON compilation as specified in
        a GMC project.
        :return: The switches of a GMC project as String.
        """
        return GPS.Project.root().get_tool_switches_as_string("GMC")

    def teardown(self):
        """
        Clean up a GMC plug-in.
        """
        # ??? useless ???
        pass

    def __visualize_model(
        self,
        hookname,
        model_file,
        line,
        column,
        column_end,
        enable_navigation,
        new_file,
        force_reload,
        focus,
        project
    ):
        """
        Create the visual representation of a Simulink model.
        :param GPS.File model_file: the model file to visualize
        """
        # Compile a Simulink model into JSON only when the MDL2JSON tool is
        # available.

        if (
            MDL2JSON_EXEC
            and self.__present(model_file)
            and model_file.language() == "simulink"
            and self.__project_file_ok()
        ):
            self.__compile_model_to_json()
            return True

        else:
            return False
