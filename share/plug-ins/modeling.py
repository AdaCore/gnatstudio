"""
This plug-in adds support for GMC (the GNAT Modeling Compiler) which generates
Ada (SPARK 2014?) and C code from Simulink models.

=========================================
THIS IS WORK IN PROGRESS
As it is this module does not perform anything useful. It defines
the Simulink language, which you can use in your project, but expects
.mdl files to be a JSON definition compatible with
GPS.Browsers.Diagram.load_json. The JSON is loaded into a browser when
you open a .mdl file, for instance from the Project view.
=========================================

"""

import GPS
import GPS.Browsers
import glob
import gps_utils
import modules
import os
import os.path
import os_utils
import re
import json

#############
# Constants #
#############

BLOCK_ID = "Block (\w_)+(/(\w_)+)*"
# A regex pattern denoting a block id

BLOCK_END = "End " + BLOCK_ID
BLOCK_START = BLOCK_ID
# Regex patterns denoting the start and end of a block annotation

COMPILE_MODEL_ACTION = "compile model"
# The name of the general action which triggers a GMC compilation

DESKTOP_ENABLED = "enabled"
DESKTOP_SCALE = "scale"
DESKTOP_TOPLEFT = "topleft"
# The names of various attributes used in saving/loading a GMC plug-in module

DIAGRAM_VIEWER = "_diagram_viewer"
# The name of an extra member added to a MDIWindow to store the diagram viewer

GMC_NAME = "gmc"
# The name of the GMC executable

GMC_EXEC = os_utils.locate_exec_on_path(GMC_NAME)
# The path to the GMC executable

GMC_HEADER = "Copyright \(C\) Project P consortium"
# A regex pattern denoting the predefined header which appears in every source
# code file generated by a GMC compilation. Note that special characters must
# be escaped.

JSON_FILE_EXTENSION = ".js"
# A regex pattern denoting the file extension of a JSON file

MDL_FILE_EXTENSION = ".mdl"
# A regex pattern denoting the file extension of a Simulink model file

MDL2JSON_NAME = "mdl2json"
# The name of the MDL2json executable

MDL2JSON_EXEC = os_utils.locate_exec_on_path(MDL2JSON_NAME)
# The path to the MDL2JSON executable

OPTION_CLEAN = "-c"
OPTION_FLATTEN = "--full-flattening"
OPTION_INCREMENTAL = "-i"
OPTION_LANGUAGE = "-l"
OPTION_LIBRARY = "-b"
OPTION_MATLAB = "-m"
OPTION_OUTPUT = "-o"
OPTION_TYPING = "-t"
# The names of various GMC and MDL2JSON options

OUTPUT_DIRECTORY = "Output_Dir"
# The name of the project attribute which denotes the output directory where a
# GMC compilation produces source code files.

SOURCE_MODEL = "Source_Model"
# The name of the project attribute which denotes the Simulink model

TARGET = "GMC for project"
# The name of the build target which describes a GMC compilation

###############
# Definitions #
###############

# Matlab and Simulink languages

LANGUAGE_DEFS = r"""<?xml version='1.0' ?>
  <GPS>
    <Language>
      <Name>Matlab</Name>
      <Body_Suffix>.m</Body_Suffix>
      <Obj_Suffix>-</Obj_Suffix>
    </Language>
    <Language>
      <Name>Simulink</Name>
      <Body_Suffix>.mdl</Body_Suffix>
      <Obj_Suffix>-</Obj_Suffix>
    </Language>
  </GPS>
"""

# The language definitions are parsed immediately to ensure that they are
# available at startup.

GPS.parse_xml(LANGUAGE_DEFS)

# Various project-related attributes

PROJECT_DEFS = """<?xml version='1.0' ?>
  <GPS>
    <project_attribute
     package="GMC"
     name="%(source_model)s"
     editor_page="GMC"
     label="Source model"
     description="The Simulink model to compile and view"
     hide_in="wizard library_wizard">
       <string type="file"/>
    </project_attribute>

    <project_attribute
     package="GMC"
     name="%(output_directory)s"
     editor_page="GMC"
     label="Output directory"
     description="The location of all generated source code files"
     hide_in="wizard library_wizard">
       <string type="directory"/>
    </project_attribute>

    <target-model name="GMC" category="">
      <description>Generic launch of GMC</description>
      <command-line>
        <arg>gmc</arg>
      </command-line>
      <switches/>
      <icon>gps-build-all</icon>
    </target-model>

    <target model="GMC" category="_Project_" name="%(target)s">
      <in-toolbar>FALSE</in-toolbar>
      <in-menu>FALSE</in-menu>
      <launch-mode>MANUALLY_WITH_NO_DIALOG</launch-mode>
      <read-only>TRUE</read-only>
      <command-line>
        <arg>gmc</arg>
      </command-line>
    </target>

    <tool
     name="GMC"
     package="GMC"
     index="Simulink">
      <language>Simulink</language>
      <switches lines="3">
        <title line="1">Files</title>
        <title line="2">Generation</title>
        <title line="3">Output</title>

        <field
         line="1"
         label="Matlab file"
         switch="%(option_matlab)s"
         separator=" "
         as-file="true"
         tip="Provides variable declarations of the Matlab workspace"/>
        <field
         line="1"
         label="Typing file"
         switch="%(option_typing)s"
         separator=" "
         as-file="true"
         tip="Provides Simulink block typing information"/>
        <field
         line="1"
         label="Library directory"
         switch="%(option_library)s"
         separator=" "
         as-directory="true"
         tip="Ask Matteo"/>

        <combo
         line="2"
         label="Target language"
         switch="%(option_language)s"
         separator=" "
         tip="The language used by GMC to produce the generated files">
           <combo-entry label="Ada" value="ada"/>
           <combo-entry label="C" value="c"/>
        </combo>
        <check
         line="2"
         label="Flatten model"
         switch="%(option_flatten)s"
         tip="Ask Matteo"/>

        <radio line="3">
          <radio-entry
           label="Delete"
           switch="%(option_clean)s"
           tip="Delete contents of output directory between compilations"/>
          <radio-entry
           label="Preserve"
           switch="%(option_incremental)s"
           tip="Preserve contents of output directory between compilations"/>
        </radio>
      </switches>
    </tool>
  </GPS>
""" % {
    "option_clean": OPTION_CLEAN,
    "option_flatten": OPTION_FLATTEN,
    "option_incremental": OPTION_INCREMENTAL,
    "option_language": OPTION_LANGUAGE,
    "option_library": OPTION_LIBRARY,
    "option_matlab": OPTION_MATLAB,
    "option_typing": OPTION_TYPING,
    "output_directory": OUTPUT_DIRECTORY,
    "source_model": SOURCE_MODEL,
    "target": TARGET
}

# The project attributes are parsed only when the GMC executable is available

if GMC_EXEC:
    GPS.parse_xml(PROJECT_DEFS)


class GMC_Diagram_Viewer(GPS.Browsers.View):

    def __init__(self):
        """
        Create a new instance of GMC_Diagram_Viewer, a class capable of
        displaying a JSON diagram.
        """
        print "GMC_Diagram_Viewer.__init__"

    def on_item_double_clicked(self, topitem, item, x, y, *args):
        print "GMC_Diagram_Viewer.on_item_double_clicked"

        GPS.Console().write(
            "double_clicked on %s (%s), at %s,%s\n" % (topitem, item, x, y))


class GMC_Module(modules.Module):

    # cod_files
    #    type   : list
    #    element: GPS.File - a source code file
    # List of all source code files in a particular target language pertaning
    # to a Simulink model.

    # fl_to_obj_map
    #    type : dictionary
    #    key  : GPS.File - a generated file
    #    value: dictionary
    #       key  : integer - line number
    #       value: list
    #          element: GPS.Browsers.View.Item - a graphical object
    # File-by-file, line-by-line map which links source code to corresponding
    # graphical objects.

    # lang_info
    #    type : dictionary
    #    key  : String - the target language
    #    value: Language
    # Table of target language-specific information

    # obj_to_fl_map
    #    type : dictionary
    #    key  : GPS.Browsers.View.Item - a graphical object
    #    value: dictionary
    #       key  : GPS.File  - generated file
    #       value: list
    #          element: integer - line number
    # Graphical object to file-by-file, line-by-line map

    def __build_compilation_command(self, executable, file, switches):
        """
        Build a GMC/MDL2JSON compilation command.
        :param String executable: the executable to run
        :param String file: a Simulink model or JSON file
        :param String switches: a sequence of switches
        :return: the String representation of the command
        """
        print "GMC.__build_compilation_command"

        cmd = executable + " " + file + " " + OPTION_OUTPUT + " "\
            + self.__output_directory() + " " + switches

        # Ensure that the command has no leading spaces in the case where the
        # executable is missing.

        return cmd.strip()

    def __build_language_info(self):
        """
        Create a repository of target language-specific information.
        """
        print "GMC.__build_language_info"

        self.lang_info = {
            "ada": Language("ada", "--  %s"),
            "c": Language("c", "/* %s */")}

    def __build_navigation_maps(self):
        """
        Establish the mapping between graphical objects and locations in source
        code files.
        """
        print "GMC.__build_navigation_maps"

        def add_fl_to_obj_entry(self, cod_file, line_num, graph_obj):
            """
            Add a single entry in map fl_to_obj.
            :param GPS.File cod_file: a source code file
            :param integer line_num: the current line in the source code file
            :param GPS.Browsers.View.Item graph_obj: a graphical object
            """
            # Ensure that all parts of map fl_to_obj are initialized

            if not fl_to_obj_map:
                fl_to_obj_map = {}

            if cod_file not in fl_to_obj_map:
                fl_to_obj_map[cod_file] = {}

            if line_num not in fl_to_obj_map[cod_file]:
                fl_to_obj_map[cod_file][line_num] = ()

            # Create a new entry

            fl_to_obj_mal[cod_file][line_num].append(graph_obj)

        def add_obj_to_fl_entry(self, cod_file, line_num, graph_obj):
            """
            Add a single entry in map obj_to_fl.
            :param GPS.File cod_file: a source code file
            :param integer line_num: the current line in the source code file
            :param GPS.Browsers.View.Item graph_obj: a graphical object
            """
            # Ensure that all parts of map obj_to_fl are initialized

            if not obj_to_fl_map:
                obj_to_fl_map = {}

            if graph_obj not in obj_to_fl_map:
                obj_to_fl_map[graph_obj] = {}

            if cod_file not in obj_to_fl_map[graph_obj]:
                obj_to_fl_map[graph_obj][cod_file] = ()

            # Create a new entry

            obj_to_fl_map[graph_obj][cod_file].append(line_num)

        def build_id_to_obj_map():
            """
            Establish a mapping between block ids and graphical objects.
            :return: a mapping (dictionary) between String block ids to
                GPS.Browsers.View.Item.
            """
            pass

        def build_navigation_map(cod_file, id_to_obj_map):
            """
            Establish the mapping between graphical objects and locations in a
            single source code file.
            :param GPS.File cod_file: a source code file
            :param dictionary id_to_obj_map: a mapping from String block id to
                GPS.Browsers.View.Item.
            """
            # Local declarations

            graph_objs = []
            # List of graphical objects currently visible from the stand point
            # of a source code line. The list is maintained in a stack-like
            # fasion.

            # Remove all previous entries from the two maps concerning the
            # source code file as they will be replaced with new ones.

            fl_to_obj_map[cod_file] = None
            for item in obj_to_fl_map:
                if cod_file in obj_to_fl_map[item]:
                    obj_to_fl_map[item][cod_file] = None

            # Open the source code file and parse its contents. For each block
            # annotation, create a mapping of the form:
            #
            #    file, line => graphical object
            #    graphical object => file, line
            #
            # For a single non-empty source code line, create a mapping of the
            # form:
            #
            #    file, line => graphical object 1, graphical object N

            lang = lang_info[cod_file.language()]
            line_num = 0

            phys_file = open(cod_file.name())
            for line in phys_file:
                line_num = line_num + 1

                is_start_annot = lang.__is_block_start_annot(line)
                is_end_annot = lang.__is_block_end_annot(line)

                # The current line denotes a block annotation

                if is_start_annot or is_end_annot:
                    graph_obj = id_to_obj_map[lang.__block_id(line)]

                    # Add entries in both maps

                    add_fl_to_obj_entry(cod_file, line_num, graph_obj)
                    add_obj_to_fl_entry(cod_file, line_num, graph_obj)

                    # A source code line may be associated with several blocks
                    # in which case it must be mapped to all the relevant
                    # graphical objects.
                    #
                    #    <Block 1>
                    #    <Block 2>
                    #    source code line - associated with Block 1 and 2
                    #    <End Block 2>
                    #    source code line - associated with Block 1
                    #    <End Block 1>
                    #
                    # To accomodate this, graphical objects are maintained in a
                    # local stack-line list.

                    if is_start_annot:
                        if not graph_obj in graph_objs:
                            graph_objs.append(graph_obj)

                    else:
                        if graph_obj in graph_objs:
                            graph_objs.remove(graph_obj)

                # Otherwise the current line denotes a statement, a comment or
                # a blank line. Either way, the line is mapped to all of the
                # graphical objects which correspond to open blocks.

                else:
                    for graph_obj in graph_objs:
                        add_fl_to_obj_entry(cod_file, line_num, graph_obj)

            phys_file.close()

        # Start of processing for __build_navigation_maps

        # The navigation maps are recomputed each time GMC compiles a Simulink
        # model into source code and GPS displays the visual equivalent of the
        # Simulink model.

        if self.cod_files and self.__diagram_viewer():
            id_to_obj_map = build_id_to_obj_map()

            for cod_file in cod_files:
                if self.__present(cod_file):
                    build_navigation_map(cod_file, id_to_obj_map)

    def __build_source_code_file_list(self):
        """
        Inspect the output directory of a GMC project and collect all source
        code files for further processing.
        """
        print "GMC.__build_source_code_file_list"

        # Clear the contents of the source code file list because it is about
        # to be repopulated.

        self.cod_files = []

        # Open all files in the output directory and try to detect source code
        # files by matching their contents against a predefined GMC header.

        all_files = os.path.join(self.__output_directory(), "*")

        for cod_file in glob.glob(all_files):
            phys_file = open(cod_file)

            # The current file contains a GMC header making it a source code
            # file. It is sufficent to compare the first line in the file as
            # the header should always precede any other contents.

            if re.search(pattern=GMC_HEADER, string=phys_file.readline()):
                self.cod_files.append(GPS.File(cod_file))

            phys_file.close()

    def __compile_model_to_json(self):
        """
        Compile a Simulink model with MDL2JSON to generate a JSON file.
        """
        print "GMC.__compile_model_to_json"

        switches = self.__switches()

        # Remove unwanted switches

        switches = re.sub(pattern=OPTION_FLATTEN, repl="", string=switches)

        # Construct the argument list and call MDL2JSON to compile the Simulink
        # model. Note that the compilation is executed without a build target
        # because the JSON machinery must remain hidden.

        GPS.Process(
            command=self.__build_compilation_command(
                executable=MDL2JSON_EXEC,
                file=self.__model_file(),
                switches=switches),
            on_exit=self.__handle_MDL2JSON_compilation_event
        )

    def __compile_model_to_source_code(self):
        """
        Compile a Simulink model with GMC to generate source code files in a
        particular target language.
        """
        print "GMC.__compile_model_to_source_code"

        if self.__project_file_ok():
            switches = self.__switches()

            # Handle a missing compilation behavior switch (-c/-i) by adding a
            # default.

            if not re.search(
                pattern=OPTION_CLEAN + "|" + OPTION_INCREMENTAL,
                string=switches
            ):
                switches = switches + " " + OPTION_INCREMENTAL

            # Handle a missing target language switch (-l) by adding a default

            if not re.search(pattern=OPTION_LANGUAGE, string=switches):
                switches = switches + " " + OPTION_LANGUAGE + " ada"

            # Construct the argument list and call GMC to compile the Simulink
            # model.

            targ = GPS.BuildTarget(TARGET)
            targ.execute(
                synchronous=False,
                extra_args=self.__build_compilation_command(
                    executable="",
                    file=self.__model_file(),
                    switches=switches))

    def __diagram_viewer(self):
        """
        Obtain the diagram viewer in charge of visualizing a Simulink model.
        :return: an instance of GMC_Diagram_Viewer
        """
        print "GMC.__diagram_viewer"

        return hasattr(GPS.MDI.get(self.__model_file()), DIAGRAM_VIEWER)

    def __handle_context_menu_event(self):
        """
        Process a contextual menu event and perform the appropriate navigation
        action.
        """
        pass

    def __handle_editor_event(self):
        """
        Process an editor event and perform the appropriate navigation action.
        """
        pass

    def __handle_GMC_compilation_event(
        self,
        hook,
        category,
        target_name="",
        mode_name="",
        status=""
    ):
        """
        Process a compilation event and perform the appropriate action.
        """
        print "GMC.__handle_GMC_compilation_event"

        # GMC has finished compiling a Simulink model. Reload the project
        # explorer as the compilation generates new files which must be
        # displayed accordingly. Inspect the output directory and collect
        # all generated source code files in a list for further processing.
        # Create the navigation maps which establish a relation between a
        # source location and a graphical item.

        if target_name == TARGET:
            GPS.execute_action("reload project")
            self.__build_source_code_file_list()
            self.__build_navigation_maps()

    def __handle_MDL2JSON_compilation_event(self, process, status, output):
        """
        Process a MDL2JSON compilation event and perform the appropriate action
        :param status: the exit status of the call to MDL2JSON
        :param output: the output of the call to MDL2JSON
        """
        print "GMC.__handle_MDL2JSON_compilation_event"

        if status == 0:
            if not self.__diagram_viewer():

                # Load the JSON file and display the diagram

                diags = GPS.Browsers.Diagram.load_json(self.__json_file())
                diag_view = GMC_Diagram_Viewer()
                diag_view.create(
                    diagram=diags[0],
                    title=os.path.basename(self.__model_file()),
                    save_desktop=self.save_desktop
                )

                # JSON files must never be exposed to the outside. Destroy the
                # file once the diagram has been displayed.

                os.remove(self.__json_file())

                # Create the navigation maps which establish a relation between
                # a source location and a graphical item.

                self.__build_navigation_maps()

    def __handle_viewer_event(self):
        """
        Process a diagram viewer event and perform the appropriate navigation
        action.
        """
        pass

    def __json_file(self):
        """
        Obtain the JSON file produced by a MDL2JSON compilation.
        """
        print "GMC.__json_file"

        # The JSON file resides in the output directory and shares the same
        # name as that of the related Simulink model, except for the file
        # extension.

        return os.path.abspath(os.path.join(
            self.__output_directory(),
            re.sub(
                pattern=MDL_FILE_EXTENSION + "$",
                repl=JSON_FILE_EXTENSION,
                string=os.path.basename(self.__model_file()))))

    def load_desktop(self, view, data):
        """
        Load the contents of a GMC plug-in modile.
        """
        print "GMC.load_desktop"

        # try:
        #     info = json.loads(data)
        #     if not isinstance(info, dict):
        #         return None
        # except:
        #     return None

        # Recompile the Simulink model to JSON if the diagram viewer was
        # enabled when GPS close.

        # if info[DESKTOP_ENABLED] and self.__project_file_ok(report=False):
        #     self.__compile_model_to_json()

        #     diagram_viewer = self.__diagram_viewer()
        #     diagram_viewer.scale = info[DESKTOP_SCALE]
        #     diagram_viewer.topleft = info[DESKTOP_TOPLEFT]

        #     return GPS.MDI.get_by_child(diagram_viewer)

        # else:
        #     return None

        return None

    def __model_file(self):
        """
        Obtain the Simulink model used in a GMC/MDL2JSON compilation as
        specified in a GMC project.
        """
        print "GMC.__model_file"

        return GPS.Project.root().get_attribute_as_string(
            package="GMC", attribute=SOURCE_MODEL)

    def __output_directory(self):
        """
        Obtain the output directory of a GMC/MDL2JSON compilation as specified
        in a GMC project.
        """
        print "GMC.__output_directory"

        return GPS.Project.root().get_attribute_as_string(
            package="GMC", attribute=OUTPUT_DIRECTORY)

    def __present(self, file):
        """
        Determine whether a file is physically present on disk. If this is not
        the case, issue an error.
        :param GPS.File file: the file to be tested
        :return: Boolean
        """
        file_name = file.name()

        if os.path.exists(file_name):
            return True

        # The file does not exist, issue an error

        else:
            GPS.Console("Messages").write(
                "file %s is missing" % file_name, mode="error")
            return False

    def __print_cod_files(self):
        """
        Output the contents of list cod_files.
        """
        if self.cod_files:
            print "Cod_Files"

            for file in self.cod_files:
                if file:
                    print "  File: " + file.name()

    def __print_fl_to_obj_map(self):
        """
        Output the contents of map fl_to_obj.
        """
        if self.fl_to_obj_map:
            print "FL_To_Obj_Map"

            for file in self.fl_to_obj_map:
                if file:
                    print "  File: " + file.name()

                    for line in self.fl_to_obj_map[file]:
                        print "    Line: " + line

                        for obj in self.fl_to_obj_map[file][line]:
                            print "      Object: " + obj

    def __print_lang_info(self):
        """
        Output the contents of table lang_info
        """
        if self.lang_info:
            print "Lang_Info"

            for lang in self.lang_info:
                if lang:
                    print "  Language: " + lang

    def __print_obj_to_fl_map(self):
        """
        Output the contents of map obj_to_fl
        """
        if self.obj_to_fl_map:
            print "Obj_To_FL_Map"

            for obj in self.obj_to_fl_map:
                if obj:
                    print "  Object: " + obj

                    for file in self.obj_to_fl_map[obj]:
                        if file:
                            print "    File: " + file

                            for line in self.obj_to_fl_map[obj][file]:
                                if line:
                                    print "      Line: " + line

    def __project_file_ok(self, report=True):
        """
        Determine whether key project attributes are present and if not, issue
        an error.
        :param Boolean report: set to True to issue an error.
        :return Boolean:
        """
        status = True

        if not self.__model_file():
            if report:
                GPS.Console("Messages").write(
                    "missing project attribute Source_Model in package GMC",
                    mode="error")
            status = False

        if not self.__output_directory():
            if report:
                GPS.Console("Messages").write(
                    "missing project attribute Output_Dir in package GMC",
                    mode="error")
            status = False

        return status

    def save_desktop(self, child):
        """
        Save the contents of a GMC plug-in modile.
        """
        print "GMC.save_desktop"

        # diagram_viewer = child.get_child()
        # info = {
        #     DESKTOP_ENABLED: True,
        #     DESKTOP_SCALE: diagram_viewer.scale,
        #     DESKTOP_TOPLEFT: diagram_viewer.topleft}
        # return json.dumps(info)

        return ""

    def setup(self):
        """
        Setup the GMC plug-in.
        """
        # The module is loaded only when GMC is available

        if GMC_EXEC:
            self.cod_files = []

            self.__build_language_info()
            self.__setup_hooks()
            self.__setup_menus()

    def __setup_hooks(self):
        """
        Enable the GMC plug-in functionaliry by registering various actions
        with corresponding GPS event hooks.
        """
        print "GMC.__setup_hooks"

        GPS.Hook("compilation_finished").add(
            self.__handle_GMC_compilation_event, last=False)
        GPS.Hook("open_file_action_hook").add(
            self.__visualize_model, last=False)

    def __setup_menus(self):
        """
        Enable the GMC plug-in menus and buttons.
        """
        print "GMC.__setup_menus"

        gps_utils.make_interactive(
            callback=self.__compile_model_to_source_code,
            name=COMPILE_MODEL_ACTION)

    def __switches(self):
        """
        Obtain the switches used in a GMC/MDL2JSON compilation as specified in
        a GMC project.
        """
        print "GMC.__switches"

        return GPS.Project.root().get_tool_switches_as_string("GMC")

    def __visualize_model(
        self,
        hookname,
        model_file,
        line,
        column,
        column_end,
        enable_navigation,
        new_file,
        force_reload,
        focus,
        project
    ):
        """
        Create the visual representation of a Simulink model.
        :param GPS.File model_file: the model file to visualize
        """
        print "GMC.__visualize_model"

        # Compile a Simulink model into JSON only when the MDL2JSON tool is
        # available.

        if (MDL2JSON_EXEC
            and self.__present(model_file)
            and model_file.language() == "simulink"
                and self.__project_file_ok()):
            self.__compile_model_to_json()
            return True

        else:
            return False


class Language:

    # block_end
    #    type: String
    # A regexp denoting the end of a block annotation

    # block_start
    #    type: String
    # A regexp denoting the start of a block annotation

    # header
    #    type: String
    # A header annotation which appears at the beginning of each generated file

    # name
    #    type: String
    # The name of the language

    def __init__(self, name, comment):
        """
        Construct a new language characterized by various attributes.
        :param String name: the name of the language
        :param String comment: the format of a comment
        """
        self.name = name
        self.header = comment % GMC_HEADER
        self.block_start = comment % BLOCK_START
        self.block_end = comment % BLOCK_END

    def __block_id(self, line):
        """
        Extract the id of a block from a line that denotes a block annotation.
        :param String line: a line denoting a block annotation
        :return:the id of the block as a String
        """
        return re.search(pattern=BLOCK_ID, string=line)

    def __is_block_end_annot(self, line):
        """
        Determine whether a line denotes the end of a block annotation.
        :param String line: the line to test
        :return: Boolean
        """
        return re.match(pattern=self.block_end, string=line) is not None

    def __is_block_start_annot(self, line):
        """
        Determine whether a line denotes the beginning of a block annotation.
        :param String line: the line to test
        :return: Boolean
        """
        return re.match(pattern=self.block_start, string=line) is not None
