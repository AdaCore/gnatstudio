import GPS
import os.path
import re
from . import core
from workflows import run_as_workflow
from workflows.promises import ProcessWrapper

MAP_FILE_BASE_NAME = "map.txt"

xml = """
<filter name="ld_supports_map_file" shell_lang="python"
        shell_cmd="memory_usage_providers.ld.LD.map_file_is_supported(
GPS.current_context())" />
"""


@core.register_memory_usage_provider("LD")
class LD(core.MemoryUsageProvider):

    _cache = {}

    @staticmethod
    def map_file_is_supported(context):
        """
        The filter used to know if the ld linker supports the '-map' switch.
        """

        target = GPS.get_target()
        build_mode = GPS.get_build_mode()

        v = LD._cache.get((target, build_mode), None)
        if v is not None:
            return v

        if not target or target == 'native' or build_mode != 'default':
            return False

        ld_exe = target + '-ld'

        try:
            process = GPS.Process([ld_exe, '--help'])
            output = process.get_result()
            v = '-map' in output
        except:
            v = False

        LD._cache[(target, build_mode)] = v

        return v

    def is_enabled(self):
        # ??? Return LD.map_file_is_supported once the new GUI
        return False

    @run_as_workflow
    def async_fetch_memory_usage_data(self, visitor):
        # Retrieve the memory map file generated by ld
        project = GPS.Project.root()
        obj_dirs = project.object_dirs(recursive=False)
        map__dir = project.file().directory() if not obj_dirs else obj_dirs[0]
        map_file_name = os.path.join(map_dir, MAP_FILE_BASE_NAME)

        # The information we want to fetch: memory regions and memory sections
        # ??? Find a way to have a finer grain view (symbols? compilation
        # units?)
        regions = []
        sections = []

        # The regexps used to match the information we want to fetch
        region_r = re.compile('^(?P<name>\w+)\s+(?P<origin>0x[0-9a-f]+)' +
                              ' (?P<length>0x[0-9a-f]+) x?r?w?')
        section_r = re.compile('^(?P<name>[\w.]+)\s+(?P<origin>0x[0-9a-f]+)' +
                               '\s+(?P<length>0x[0-9a-f]+)')

        def try_match_region(line):
            """
            Try to match a region description in the given line.

            Return a tuple (name, origin, length) if a region was matched
            and None otherwise.
            """

            m = region_r.search(line)
            if m:
                return (m.group('name'), int(m.group('origin'), 16),
                        int(m.group('length'), 16))
            else:
                return None

        def try_match_section(line):
            """
            Try to match an allocated section description in the given live.

            An allocated section is a memory section that will actually be
            loaded by the target. Sections related with debug information,
            code comments or that have null size are typically not allocated
            and should be ignored.

            Return a tuple (name, origin, length) if a section was matched
            and None otherwise.
            """

            not_alloc_sections_prefixes = ['.debug', '.comment']
            m = section_r.search(line)

            if m:
                section = (m.group('name'), int(m.group('origin'), 16),
                           int(m.group('length'), 16))

                for prefix in not_alloc_sections_prefixes:
                    if section[0].startswith(prefix):
                        return None

                if section[2] == 0:
                    return None

                return section
            else:
                return None

        # Parse the memory map file to retrieve the memory regions and
        # the path of the linked executable.

        with open(map_file_name, 'r') as f:
            for line in f:
                region = try_match_region(line)
                if not region:
                    section = try_match_section(line)
                    if section:
                        sections.append(section)
                else:
                    regions.append(region)

        visitor.on_memory_usage_data_fetched(regions, sections)

GPS.parse_xml(xml)
