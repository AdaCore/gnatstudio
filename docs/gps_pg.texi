\input texinfo   @c -*-texinfo-*-
@input texiplus

@c %**start of header
@setfilename gps_pg.info
@settitle GPS Programmer's Guide
@syncodeindex fn cp

@set GPS
@set GPSVersion 3.1.3

@titlepage

@title{GPS Programmer's Guide}
@subtitle Version @value{GPSVersion}
@subtitle Document revision level $Revision$
@subtitle Date: $Date$
@author AdaCore

@c Insist we have a draft
@iftex
@headings off
@everyheading @emph{Draft!} @| @thispage @| @thischapter
@everyfooting @| @| Version: 0.27: @today{}
@end iftex


@page
@vskip 0pt plus 1filll

Copyright @copyright{} 2002-2006, AdaCore.
This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are clearly
marked as alterations and (2) this copyright notice is included
unmodified in any copy.

@end titlepage

@ifnottex
@node Top, Introduction, (dir), (dir)
@top GPS Programmer's Guide

Version @value{GPSVersion}

Date: $Date$

Copyright @copyright{} 2002-2006, AdaCore.
This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are clearly
marked as alterations and (2) this copyright notice is included
unmodified in any copy.

@menu
* Introduction::
* System Setup::
* The GPS modules::
* Hello World Walk Through::
* The GPS Kernel::
* Intermodule communication::
* Documenting your module::
* Debugging::
* Contexts::

@detailmenu

 --- The Detailed Node Listing ---

@end detailmenu
@end menu
@end ifnottex

@iftex
@contents
@end iftex

@c --------------------------------------------------------------------
@node Introduction
@chapter Introduction
@c --------------------------------------------------------------------

@b{Important note}: This document is not ready for release yet.


@noindent
This document explains how to add your own modules to the GPS programming
system.

GPS is a fully open architecture, to which one can add new features ranging
from new menu items to launch external tools to full support for new languages,
including cross-references.

@cindex adding menus
@cindex menus
@cindex toolbar
@cindex key bindings

Some of these additions can be done solely through the use of text
files. These are for instance adding new key bindings to various parts
of GPS, for instance in the editor. The end-user can also easily add new menus
or toolbar buttons. See the customization chapters in the GPS user's guide.

This document will focus on these additions that can only be done
through programming languages.

At this point, GPS can only be extended by programming in
@b{Ada}. In addition, it is planned for the near future that extensions
in @b{C} or @b{C++} can be done. Work is under way to extend python scripting
in GPS.

Likewise, adding basic support for new languages will be made easier,
and doable through external text files, requiring no
programming. This is not available for this first release of the GPS
environment.

@c --------------------------------------------------------------------
@node System Setup
@chapter System Setup
@c --------------------------------------------------------------------

@noindent
As explained in the introduction, GPS can currently only be extended
by programming in Ada. This assumes that a number of tools are
available on your system, so that you can recompile your new module.

Most of these external tools and libraries are available from
@url{http://libre.act-europe.fr}.

@table @b
@item GNAT 3.15 or above
GNAT is the GNU Ada Compiler, integrated into the gcc tool chain, and
developed by @b{Ada Core Technologies} and @b{ACT Europe}. GPS will not compile
with other Ada compilers than GNAT.

@item Gtk+ 2.2.0 or above
gtk+ is a C toolkit used for the graphical interface of GPS. It is
available on a number of platforms, including most UNIX systems and
Windows. Available from @url{http://www.gtk.org}.

@item GPS sources
The GPS sources include the corresponding GNAT, GtkAda and GVD sources
needed to build it. If needed, GNAT, GtkAda and GVD sources can be
obtained seperately from anonymous cvs access from
@url{http://libre.act-europe.fr}

@end table

The GPS sources contain an INSTALL file that explains how to recompile
GPS itself. GPS knows how to dynamically load a module. As a result,
you do not necessarily need to rebuild GPS itself to add new modules,
although the dynamic loading hasn't been fully tested yet and might
not work on all platforms.

@c --------------------------------------------------------------------
@node The GPS modules
@chapter The GPS modules
@c --------------------------------------------------------------------

@noindent
GPS is organized around the concept of modules. The only part of GPS that
is mandatory is its kernel (@pxref{The GPS Kernel}), all the other tools,
menus and features are provided in optional modules.

Although currently all modules have to be loaded at startup, some proof of
concept for dynamically loadable module was implemented, and will most likely
be part of a future version of GPS.

Every new feature you implement will be part of one or more modules. We will
go through the details of creating new modules all along this manual, starting
from a simple Hello World module to more advanced features like providing
new shell or python commands.

Generally speaking, a module provides a limited set of features, and adds
new GUI features in the GPS interface, like menus, toolbar buttons, contextual
menu entries, new windows,@dots{} As much as possible, a menu shouldn't directly
depend on any other module, only on the GPS kernel itself.

See the file @file{gps-kernel-modules.ads} for more information on modules.


@c --------------------------------------------------------------------
@node Hello World Walk Through
@chapter Hello World walk through
@c --------------------------------------------------------------------

@noindent
Creating a new module is best demonstrated by going through the
classical and simple example ``hello world''. This example will be
refined as new extension possibilities are described later on in this
document.

@section Declaring the module

@noindent
A module is generally implemented in a separate source file, at this point
an Ada package. The first thing that needs to be done is to create the specs
of this package. Most of the time, a single function has to be exported,
which is called Register_Module by convention. Therefore, we have to create
a new directory to contain the module (we'll call it @file{hello_world}), at
the same level as other modules like the source editor.

Still by convention, the sources are put in a directory called @file{src}, and
the object files are kept in a separate directory called @file{obj}.

@smallexample
mkdir hello_world
mkdir hello_world/src
mkdir hello_world/obj
@end smallexample

In the source directory, we create the file @file{hello_world.ads}, which
contains the declaration of the @code{Register_Module} subprogram.

@smallexample
@b{with} GPS.Kernel;
@b{package} Hello_World @b{is}
   @b{procedure} Register_Module
      (Kernel : @b{access} GPS.Kernel.Kernel_Handle_Record'Class);
@b{end} Hello_World;
@end smallexample

Before going over the details of the implementation of @code{Register_Module},
we have to make sure that the rest of GPS knows about this module, and that
we know how to compile it

@section Publicizing your module

@noindent
Until GPS provides dynamic modules, you have to modify the main subprogram of
GPS to make it aware of your module.

This is done by modifying the file @file{gps.adb}, and adding two statements
in there: a @code{with} statement that imports @file{hello_world}.ads, and
a call to @code{Hello_World.Register_Module}. See for instance how this is
done for the keymanager module.

@section Compiling your module

@noindent
However, after the addition of the two statements in @file{gps.adb}, the file
@file{hello_world.ads} will not be found automatically by GPS. Therefore,
you need to create a project file for your new module (we'll call it
@file{hello_world.gpr}), and add a dependency to it in the root project file
of GPS (@file{gps/gps.gpr}), as is currently done for all other modules.

The project file @file{hello_world.gpr} is best created by copying the
project file from any other module, for instance the aliases module
(@file{aliases/aliases.gpr}), and changing the name of the project to
@code{Hello_World}.

You must also create a set of two Makfiles, which are used to add files other
than Ada, even if your module only uses Ada files.
Once again, this is best done by copying the two Makefiles from the
directory @file{aliases}, renaming them into @file{Makefile} and
@file{Makefile.hello_world}, and replacing the strings @code{aliases} and
@code{ALIASES} by resp. @code{hello_world} and @code{HELLO_WORLD}.

These steps will be made easier in the near future, but in any case are
relatively straightforward, and only need to be done once per module. The
resulting setup automatically takes into account all sources files that will
be added later on to the module, either C or Ada, and compile them with the
appropriate compiler.

You might also prefer in your first attempt at creating a new module to add
your new files into the @file{src} directory of an existing module. In this
case, you don't have to create any of the project files or Makefile, nor to
modify the @file{gps.adb} file.

Once the project file has been created, and a dependency added in
@file{gps.gpr}, you might want to reload the GPS project in GPS, so that the
editing of your sources can be done in an Ada-friendly context.

@section Registering the module

@noindent
Back to the source files of your modules. We now need to create a body for
the procedure @code{Register_Module}. The minimal thing this function has to
do is indicate to the GPS kernel that a new module is being declared, and
give it a name. If you only do that, there is no direct impact on the rest
of GPS. However, as we will see during in this guide, having a specific
@code{Module_Id} is mandatory for some of the advanced feature, so it is
cleaner to always declare one from the start.

This is done by creating the file @file{hello_world.adb}, with the following
contents.

@smallexample
@b{with} GPS.Kernel.Modules;  @b{use} GPS.Kernel, GPS.Kernel.Modules;

@b{package} Hello_World @b{is}
   @b{procedure} Register_Module
      (Kernel : @b{access} GPS.Kernel.Kernel_Handle_Record'Class)
   @b{is}
      Module : Module_ID;
   @b{begin}
      GPS.Kernel.Modules.Register_Module
         (Module, Kernel, Module_Name => "hello_world");
   @b{end} Register_Module;

@b{end} Hello_World;
@end smallexample

At this point, the hello_world module is compilable, only it won't do anything
but be loaded in GPS.

The following sections will show how new features can be provided to the
rest of GPS.


@c Adding new contextual menu: display "hello <file>" when a file is
@c   selected.
@c Adding new window in the MDI
@c Adding messages to the console

@c --------------------------------------------------------------------
@node The GPS Kernel
@chapter The GPS Kernel
@c --------------------------------------------------------------------

@noindent

@c gps-kernel.ads
@c gps-kernel-module.ads
@c up-to-date documentation found in the sources themselves
@c Saving data from one session to the next:
@c   - adding new preferences
@c   - interface to histories
@c   - custom files (XML,...)
@c interface with projects: projects.ads
@c i18n and utf8

@c --------------------------------------------------------------------
@node Intermodule communication
@chapter Intermodule communication
@c --------------------------------------------------------------------

@noindent
As described above, GPS is organized into largely independent
modules. For instance, the various explorers, browsers, help, vcs
support,... are separate modules, that can either be loaded at startup
or not.

When they are not loaded, the correspondings features and menus are not
available to the user.

These modules need to communicate with each other so as to provide the
best possible integration between the tools. There currently exists a
number of ways to send information from one module to
another. However, some of these technics depend on Ada-specific types,
and thus makes it harder to write modules in different languages like
C or Python.

The following communication technics are currently provided:

@itemize
@item Direct calls
A module can explicitly specify that it depends on another one. This
is done by changing the project file, and adding the necessary "with"
statements in the code.  This technics is highly not recommended, and
should never be used when one of the other technics would do the job,
since it defeats the module independency.  The only place it is
currently used at is for direct calls to the Register_* commands.
Most of the time, these Register_* subprograms are also available through
XML customization files, and thus limit the direct dependencies between
modules, while providing greated extensibility to the final user.

@item Shell calls
Each module can register new shell commands for the interactive shell
window.  Any other module can call these commands. There is no direct
dependency on the code, although this means that the module that
provide the command must be loaded before the other module.  This
technics is used for instance for the codefix module, that needs a
high degree of integration with the source editor module. It will also
be used for communicating with Emacs.

@item Addition to contextual menus
A module is free to add entries to the main menu bar or to any
contextual menus within GPS.

Most of the time, a module will decide to add new entries depending on
what the contextual menu applies to (the current context), although it
might also decide to do that based on what module is displaying the
contextual menu. Modules are identified by their name, which can
easily be tested by other menus.

@item Context changes
Every time a new MDI child is selected, or when a module chooses to
emit such a signal, a context change is reported via a gtk+ signal. A
context is an Ada tagged type, created by the currently active
module. There exists different kinds of contexts, some for files
(directories and project), others for entities (same as before, but
with an entity name in addition, other for a location (adding line and
column),...  New types of contexts can be created by the modules
without impacting the rest of GPS. All callbacks must test that the
context they receive matches what they can handle.

These contexts are also used for the contextual menus

A module can choose to emit the signal to report changes to its
context by emitting the signal. Other modules can they update their
content accordingly. This is how the switches editor updates the
project/directory/file it is showing when a new selection is done in
the explorer.

@item hooks and action hooks
Hooks are similar to the usual gtk+ signals.
Each hook is a named collection of subprograms to be called when the hook is
executed. Such hooks are executed by various parts of GPS when some actions
take place, like reloading the project, loading a file,@dots{}

These are the most powerful way for a module to react to actions taking place
in other parts of GPS, and to act appropriately.

In most cases, all the subprograms in a hook are executed in turn, and thus
they all get a chance to act.

However, in some other cases, the subprograms are only executed until one of
them indicates that it has accomplished a useful action, and that no other
subprogram from this hook should be called. These are called @b{action hooks}.
This is the fundamental mechanism used by GPS to request for instance the
edition of a file: the module that wishes to display a file executes the
hook "open_file_action_hook" with the appropriate argument. At this point, all
subprograms bound to this hook are executed, until one of them acknowledge that
it knows how to edit this file (and hopefully opens an editor). Then no other
subprogram from this hook is called, so that the file is not open multiple
times.

This mechanism is used for instance by the module that handles the external
editors. It is setup so that it binds to the "open_file_action_hook" hook. Any
time a file needs to be open, the callback from this module is called first.
If the user has indicated that the external editor should always be used, this
external editors module opens the appropriate editor, and stops the execution
of the hook. However, if the user didn't wish to use an external editor, this
module does nothing, so that the callback from the source editor module is
called in turn, and can thus open the file itself.

See @file{gps-kernel-hooks.ads} for more information on hooks.

@end itemize


@c --------------------------------------------------------------------
@node Documenting your module
@chapter Documenting your module
@c --------------------------------------------------------------------

@noindent
All modules should be documented, so that the users are aware of all
its capabilities.

There are several levels of documentation:

@itemize @bullet

@item Tooltips
It is recommended that all new preferences and as much of the GUI as
possible be documented through tooltips. This is the only help that
most users will read.

Tooltips are easily added directly with gtk+: Just call
@code{Gtk.Tooltips.Set_Tooltip} with the appropriate parameters. The
kernel itself contains a tooltip group, which should be used when
setting new tooltips. This is so that a common timeout is used for all
tooltips in the application: when a user has waited long enough for
the first tooltip to be displayed, he won't have to wait again for the
other tooltips.

@item extended documentation
Extended documentation should be written in HTML.
See the GPS user's guide on how to make new documentation available to
users.

@end itemize

@c --------------------------------------------------------------------
@node Debugging
@chapter Debugging
@c --------------------------------------------------------------------

@section X11 server

If you are developing on a linux system, it is recommended that you
reconfigure your X11 server with the following setup (see the file
@file{/etc/X11/XF86Config-4}):

@smallexample
Section "ServerFlags"
        Option "AllowDeactivateGrabs" "true"   # Ctrl+Alt+Keypad *
        Option "AllowClosedownGrabs"  "true"   # Ctrl+Alt+Keypad /
EndSection
@end smallexample

The two key bindings described above are used to release any grab that
a GUI application might have. This is especially useful when debugging
through @code{gdb}: it might happen that the breakpoint happens while
such a grab is in place, and would therefore prevent any input (mouse
or keyboard) to any application in your X11 session, in particular the
debugger.


@section gtk+ library

It is also recommended that you recompile your own gtk+ library (on
systems where this is easily doable such as Unix systems), with the
following configure command:

@smallexample
   ./configure --with-debug=yes
@end smallexample

In addition to providing the usual debugging information in the
debugger, this also activates several environment variables which
might be used to monitor the actions in gtk+ and its associated
libraries.

These variables are the following:

@smallexample
export GTK_DEBUG=misc:plugsocket:text:tree:updates:keybindings;
export GDK_DEBUG=updates:nograbs:events:dnd:misc:xim:colormap:gdkrb:gc:pixmap:image:input:cursor;
export GOBJECT_DEBUG=objects:signals;
@end smallexample

Some of the values for these variables can be omitted. The exact
semantic (or even the exact list) of such variables depends on your
version of gtk+, and you should therefore consult its documentation.


@section debugger

When debugging with @code{gdb}, it is recommended that you always
specify the flag @code{--sync} to gps. This forces any gtk+
application, and in particular GPS, to process X11 events
synchronously, and therefore makes it easier to debug possible
problems.

If your application is printing some gtk+ warnings on the console, you
should do the following in the debugger:

@smallexample
  (gdb) set args --sync
  (gdb) begin
  (gdb) break g_log
  (gdb) cont
@end smallexample

This will stop the application as soon as the gtk+ warning is printed.

@c --------------------------------------------------------------------
@node Contexts
@chapter Contexts
@c --------------------------------------------------------------------

@noindent

@c describe what contexts are: file context, entity context,
@c defining new contexts


@c --------------------------------------------------------------------
@unnumbered Index
@printindex cp


@bye
