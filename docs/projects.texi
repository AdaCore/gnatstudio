@c --------------------------------------------------------------------
@node Project Handling
@chapter Project Handling
@c --------------------------------------------------------------------

@noindent
The section on the project explorer (@ref{The Project Explorer}) has
already given a brief overview of what the projects are, and the
information they contain.

This chapter provides more in-depth information, and describes
how such projects can be created and maintained.

@menu
* Description of the projects::
* Scenarios and configuration variables::
* The project wizard::
* The project properties editor::
@end menu

@c -------------------------------------------------------------------
@node Description of the projects
@section Description of the projects
@c -------------------------------------------------------------------

@subsection Project files and GNAT tools

@noindent
This section describes what the projects are, and what information
they contain.

The most important thing to note is that the projects used by GPS are
the same as the ones used by GNAT itself. These are text files
(using the extension @file{.gpr}) which can be edited either manually, with
any text editor, or through the more advanced GPS interface.

The exact syntax of the project files is fully described in the GNAT
User's Guide (@url{gnat_ug.html}) and GNAT Reference Manual
(@url{gnat_rm.html}). This is a recommended reading in any case if you
want to use the more advanced capabilities of the project files, which
are not necessarily all supported by the graphical interface yet.

GPS cannot edit graphically all the aspects of the project files
(variables for instance are not editable as such, since the GUI makes
their use less necessary). However, it can load any project file, even
those that you have edited manually. On the other hand, you can manually edit
the project files created by GPS.

You will usually not have to edit the project files manually, since several
graphical tools are provided such as the project wizard
(@ref{The project wizard}) and the properties editor(@ref{The
project properties editor}).

All the non graphical GNAT tools are project aware, meaning that the notion
of project goes well beyond GPS' user interface, and most capabilities of
the project file can be accessed without using GPS itself, making the
project files very attractive.

If you are using programming languages other than Ada, the project
files can automatically generate Makefiles through the @file{gpr2make}
tool provided with GNAT. Roundtrip editing is not available though,
and any change you make to the generated Makefiles will be lost the
next time the tool is run.


@subsection Contents of project files

@noindent
The project files contain all the information that describe the
organization of your source files, object files and executables.

Generally, one project file will not be enough to describe complex
organization. In this case, you will create and use a project hierarchy,
with a root project importing other subprojects. Each of the projects
and subprojects is responsible for its own set of sources (recompile
them with the appropriate switches, put the resulting files in the
right directories, ...).

Each project contains the following information, among other things
(see the GNAT user's guide for a full list)

@itemize @bullet
@item @b{List of imported projects}:
   When you are compiling some sources from this project, the compiler
   (either through GNAT or the automatically generated Makefiles) will
   first make sure that all the imported projects have been correctly
   recompiled and are up-to-date. This way, dependencies between
   source files are properly handled.

   If one of the source files of project A depends on some source
   files from project B, then B must be imported by A. If this isn't
   the case, the compiler will complain that some of the source files
   cannot be found.

   One important rule is that each source file name must be unique in
   the project hierarchy (ie a file can not be under control of two
   different projects. This ensures that the same file will be found
   no matter what project is managing the source file that uses

@item @b{List of source directories}:
   All the sources managed by a project are found in one or more
   source directories. Each project can have multiple source
   directories, and a given source directory might be shared by
   multiple projects.

@item @b{Object directory}:
   When the sources of the project are compiled, the resulting object
   files are put into this object directory. There exist exactly one object
   directory for each project. If you need to split the object files
   among multiple object directories, you need to create multiple
   projects importing one another as appropriate.

   When sources from imported subprojects are recompiled, the
   resulting object files are put in the subproject's own object
   directory, and will never pollute the parent's object directory.

@item @b{Exec directory}:
   When a set of object files is linked into an executable, this executable
   is put in the exec directory of the project file. If this attribute
   is unspecified, the object directory is used.

@item @b{List of source files}:
   The project is responsible for managing a set of source
   files. These files can be written in any programming
   languages. Currently, the graphical interface supports Ada, C and C++.

   The default to find this set of source files is to take all the
   files in the source directories that follow the naming scheme (see
   below) for each language. In addition if you edit the
   project file manually, it is possible to provide an explicit list of source
   files.

   This attribute cannot be modified graphically yet.

@item @b{List of main units}:
   The main units of a project (or main files in some languages) are
   the units that contain the main subprogram of the application, and
   that can be used to link the rest of the application.

   The name of the file is generally related to the name of the
   executable.

   A given project file hierarchy can be used to compile and link
   several executables. GPS will automatically update the Compile, Run
   and Debug menu with the list of executables, based on this list.
   
@item @b{Naming schemes}:
   The naming scheme refer to the way files are named for each
   languages of the project. This is used by GPS to choose the language
   support to use when a source file is opened. This is also used to
   know what tools should be used to compile or otherwise work with a
   source file.

@item @b{Embedded targets and Cross-environments}:
   GPS fully supports cross-environment work: GPS itself can run on a
   machine but start all the compilation, run and debugger on a remote
   host.

   It also support embedded targets (VxWorks,...) by specifying alternate
   names for the build and debug tools.

   The project file contains the information required to log on the
   remote host.
   
@item @b{Tools}:
   The project files provide a simply way to change the compiler that
   should be used to compile the source files, as well as the
   underlying debugger to use.

@item @b{Switches}:
   Each tool that is used by GPS (compiler, pretty-printer,
   debugger,...) has its own set of switches. Moreover, these switches
   may depend on what specific file is manipulated, and on its language.

@end itemize


@c -------------------------------------------------------------------
@node Scenarios and configuration variables
@section Scenarios and configuration variables
@c -------------------------------------------------------------------

@noindent
The behavior of projects can be further taylored by the use of
scenarios.

All the attributes of a project, except its list of imported projects,
can be chosen based on the value of external variables, whose value is
generally coming from the environment, or directly set in GPS (using
the small area on top of the project explorer (@ref{The Project
Explorer}).

This can for instance be used to compile all the sources either in
debug mode (so that the executables can be run in the debugger), or in
optimized mode (to reduce the space and increase the speed when delivering).
In this case, all the attributes (source directories, tools,...) remain the
same, except the switches. It would
be more difficult to maintain a completely separate hierarchy of
project, and it is much more efficient to create a new configuration
variable and edit the switches for the appropriate scenario (@ref{The
project properties editor}).


@subsection Creating new configuration variables

Creating a new scenario variable is done through the contextual menu
(right-click) in the project explorer. Select the menu @code{Add
Configuration Variable}. This opens the following dialog:

@iftex
@image{scenarios}
@end iftex

@ifhtml
@image{scenarios}
@end ifhtml

There are two main areas in this dialog: in the top line, you specify
the name of the variable. This name is used for two purposes:

@itemize @bullet
@item It is displayed in the project explorer

@item This is the name of the environment variable from which the
initial value is read. When GPS is started, all configuration
variables are initialized from the environment, although you can of
course change them as many times as you want later on.

@end itemize

If you click on the arrow on the right of this name area, GPS will
display the list of all the environment variables that are currently
defined. However, you don't need to pick the name of an existing
variable, neither must the variable exist when GPS is started.

The second part of this dialog is the list of authorized value for
this variable. Any other value will generate an error reported by
GPS, and the project won't be loaded as a result.

One of these values is the default value (the one whose button in the
Default column is selected). This means that if the environment
variable doesn't exist when GPS is started, GPS will behave as if it
did exist with this default value.

The list of possible values can be edited through the @code{Remove},
@code{Add} and @code{Rename} buttons, although you can also simply
click on the value itself to change it.


@subsection Editing existing configuration variables

If at least one configuration variable is defined in your project, the
area on top of the project explorer will contain something similar to:

@iftex
@image{explorer-scenario}
@end iftex

@ifhtml
@image{explorer-scenario}
@end ifhtml

This screenshot shows two configuration variables, named @code{Build}
and @code{OS}, with their current value (resp. @code{Debug} and
@code{Unix}).

You can easily change the current value of any of these variables by
clicking on the arrow on the right of the value. This will display a
popup window with the list of possible values, from which you select
the one you wish to use.

As soon as a new value is selected, GPS will recompute the project
explorer (in case the source directories, object directories or list
of source files has changed). A number of things will also be updated
(like the list of executables in the @code{Compile}, @code{Run} and
@code{Debug} menus).

Currently, GPS will not recompute the contents of the various browsers
(callgraph, dependencies,...) for this new project. This would be too
expensive to do every time the value changes, and therefore you need
to explicitely request an update.

@c ??? Need to explain how to force an update, once this is
@c implemented

You can change the list of possible values for a configuration
variable at any time by clicking on the button to the far left of the
variable's name. This will popup the same dialog that is used to create
new variables

Removing a variable is done by clicking on the button immediately to
the left of the variable's name. GPS will then display a confirmation
dialog.

If you confirm that you want to delete the variable, GPS will simply
remove the variable, and from now on act as if the variable always had
the value it had when it was deleted.


@c -------------------------------------------------------------------
@node The project wizard
@section The project wizard
@c -------------------------------------------------------------------


@c -------------------------------------------------------------------
@node The project properties editor
@section The project properties editor
@c -------------------------------------------------------------------


