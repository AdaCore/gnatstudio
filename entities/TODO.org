# for Emacs: -*- mode: org; mode: flyspell; fill-column: 79 -*-

* Optimization of the initial insert

** Timing
   Current timing:
       kernel/src_info/test/parse_all:  66.59s user, 1.44s system, 1:48:34 elapsed
       test_entities: 39.97 user, 1.62 system, 3:16:18 elapsed  21% CPU
   Not sure why we have a big difference in elapsed time when the total time for
   the rest is much smaller. Should likely try to get a system that really does
   nothing. This is with disk caches

** Database in memory
   We could try to create a database in memory, and dump it into a file in the
   end.
   Timing to fill the :memory: sqlite database: 40.09u 0.88s 0:59.33elapsed
      (for the parsing of ALI files: 50.75s)
   Then we can dump it into a file with:

   http://www.sqlite.org/backup.html 

   This also allows creating the database on the side, and then make it
   available to GPS, without blocking all GPS SQL queries in the meantime.

** Using SQL commands similar to Django's bulk_create.
   Django 1.4 introduces a new bulk_create command, which emits a different
   SQL command (but then does not provide a way to retrieve the new primary
   keys when they are from a sequence).
   Similar timings can be reproduced from the command line when using "sqlite3"
   directly. But in neither cases (django or sqlite3) do we use prepared queries,
   whereas GNATColl gives full access to them. So it is expected that using the
   equivalent of bulk_create would not provide a speed up (might even be slower
   since we can't use a prepared query in this case).

*** sqlite:
   no bulk:   0.289407968521
   with_bulk: 0.118507862091    (max:  999 / number_of_fields)
   INSERT INTO "entitiesdb_entities" ("name", "xmi") VALUES (name0, xmi0)
   INSERT INTO "entitiesdb_entities" ("name", "xmi") VALUES (name1, xmi1)
   INSERT INTO "entitiesdb_entities" ("id", "name", "xmi") SELECT None AS "id", name0 AS "name", xmi0 AS "xmi" UNION SELECT None, name1, xmi1 UNION SELECT None, name2, xmi2 UNION SELECT None, name3, xmi3 UNION SELECT None, name4, xmi4 UNION SELECT None, name5, xmi5 UNION SELECT None, name6, xmi6 UNION SELECT None, name7, xmi7 UNION SELECT None, name8, xmi8 UNION SELECT None, name9, xmi9

*** postgreSQL:
   no bulk:   0.161162853241
   with bulk: 0.025486946106
   INSERT INTO "entitiesdb_entities" ("name", "xmi") VALUES ('name0', 'xmi0') RETURNING "entitiesdb_entities"."id"
   INSERT INTO "entitiesdb_entities" ("name", "xmi") VALUES ('name1', 'xmi1') RETURNING "entitiesdb_entities"."id"
   INSERT INTO "entitiesdb_entities" ("name", "xmi") VALUES ('name0', 'xmi0'), ('name1', 'xmi1'), ('name2', 'xmi2'), ('name3', 'xmi3'), ('name4', 'xmi4'), ('name5', 'xmi5'), ('name6', 'xmi6'), ('name7', 'xmi7'), ('name8', 'xmi8'), ('name9', 'xmi9')

** Improving the format of the ALI files
   There are currently two aspects in the ALI files that require extra handling:

*** A rename does not necessarily point to an entity visible in the same ALI file,
   so this requires an extra link pass. This could be changed in a backward
   compatible manner. Also the renamed entity (after the '=') is pointed to one
   of its references instead of its declaration. So this can only be looked for
   in a separate pass. That change however might not be backward compatible.

*** Generic instantiations do not contain the column of the generic they are
   instantiating. In some cases, this means two SELECT instead of one to find
   the entity. The speed up is minor though.
   To test: set Instances_Provide_Column to True. On one run of the test,
   it went from 149.5 down to 145s)

** Loading entity references as a file
   Rather than doing the 917_402 entity references through one SQL command each,
   it might be faster to load them in the end as a single file (using either
   .import in sqlite or COPY...FROM in postgreSQL).

*** sqlite
   After creating the full database, the following commands where executed:

        .mode csv
        .separator "\t"
        .output entity_refs.sql
        delete from entity_refs;

   Then the database is reloaded with:

        .separator "\t"
        DROP INDEX entity_refs_file_line_col;
        .import entity_refs.sql entity_refs
        CREATE INDEX entity_refs_file_line_col on entity_refs(file,line,"column");
        .exit

        time sqlite3 -bail -batch entities.db < load.sql

   Total time for the load was:  18.55s user 3.48s system 40% cpu 53.905 total
   Keeping the index active during load: 18.63s user 0.32s system 19% cpu 1:35.69
   Drop index, but don't recreate:  11.89s user 0.19s system 20% cpu 59.724 total
      (this is the timing we would see if we were doing this in test_entity)

   By comparison, if we disable the insertions in the table entity_refs when
   loading the initial database, the time went from 149.5s down to 71.86s.
   Seems we could be saving about 20s here.

   But looking at the C implementation of .import, they simply execute a
   prepared SQL statement "INSERT INTO '...' VALUES(...'" within a transaction,
   which is already what test_entity is doing. They do it at the C level, so
   without the overhead of GNATCOLL, but that's the only difference.

   Comparing the low-level C commands: GNATCOLL does

        sqlite3_clear_bindings   (not done by .import)
        sqlite3_reset
        sqlite3_reset    (duplicate -- now fixed in GNATCOLL)
        sqlite3_bind_int * 4 + sqlite3_bind_text * 2
        sqlite3_step
        sqlite3_last_insert_rowid   (we don't need it -- fixed in GNATCOLL)

*** postgreSQL
   we could use COPY...FROM, this hasn't been tested yet (and not really needed
   for now).


