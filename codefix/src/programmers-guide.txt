------------------------------------
How to add a new parser in Codefix ?
------------------------------------

An error message treatment in Codefix is divided into two parts: the structure
of the message and its semantic meaning. Those two parts are separated into two
different packages: Codefix.Errors_Parsers and Codefix.Formal_Errors. Ideally,
no information concerning the message caption should appear in Formal_Errors,
in order to minimize problems following changes in GNAT error system.


Adding an error parser is quite easy. An error parser is a tagged type derived
from 'Error_Parser'. The two values of the discriminant should be defined at
the derivation. 'Subcategory' is used to know which category of error the
parser fixes. It is used to know if the user wants or not to fix this error. If
you want to create a new category, just add it at the end of the type
'Errors_Subcategories'. The genius programmers of GPS should have managed a way
to update automatically the structure of the preferences. The second parameter
of 'Error_Parser'is 'Nb_Parser'. It is used to know how many regular expressions
you want to check in your parser. In fact, you can have some messages that
can't be described in one expression, but close enough to make a bit redundant
the creation of a new 'Error_Parser'. That's why you can create more than one
regular expression for a parser.


After having chosen the two discriminants, you must at least implement the two
abstract functions. The first one is 'Initialize':

procedure Initialize (This : in out Error_Parser)

In this procedure, you have to initialize the field 'Matcher', an array
constrained between 1 and Nb_Parsers (the second discriminant value), in which
you have to create all the pattern matchers. Each pattern matcher is in fact an
access to Pattern_Matcher (automatically freed in the Free function of
'Error_Parser'). Basically, the creation of a new regular expression is
' := new Pattern_Matcher'(Compile (...))'.


The second procedure, the most important one is the procedure Fix:

procedure Fix
  (This         : Error_Parser;
   Errors_List  : in out Errors_Interface'Class; 
   Current_Text : Text_Navigator_Abstr'Class;
   Message      : Error_Message;
   Solutions    : out Solution_List;
   Matches      : Match_Array)

This procedure is called when a regular expression of 'This' matches. Usually,
a regular expression matching stops the search of other matches. If you want to
continue the search, you have to raise 'Uncorrectable_Message'. Then, Codefix
will consider that the message does not match and the search will continue.

A possible fix is an object called 'Extract'. It is a copy of the original text
with some modifications (lines deleted, added or modified). More than one
possibility can be associated with an error, each one have to be appended to
the object Solution_List, which is a 'Generic_List' of 'Extract'. Later, the
user will chose which one he wants. The main functionality of this procedure
Fix is to add extracts to Solution_List.

The object Message is the message that matches a parser. The cols that it
contains is a little modified (a tabulation is equal to a character, not a
position mod 8).

The object Matches is the Match_Array resulting from the execution of the
pattern matcher. It is constrained between 0 .. n, where n is the number of
couple of parenthesis in the regular expression.

The object Error_List is the main Error_Interface, the object with whom you can
extract new errors captions. It is necessary to use this object when a message
is on more than one line. The problem is that if you use the function
'Get_Message' and discover that the message is not matching with ones you need,
this message will never be parsed by other parsers. So, you have to call first
the function 'Preview', check if you really want to treat this message and then
call 'Get_Message' to suppress the message from the list. This function
assumes that you won't need to get nonadjacent message for the same treatment.
If you need such of thing, add a complain at the beginning of the document.

In the body of Fix, you have to call one or more functions from Formal_Errors
to generate at least one extract and add it in 'Solutions'.


After having created your own 'Error_Parser', you have to add it in the parsers
list. Nothing easier, just call the function Add_Parser with an instantiation
of your parser. Just a thing to care about: the order of the instantiations is
the order of the call. You may want to analyze a possibility before the other
ones (to make structures like 'this one is possible only if the previous
isn't). That's the only case where the order matters.
 

After having created a new parser, you probably have to create a new function
in formal error. There is no real rule, just look at examples and
'Text_Manager' packages to know which possibilities you have. The only thing
important is to avoid using the error message, but variables that have been
initialized from it in the Errors_Parser, because the error message can change
and 'Formal_Errors' should not be disturbed by these changes.
