------------------------------------
How to add a new parser in Codefix ?
------------------------------------

An error message treatment in Codefix is divide into two parts : the structure of the message and his semantic meaning. Those two parts are separate into two different packages : Codefix.Errors_Parsers and Codefix.Formal_Errors. Ideally, no information concerning the message caption should appears in Formal_Errors, in order to minimize problems following changes in GNAT error system.


Add an error parser is quite easy. An error parser is a tagged type derived from 'Error_Parser'. The two values of the discriminant should be defined at the derivation. 'Subcategory' is use to know which category of error the parser fixes. It is used to know if the user wants or not to fix this error. If you want to create a new category, just add it a the end of the type 'Errors_Subcategories'. The genius programmers of GPS should have managed a way to update automatically the structure of the preferences. The second parameter of 'Error_Parser'is 'Nb_Parser'. It is used to know how many regular expression you want to check for your parser. In fact, you can have some messages that can't be describe in one expression, but close enough to make a bit redundant the creation of a new 'Error_Parser'. That's why you can create more than one regular expression for a parser.


After having chosen the two discriminants, you must at least implement the two abstract function. The first one is 'Initialize' :

procedure Initialize (This : in out Error_Parser)

In this procedure, you have to initialize the field 'Matcher', an array constrained between 1 and Nb_Parsers (the second discriminant value), in which you have to create all the pattern matchers. Each pattern matcher is in fact an access to Pattern_Matcher (automatically free in the Free function of 'Error_Parser'). Basically, the creation of a new regular expression is ' := new Pattern_Matcher'(Compile (...))'.


The second procedure, the most important one is the procedure Fix :

procedure Fix
  (This         : Error_Parser;
   Errors_List  : in out Errors_Interface'Class; 
   Current_Text : Text_Navigator_Abstr'Class;
   Message      : Error_Message;
   Solutions    : out Solution_List;
   Matches      : Match_Array)

This procedure is called when a regular expression of 'This' matches. Usually, a regular expression matching break the research for others ones. If you want to continue the research, if you have to raise 'Uncorrectable_Message'. Then, Codefix will considerate that the message does not match  and the research will continue.

A possible fix is an object called 'Extract'. It is a copy of the original text with some modifications (lines deleted, added or modified). More than one possibility can be associated to an error, each ones have to be append to the object Solution_List, which is an 'Generic_List' of 'Extract'. Later, the user will chose which one he wants. The main functionality of this procedure Fix is to add extracts to Solution_List.

The object Message is the message that matches a parser. The cols that it contains is a little modified (a tabulation is equal to a character, not a position mod 8).

The object Matches is the Match_Array resulting from the execution of the pattern matcher. It is constrained between 0 .. n, where n is the number of couple of parenthesis in the regular expression.

The object Error_List is the main Error_Interface, the object with whom you can extract new errors captions. It is necessary to use this object when a message is on more than one lines. The problem is that if you use the function 'Get_Message' and discover that the message is not matching with ones you need, this message will never be parsed by others parsers. So, you have to call first the function 'Preview', check if you really wants to treat this message and then call 'Get_Message' to suppress the message from the list. This function supposes that you won't need to get nonadjacent message for the same treatment. If you need such of thing, add a complain at the beginning of the document.

In the body of Fix, you have to call one or more functions from Formal_Errors to generate at least one extract and add it in 'Solutions'.


After having created your own 'Error_Parser', you have to add it in the parsers list. Nothing easier, just call the function Add_Parser with an instantiation of your parser. Just a thing to care about : the order of the instantiations is the order of the call. You can want to analyze a possibility before the other ones (to make structures like 'this one is possible only if the precedent isn't). That's the only case where the order is important.
 

After having created a new parser, you certainly have to create a new function in formal error. There is no real rule, just look at examples and 'Text_Manager' packages to know which possibilities you have. The only thing important is to avoid using the error message, but variables that have been initialized from it in the Errors_Parser, because the error message can change and 'Formal_Errors' should not be disturbed by these changes.
