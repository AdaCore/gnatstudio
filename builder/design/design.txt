The purpose of this component is to build automatically a multi-language
application.

Requirements:
- Be easily extensible to new programming languages
- Handle the dependencies automatically
- Handle different compilers for different languages
- Handle source dependencies automatically
- Provide language-specific compilation/link options
- Provide file-specific compilation options
- Provide conditional sections based on configurable variables
- ??? Handle building and use of libraries

Process:

- The builder will take a GNAT multi-language project file as its input,
  and generate a Makefile for each project file.

- A project file is considered multi-language if the "Language" attribute
  is different from ("ada"), e.g ("c"), ("ada", "c"), ("c", "c++")

- The Ada dependencies and compilations are handled by gnatmake

- Part of the build process is handled by a generic Makefile, as described
  below

- The dynamic part is handled by a Makefile generated from the GNAT project
  file. The automatic translation is described below in the section entitled
  "Section generated by translating the project file"

############################################
# Section handled by the generic Makefile
############################################

- The list of non Ada objects is computed automatically based on language
  extensions:

ifeq ($(strip $(filter c,$(LANGUAGES))),c)
   ifndef C_SRCS
      C_SRCS := \
        $(foreach name,$(SRC_DIRS),$(notdir $(wildcard $(name)/*$(C_EXT))))
   endif

   OBJECTS += $(C_SRCS:$(C_EXT)=$(OBJ_EXT))
endif

ifeq ($(strip $(filter c++,$(LANGUAGES))),c++)
   ifndef CXX_SRCS
      CXX_SRCS := \
        $(foreach name,$(SRC_DIRS),$(notdir $(wildcard $(name)/*$(CXX_EXT))))
   endif

   OBJECTS += $(CXX_SRCS:$(CXX_EXT)=$(OBJ_EXT))
endif

OBJ_FILES := $(foreach name,$(OBJECTS),$(OBJ_DIR)/$(name))

- The initial idea to handle C/C++ dependencies was to use makedepend
  by adding a special rule in the Makefile:

    SRCS = file1.c file2.c ...
    CFLAGS = -O -DHACK -I../foobar -xyz
    depend:
        makedepend -- $(CFLAGS) -- $(SRCS)

  but makedepend does not know about the compiler specific include directories
  and does not seem to handle all C files properly, so the approach taken
  is to use the output of $(CC) -M (also note the handling of object files):

SRCS = file1.c file2.c ...
ALL_CFLAGS = -O -DHACK -I../foobar -xyz
OBJ_DIR = obj

ifeq ($(CC),gcc)
   DEP_FLAGS := -MM
else
   DEP_FLAGS := -M
endif

DEP_FILES := $(OBJ_FILES:$(OBJ_EXT)=.d)

ifeq ($(strip $(filter-out %sh,$(SHELL))),)
$(OBJ_DIR)/%.d: %.c
	@$(SHELL) -ec '$(CC) $(DEP_FLAGS) $(ALL_CFLAGS) $< \
		| sed '\''s/\($*\)\.o[ :]*/\1.o $(notdir $@) : /g'\'' > $@; \
		[ -s $@ ] || rm -f $@'
else
$(OBJ_DIR)/%.d: %.c
	@$(CC) $(DEP_FLAGS) $(ALL_CFLAGS) $< \
		| sed 's/\($*\)\.o[ :]*/\1.o $(notdir $@) : /g' > $@
endif

-include $(DEP_FILES)

   Another approach when CC is gcc is to use the -MD preprocessor option:

DEP_CFLAGS=-Wp,-MD,$(OBJ_DIR)/$(*F).d

$(OBJ_DIR)/%.o: %.c
	$(CC) -c $(ALL_CFLAGS) $(DEP_CFLAGS) $< -o $(OBJ_DIR)/$@

- The directory/source search is handled using the vpath make pattern:

vpath %.c $(C_SRC_DIRS)
vpath %.o $(OBJ_DIR)

- Static linking is handled by special make rule:

foo : foo.c -lcurses
        $(CC) $^ -o $@

will generate:

$(CC) foo.c /usr/lib/libcurses.a -o foo

- Phony commands will be used for reliability and efficiency instead of the
  "force" rule:

.PHONY : clean all

clean:
	$(RM) $(OBJ_FILES)

distclean: clean
	$(RM) $(DEP_FILES)

- Automatic rules are used to handle default compilation:

%.o : %.c
	$(CC) -c $(ALL_CFLAGS) $< -o $(OBJ_DIR)/$@

- A variable LINKER is computed automatically as the C/C++ linker command, based
  on the languages:

# Set C/C++ linker command & target

ifeq ($(filter c++,$(LANGUAGES)),c++)
   LINKER = $(CXX)

   ifeq ($(filter ada,$(LANGUAGES)),ada)
      # C++ and Ada mixed
      LINKER = $(OBJ_DIR)/c++linker
      LARGS = --LINK=$(LINKER)

      ifeq ($(strip $(filter-out %gcc %g++ %c++,$(CXX))),)
         # Case of GNU C++ and GNAT

$(LINKER): Makefile
	@echo \#!/bin/sh > $(LINKER)
	@echo unset BINUTILS_ROOT >> $(LINKER)
	@echo unset GCC_ROOT >> $(LINKER)
	@echo $(CXX) $$\* >> $(LINKER)
	@chmod +x $(LINKER)

      else
$(LINKER): Makefile
	@echo \#!/bin/sh > $(LINKER)
	@echo $(CXX) $$\* $(shell gcc -print-libgcc-file-name) >> $(LINKER)
	@chmod +x $(LINKER)
      endif
   endif
else
   ifeq ($(strip $(LANGUAGES)),c)
      # Case of C only
      LINKER = $(CC)
   endif
endif

- Linking is handled is a generic manner, based on the value of LANGUAGES,
  MAIN and LINKER:

ifeq ($(strip $(filter-out c c++,$(LANGUAGES))),)
# link with C/C++
link: $(OBJ_DIR)/$(EXEC)
$(OBJ_DIR)/$(EXEC): $(OBJ_FILES)
	$(LINKER) $(OBJ_FILES) -o $(OBJ_DIR)/$(EXEC) $(LDFLAGS)

else
ifeq ($(strip $(filter-out c c++ ada,$(LANGUAGES))),)
# link with Ada/C/C++

ifeq ($(MAIN),ada)
# Ada main
link: $(LINKER) force
	$(GNATMAKE) -P$(PROJECT_FILE) $(ADA_SOURCES) \
		    -largs $(OBJ_FILES) $(LARGS)
else
# C/C++ main
# The trick here is to force gnatmake to bind/link, even if there is no
# Ada main program. To achieve this effect, we use the -z switch, which is
# close enough to our needs, and the usual -n gnatbind switch and --LINK=
# gnatlink switch
link: $(LINKER) force
	$(GNATMAKE) -o $(OBJ_DIR)/$(EXEC) -z -P$(PROJECT_FILE) $(ADA_SOURCES) \
		-bargs -n -largs $(LARGS) \
		$(OBJ_FILES)
endif

else
# unknown set of languages, fail
link:   
        @echo do not know how to link with the following languages: $(LANGUAGES)        exit 1
endif
endif

######################################################
# Section generated by translating the project file
######################################################

- each project file generates one Makefile

- The Makefile is called Makefile.<project> where <project> is the name of the
  project, and is located at the same place the project file is.
  In the following sections, <project> will designate the project name in lower
  case, and <PROJECT> the project name in upper case.

- "extends" projects are fully translated into an expanded, non "extending"
  GNAT project file first (as is done internally when processed by GNAT tools)
  and then translated as a regular project into a Makefile

- each Makefile starts with the following section, used to handle multiple
  inclusions in other Makefiles:

ifeq ($(<PROJECT>_PROJECT),)
<PROJECT>_PROJECT=True

ifeq ($(BASE_DIR),)
   <config section>
   BASE_DIR=$(shell pwd)
   <PROJECT>_ROOT=True
endif

<PROJECT>_BASE_DIR := $(BASE_DIR)

The variables BASE_DIR and <PROJECT>_BASE_DIR are used to handle relative
directories.
The variable <PROJECT>_ROOT is used to know whether the current Makefile acts
as the main project or as a sub project.

The <config section> will contain variables configuring the environment, with
the following variables:

   CC = <c compiler>
   CXX = <c++ compiler>
   LANGUAGES = <list of project languages>
   AR_EXT = <extension of archive files>
   MAIN = <language of main program>         optional
   OBJ_EXT = <extension of object files>     optional
   C_EXT = <extension of C files>            optional
   CXX_EXT = <extension of C++ files>        optional
   ADA_SPEC = <extension of ada spec files>  optional
   ADA_BODY = <extension of ada body files>  optional

Here is a detail of these variables:
   - A variable LANGUAGES will contain the list of languages for the project:

   LANGUAGES = c ada c++

   which is taken directly from the project attribute Languages

   - A variable MAIN will specify the language of the main program:

   MAIN = c++

   which is taken from the project attribute Main_Language, default is "ada"

   - AR_EXT is the extension of archive files, usually .a:

   AR_EXT = .a

   - OBJ_EXT is the extension of object files, .o by default (in which case,
     it is not necessary to specify it):

   OBJ_EXT = .obj

   - C_EXT is the extension of C files, .c by default (no need to specify it)
     and is taken from the Naming package:

   [package Naming is]
      for Specification_Suffix ("C") use (".cfile");

   C_EXT = .cfile

   - CXX_EXT is the extension of C++ files, .cc by default (no need to specify
     it) and is taken from the Naming package:

   CXX_EXT = .cpp

   - ADA_SPEC is the extension of ada spec files, .ads by default, and is taken
     from the Naming package:

   ADA_SPEC = .1.ada

   - ADA_BODY is the extension of ada body files, .adb by default, and is taken
     from the Naming package:

   ADA_BODY = .2.ada

   ADA_SPEC and ADA_BODY variable are needed to handle file specific compilation

- project dependencies (with clauses) are handled by the following translation:

   with "../project1"

   is translated as:

   BASE_DIR=$(<PROJECT>_BASE_DIR)/../project1
   include $(BASE_DIR)/Makefile.project1

   or, if the with clause contains an absolute path:

   with "/a/b/project1"

   is translated as:

   BASE_DIR=/a/b
   include $(BASE_DIR)/Makefile.project1

- The attribute Source_Dirs is translated as two variables:

   for Source_Dirs use ("a", "/a/b/c");

   <PROJECT>_SRC_DIRS = $(<PROJECT>_BASE_DIR)/a /a/b/c
   SRC_DIRS += $(<PROJECT>_SRC_DIRS

   <PROJECT>_SRC_DIRS contains the direct project source directories
   SRC_DIRS will contain all the source directories from the current project and
   all its dependencies

- Non Ada source list is taken from the attribute Source_Files or
  Source_Files_List if present by taking only the relevant sources (following
  the naming convention), e.g:

   for Source_Files use ("a.adb", "foo.c", "foo1.c" "bar.cc");

   is translated as:

   C_SRCS = foo.c foo1.c
   CXX_SRCS = bar.cc

   and

   for Source_Files_List use "foo.txt";

   is translated as:

   SRCS := $(shell cat $(<PROJECT>_BASE_DIR)/foo.txt)
   C_SRCS = $(filter %$(C_EXT) $(SRCS))
   CXX_SRCS = $(filter %$(CXX_EXT) $(SRCS))

- If no Source_Files or Source_Files_List attribute is present, the list is
  computed by the following statement:

C_SRCS = \
  $(foreach name,$(<PROJECT>_SRC_DIRS),$(notdir $(wildcard $(name)/*$(C_EXT))))

Same for CXX_SRCS (C++ sources) if needed (if Language attribute contains "c++")

- The attribute Object_Dir is translated as variables <PROJECT>_OBJ_DIR and
  OBJ_DIR:

   for Object_Dir use "obj";

->

<PROJECT>_OBJ_DIR = $(<PROJECT>_BASE_DIR)/obj
OBJ_DIR = $(<PROJECT>_OBJ_DIR)

or if Object_Dir is an absolute path:

<PROJECT>_OBJ_DIR = /absolute/path/to/obj/dir
OBJ_DIR = $(<PROJECT>_OBJ_DIR)

  The two variables are needed because when including other Makefiles, the
  variable OBJ_DIR will be overriden, while the variable <PROJECT>_OBJ_DIR will
  never be.

- Ada switches are ignored since they are handled by gnat tools directly

- Global (non Ada) switches are translated as blank separated variables:

   Default_Switches ("C") -> CFLAGS
   Default_Switches ("C++") -> CXXFLAGS

   e.g:

   for Default_Switches ("C") use ("-g", "-O2");

   ->

   CFLAGS = -g -O2

- Specific rules are used to handle file specific compilation:

The rule

   [package Compiler is]
      for Switches ("file.c") use ("-g", "-O");

is translated as:

file$(OBJ_EXT):
	@echo $(CC) -c -g -O $< -o $(OBJ_DIR)/$@
ifndef FAKE_COMPILE
	@$(CC) -c -g -O $(C_INCLUDES) $(DEP_CFLAGS) $< -o $(OBJ_DIR)/$@
endif

C_INCLUDES and DEP_CFLAGS should always be added to the compilation flags,
they are computed automatically and provide the necessary source path and
flags to handle dependencies (they can be used for both C and C++).

The FAKE_COMPILE section is useful for computing which files need to be compiled
without actually compiling them.

The echo line provides a clean and stripped output, similar to the output given
by gnatmake when using project files

- The non-Ada parts of conditional sections (case statements in the project
  file) are handled by using nested "ifeq" statements:

for Switches ("C") use ("-O");

case Build is
   when Debug =>
      for Switches ("C") use Switches ("C") & "-g";

   when Production =>
      for Switches ("C") use Switches ("C") & "-O2";

   when others =>
      for Switches ("C") use ("-O2");
end case;

will be converted into:

BUILD_VAR := $(shell echo $(BUILD) | to_lower)

CFLAGS := -O

ifeq ($(BUILD_VAR),debug)
   CFLAGS := $(CFLAGS) -g
else
   ifeq ($(BUILD_VAR),production)
      CFLAGS := $(CFLAGS) -O2
   else
      CFLAGS := -O2
   endif
endif

to_lower is a small executable/script provided with Glide that converts the
standard input to lower case on standard output, e.g on unix:
#!/bin/sh
tr '[A-Z]' '[a-z]'

- The Attribute Main_Sources is translated as a variable ADA_SOURCES:

  for Main_Sources use ("main1.adb, "main2.adb");

  ->

  ADA_SOURCES = main1.adb main2.adb

- The name of the current project is specified as a variable PROJECT_FILE:

PROJECT_FILE = <project>

WARNING:
Due to the overriding rules of Makefiles, and to inclusions in other Makefiles,
do not attempt to replace <project> by $(PROJECT_FILE) or any other similar
changes, it won't work.

- Each multi-language project file will generate a library that is added to
  the list of libs using variable LIBS:

LIBS := $(<PROJECT>_OBJ_DIR)/lib<project>$(AR_EXT) $(LIBS)

- Each Makefile is terminated by the following section that terminates the
  conditional section started at the beginning of the Makefile, and includes
  the generic Makefile (if project is used as the main project), or
  update the list of dependencies (if project is used as a sub project):

ifeq ($(<PROJECT>_ROOT,True)
   include path/to/Makefile.glide
else
   DEPS_PROJECTS += $(<PROJECT>_BASE_DIR/<project>
endif

endif
