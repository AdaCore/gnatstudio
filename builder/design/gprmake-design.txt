Design of a multi-language tool build, called gprmake.

The purpose of this tool is handle automatically multi-language builds,
based on the GNAT Project files.

Similarly, other GNAT tools will be reviewed wrt multi-language support.
In particular:

- gnatclean: verify that gnatclean handles multi-language objects/projects.
  See D612-002.

- gnatname: add support for non Ada languages in gnatname.

- gnatls: ditto.

Requirements:
- Be extensible to new programming languages without having to modify
  gprmake itself
- Handle source dependencies automatically
- Handle different compilers for different languages
  - including Ada
  - not restricted to GCC

- Provide language-specific compilation/link options
- Provide file-specific compilation options
- Provide conditional sections based on configurable variables
- Handle building and use of libraries
- Use a process as similar as possible for each language
- Should be independent of the compiler version (in particular of the
  gnat version) as much as possible.
- Be as compatible as possible with gpr2make
- Provide useful defaults to ease set up and use with GNU compilers so
  that gprmake can either be very simple to use in the default cases (by
  not having to change dozens of settings), and also be configured for many
  different languages and toolchains.

Note: a prototype implementation of gprmake exists, which mimic closely the
implementation of gpr2make+Makefile.generic. In the document below, we will,
for simplicity, refer to the whole gpr2make+Makefile.generic+Makefile.prolog+
gprcmd as 'gpr2make', without distinguishing which file does actually what.

Since gpr2make was based on GNU makefiles, and gprmake is a tool written in
Ada, some decisions made for gpr2make do not necessarily make sense for gprmake.
this document is a good opportunity to fix these.

Although the behavior of the tool will be similar, the design and
implementation is expected to be different.

Related tools:
- gnatmake
- gcc
- make
- ant

Process:

- The tool will take a GNAT project file as its input,
  and generate calls to underlying tools to handle the compilation, bind and
  link process.

- sources files are recompiled when
  - no dependency info is available for this file
  - one of the dependencies has a timestamp more recent than the corresponding
    object file

- We do not want to get too deep in the handling of extra build processes (e.g.
  build of documentation, automatic code generation tools, extra preprocessing,
  ...), so this is intentionally left outside the control of this tool, to
  keep the process straight and simple. It is expected (and will be documented)
  that extra scripts or makefiles will be provided by the user that will take
  care of these extra steps, and that will call gprmake as part of these
  actions.

  However, a simple mechanism will be provided to perform such basic operations,
  as a way to generalize the current use of 'gnatmake' as the Ada driver
  (as opposed to calling separate 'gcc' for other languages and checking the
  dependencies). See below for more information.

  Rationale: the gprmake tool is focused on handling specific operations
  in an automated and simple way (namely, compiling, binding and linking a
  set of sources written in different languages). Trying to providing extra
  capabilities around this initial goal would mean starting to reimplement
  and reinvent most of the capabilities already provided by existing tools
  such as 'make', only in a more limited way.
  In addition, the main idea behind project files is to describe some
  project properties to external tools that will perform dedicated processing
  based on this information, whereas Makefile and similar files are a general
  way to describe a set of dependencies and actions to perform when these
  dependencies are outdated (this includes compiling sources, but is also
  used for pretty much anything, such as running a test case, launching
  a debugger, etc...); Keeping these two very distinct goals in the gprmake
  design is desirable, and introducing some (even simple) notions of
  'post-processing' or 'pre-processing' would inevitably bring the added
  complexity associated with the 'make'-like tools that we want to avoid.

TBC
[...]

Output created by gprmake:

- For the convenience of tools launched, gprmake will set an environment
  variable to the full path of the top level project file so that this info
  is shared easily among tools.

  This environment variable could be called GNAT_PROJECT

  Note: this raises the interesting question of whether some gnat tools
  (e.g. the gnat driver) should support this environment variable, and if set
  and no -P switch is specified on the command line, use this project instead.
  This would probably make things simpler for gprmake, in particular for setting
  the Builder'Driver attribute described below.

- (optionally) dependency files in the object directory

- object files, results of compilations

- executable and libraries, results of link

Input needed from gprmake:

- Specify compiler command
  Currently specified using IDE'Compiler_Command (<language>)

  IDE is not the best package to store this info now that we are using it
  in non IDE tools and that we are generalizing the notion of multi-language
  support.

  Question:
  - Should the GNAT compiler command be "gcc" or "gnatmake" ?
    It's currently "gnatmake" because that's what GPS needed, but this could
    be changed.

    -> The compiler command should be "gcc", since there's no reason to make
    a distinction between how Ada and non-Ada files are compiled. However,
    from a practical point of view, being able to delegate to gnatmake the
    process of compiling Ada files has also its advantages, in particular it
    insulates gprmake from incompatible changes in e.g. ALI format.

    Therefore, in order to support and generalize the use of gnatmake for Ada
    files on one hand, and on the other hand, support the invocation of
    'external tools' to handle build of a set of sources, we could add a new
    attribute Builder'Driver (<language>) that will, if specified, be
    called to check sources and compile them if needed. In this case, gprmake
    won't perform any timestamp check nor compilation for the sources of the
    designated language.

  For new attributes, we will reuse when it makes sense existing packages such
  as 'Compiler', 'Builder', 'Linker'.

  - Add new attributes:
    - Builder'Driver (<language>): If set, use this tool to check
      dependencies of sources for a given language, and rebuild them if
      needed.
      Defaults to ("<prefix>gnat", "make", "-c") for "ada".
      Defaults to () otherwise.

      Note: the default for Ada assumes that the GNAT_PROJECT environment
      variable has been set and is recognized by the gnat driver.
      Alternatively, we could provide a wrapper that would recognize it,
      and call gnatmake -P -c $GNAT_PROJECT directly.

    - Compiler'Compiler_Kind (<language>): Kind of compiler used for a given
      language. Recognized values are:
      - "GNU" (the default)
      - possibly others in the future, such as "Diab"
      This attribute is used by gprmake to set various defaults and change the
      way the build is handled in some cases.
      For now, any value other than "GNU" is considered as non-gnu compiler
      (e.g. "unknown").

    - Compiler'Driver (<language>): name of the tool that knows
      how to compile files of the given language. Defaults to "<prefix>gcc"
      where <prefix> is an optional prefix computed based on the name
      of the gprmake tool when launched (e.g. calling powerpc-elf-gprmake
      will set the default Compiler'Driver to "powerpc-elf-gcc").

    - Compiler'Compilation_Option (<language>): list of switches to be
      used to tell the Compiler'Driver to compile-only
      Defaults to ("-c") for non GNU compilers.
      Defaults to ("-c", "-x", <language>) for GNU compilers.

      Note: there's a potential risk of misuse of this attribute vs
      Default_Switches (<language>) by end users. Clarify in the documentation.
      -> use another name for this attribute ?

    See below 'Specify how to handle dependencies' for more info on the
    following attributes:

    - Compiler'Dependency_Option (<language>): list of switches to
      be used to tell the Compiler'Driver to generate a dependency file
      as part of the compilation process, e.g: ("-Wp,-MD,"),
      appended by Object_Dir & "file".d
      Defaults to ("-Wp,-MD,") for "c" and "c++" if the Compiler_Kind is set
      to "GNU".
      Defaults to () otherwise

      Question: How to specify whether the filename is part of the option,
      or should be the next option on the command line ?

      Answer: could assume that the name is always appended. If some compiler
      does not support it, there's always the possibility to use a wrapper,
      or use the Compute_Dependency attribute instead.

      If set, the Compute_Dependency attribute is ignored.

    - Compiler'Compute_Dependency (<language>): Command used to compute
      the dependency for a given language. This is a list of strings, the
      first string being the command itself, and the remaining strings are
      the options. The path to the filename will be appended to the command,
      and the source search path will be set via additional switches or
      environment variables using Compiler'Path_Env and Compiler'Include_Option
      Defaults to:
      (Compiler'Driver (<language>), "-M") & Default_Switches (<language>)

      If set and Compiler'Dependency_Option isn't, this command is called right
      after a source file has been recompiled to create or update its
      dependencies.

    -> If Dependency_Option and Compute_Dependency are both undefined or set
       to the empty value, gprmake will consider that sources for this language
       have no dependencies and will only compare the timestamp of the object
       and source file.

    -> Dependency files are assumed to be generated in Makefile format:
       source_file: source_dependencies

    - Handling of search path
      The source search path is extracted from the Source_Dirs attribute.
      Depending on the compiler, gprmake will need to:

      - use compiler switches (-I/path)
      - set an environment variable (ADA_INCLUDE_PATH, CPATH)

      New attributes are therefore added to tell gprmake how to behave:

      - New attribute Compiler'Path_Env (<language>)
        Defaults to ADA_INCLUDE_PATH for "ada"
        Defaults to CPATH for "c" and "c++"
        Defaults to "" otherwise

        If not null, gprmake will set this environment variable to the list
        of source directories for a given project before compiling the
        project's sources, if some compilations are needed.
        This list is concatenated and separated by the
        appropriate Path_Separator (":" under unix, ";" under Windows), and
        concatenated with the previous value of this env var, if any.

      - New attribute Compiler'Include_Option (<language>)
        Simple string, defaults to "-I" for all languages.

        If Compiler'Path_Env is null, each source dir is put on the command
        line, prepended with Compiler'Include_Option, e.g:
        if Source_Dirs is set to ("/a/b", "../foo"), gprmake appends
        ("-I/a/b", "-I../foo") to the compilation switches, translating if
        needed relative paths to absolute paths, resolved based on the
        project file's directory.

      Note: if a compiler uses/requires another mechanism to pass include
      options (such as an input file), this can be achieved by using a wrapper
      that will generate the input file, either from an environment variable
      (preferred to work around command line limitations) or from the
      command line.

  TBC

- Specify how to handle dependencies
  TBC

  - how are dependencies handled in other languages ?
    and verify that the proposed scheme would allow handling of these languages

    - fortran: does not really have the notion of dependencies between files,
    basically each proram is self contained, so the handling of dependencies is
    a simple matter of comparing the timestamp of the object file against the
    timestamp of the source file (correspond to having no
    Dependency_Option/Compute_Dependency attribute).

    - java: it seems that recompiling java files is handled either by IDEs
    directly or using tools such as 'ant', which is a make-like tool written in
    Java. Using 'ant' is in line with the Builder'Driver attribute
    proposed.

    - assembler: no dependencies with assembler files.
    With a GNU toolchain, using default values should work out of the
    box: "gcc" as the Compiler'Driver, and ("-c", "-x", "assembler") for the
    Compiler'Compilation_Option. No dependency files will be created.

  - for simplicity, gprmake will, at least in a first step, only understand
    Makefile fragments.
    In the future, it would probably make sense to handle other formats
    directly, in particular ALI files, so that compilation of Ada files can be
    handled without using gnatmake, and have Ada be handled very much
    like C or C++.

    Note: if some compiler (e.g. proprietary Ada compiler) does not provide
    the capabilities of generating a Makefile, the idea would be to provide a
    helper tool (a wrapper) that would extract the proprietary information
    (from e.g. the Ada 83 library) and generate the information in the
    expected format.
    Another approach would be to use gcc -c -gnatc to generate .ali files, and
    gnatmake -M to generate corresponding Makefile fragments. In this case,
    Compiler'Compute_Dependency would be set to a wrapper that would e.g.
    first call gcc -c -gnatc, and then gnatmake -M on the resulting ali file,
    or a separate tool written in Ada that would provide a similar capability.

  Note: as opposed to gpr2make which needed to post process the Makefile
  fragments (*.d files), gprmake does not need to modify these files, since
  the extra capability can be handled by the tool directly. Namely, handling
  of added/removed files in the project.

- Ability to specify that a given project should not be compiled
  This is needed so that external scripts/makefiles can be provided
  instead, and have other gpr-related tools such as GPS still be able to
  take advantage of the source list associated to a given project (for
  instance, to provide source navigation in GPS).

  -> This can be achieved by specifying an empty or special value to
  Builder'Driver (e.g. "null").

- Specify how to handle bind phase between languages
  TBC
  New attribute Binder'Driver (<language>)
  Defaults to "<prefix>gnatbind" for "ada"
  Defaults to "" for other languages

  If non null, Binder'Driver (<language>) is called for each language
  supported by the project.

  ??? which option should be passed to gnatbind ? Should -P project be passed
  we well ?

- Specify how to handle link phase between languages
  TBC

  Examples, to be generalized:
  - C: use Compiler'Driver ("c") (e.g. gcc)
  - C++: use Compiler'Driver ("c++") (e.g. g++)
  - Ada: use gnatlink with GNAT
  - C & C++: use Compiler'Driver ("c++")
  - C & Ada: use gnatlink with GNAT
  - Ada & C++: use gnatlink --LINK=Compiler_Command ("c++")

  Add new attribute Linker'Driver (<language>) which defaults to:
  - <prefix>gnatlink for Ada (or a wrapper called gnatld, see below)
  - Compiler'Driver (<language>) for other languages

  Add new attribute Linker'Default_Driver to specify the name of the tool
  called to handle linking. The linker driver is called in the object
  directory of the main project. This attribute is empty by default,
  meaning that a built-in driver is used, which behaves as follows:

  - for projects with a single language, call Linker'Driver (<language>)
  followed by ("-o", <executable name>),
  followed by the object of the main unit, followed by lib<project>.a if
  one has been created,
  followed by Linker'Default_Switches (<language>) or
  Linker'Switches (<main>) if defined.

  executable name is computed based on the project info and defaults, as
  done by gnatmake for Ada projects.

  Note: for Ada, since gnatlink expects an ali file rather than an object
  file, we could either:
  - add a new tool called tentatively gnatld, which
    is a wrapper around gnatlink that will call gnatlink by replacing the
    object of the main unit by the corresponding ali file (basically by
    replacing .o by .ali)
  - or enhance gnatlink to consider that if no .ali is specified, then the
    first .o file should be used instead (if a corresponding .ali file exists).

  This last option seems slightly preferrable (avoids having to introduce
  a new tool, makes it more compatible with other linkers).

  - for projects with multiple languages excluding Ada, call
  Linker'Driver (<language of the main unit>) followed by the same arguments
  as single language projects.

  - Ada+C ???
  - Ada+C++ ???

  Arguments passed to Linker'Default_Driver:
  for each language used in the project, provide the language, the name of the
  language linker driver, object of the main source if available,
  language of the main source, list of all objects for this language &
  associated linker options (such as libraries). This command will typically
  be a wrapper doing some tests and computation based on the language list.

  At link time, when some sources or executable are not up-to-date,
  an archive is built containing the object files of each language
  source for which no Builder'Driver is set, and recreated in the object
  directory of the main project as lib<project>.a.
  If Builder'Driver is set for all supported languages, no archive is created
  nor used (rationale: some systems do not support creating empty archives).

  Rationale: it is expected that when Builder'Driver is set, the specific
  builder driver will keep track of the object files required itself, and
  that they will be handled either by Linker'Driver, or via
  Linker'Default_Switches.
  Concerning the approach of building a single big archive, see also file
  link-order.txt for more info on why we're doing it.

  If a previous archive exists, it is removed before creating a new one, so
  as to avoid picking obsolete object files coming from deleted or moved source
  files.

  Linker'Default_Switches (<language>) or Linker'Switches (<executable>)
  are taken into account by gprmake and added to the end of the link options,
  after the lib<project>.a file.

- How to handle default values ?
  Lots of default values are suggested in this document.
  Would it be worth having a meta-configuration file used to set/change
  these default values ?

MISSING:

- more details on command line options supported
