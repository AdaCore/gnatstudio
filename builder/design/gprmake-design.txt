Design of a multi-language tool build, called gprmake.

The purpose of this tool is handle automatically multi-language builds,
based on the GNAT Project files.

Similarly, other GNAT tools will be reviewed wrt multi-language support.
In particular:

- gnatclean: verify that gnatclean handles multi-language objects/projects.
  See D612-002.

- gnatname: add support for non Ada languages in gnatname.

- gnatls: ditto.

Requirements:
- Be easily extensible to new programming languages
- Handle source dependencies automatically
- Handle different compilers for different languages
  - including Ada
  - not restricted to GCC

- Provide language-specific compilation/link options
- Provide file-specific compilation options
- Provide conditional sections based on configurable variables
- Handle building and use of libraries
- Use a process as similar as possible for each language
- Should be independent of the compiler version (in particular of the
  gnat version) as much as possible.
- Be as compatible as possible with gpr2make
- Provide useful defaults to ease set up and use with GNU compilers.

Note: a prototype implementation of gprmake exists, which mimic closely the
implementation of gpr2make+Makefile.generic. In the document below, we will,
for simplicity, refer to the whole gpr2make+Makefile.generic+Makefile.prolog+
gprcmd as 'gpr2make', without distinguishing which file does actually what.

Since gpr2make was based on GNU makefiles, and gprmake is a tool written in
Ada, sharing code with other GNAT tools (in particular the project parser),
some decisions made for gpr2make do not necessarily make sense for gprmake.

Although the behavior of the tool will be similar, the design and
implementation is expected to be different.

Related tools:
- gnatmake
- gcc
- make
- ant

Process:

- The tool will take a GNAT project file as its input,
  and generate calls to underlying tools to handle the compilation, bind and
  link process.

- sources files are recompiled when
  - no dependency info is available for this file
  - one of the dependencies has a timestamp more recent than the corresponding
    object file

- We do not want to get too deep in the handling of extra build processes (e.g.
  build of documentation, automatic code generation tools, extra preprocessing,
  ...), so this is intentionally left outside the control of this tool, to
  keep the process straight and simple. It is expected (and will be documented)
  that extra scripts or makefiles will be provided by the user that will take
  care of these extra steps, and that will call gprmake as part of these
  actions.

  However, a simple mechanism will be provided to perform such basic operations,
  as a way to generalize the current use of 'gnatmake' as the Ada driver
  (as opposed to calling separate 'gcc' for other languages and checking the
  dependencies). See below for more information.

  Rationale: the gprmake tool is focused on handling specific operations
  in an automated and simple way (namely, compiling, binding and linking a
  set of sources written in different languages). Trying to providing extra
  capabilities around this initial goal would mean starting to reimplement
  and reinvent most of the capabilities already provided by existing tools
  such as 'make', only in a more limited way.
  In addition, the main idea behind project files is to describe some
  project properties to external tools that will perform dedicated processing
  based on this information, whereas Makefile and similar files are a general
  way to describe a set of dependencies and actions to perform when these
  dependencies are outdated (this includes compiling sources, but is also
  used for pretty much anything, such as running a test case, launching
  a debugger, etc...); Keeping these two very distinct goals in the gprmake
  design is desirable, and introducing some (even simple) notions of
  'post-processing' or 'pre-processing' would inevitably bring the added
  complexity associated with the 'make'-like tools that we want to avoid.

TBC
[...]

Input needed from gprmake:

- Specify compiler command
  Currently specified using IDE'Compiler_Command (<language>)

  IDE is not the best package to store this info now that we are using it
  in non IDE tools. So this design seems a good opportunity to change that now
  rather than later.

  Question:
  - Should the GNAT compiler command be "gcc" or "gnatmake" ?
    It's currently "gnatmake" because that's what GPS needed, but this could
    be changed.

    -> The compiler command should be "gcc", since there's no reason to make
    a distinction between how Ada and non-Ada files are compiled. However,
    from a practical point of view, being able to delegate to gnatmake the
    process of compiling Ada files has also its advantages, in particular it
    insulates more gprmake from incompatible changes in e.g. ALI format.

    Therefore, in order to support and generalize the use of gnatmake for Ada
    files on one hand, and on the other hand, support the invocation of
    'external tools' to handle build of a set of sources, we could add a new
    attribute Builder'Driver (<language>) that will, if specified, be
    called to check sources and compile them if needed. In this case, gprmake
    won't perform any timestamp check nor compilation for the sources of the
    designated language.

  Suggestion:
  - Use existing packages 'Compiler', 'Builder'

  - Add new attributes:
    - Builder'Driver (<language>): If set, use this tool to check
      dependencies of sources for a given language, and rebuild them if
      needed.
      Defaults to ("<prefix>gnatmake", "-c", "-P", <Project_Name>) for "ada".
      Defaults to () otherwise.

    - Compiler'Compiler_Kind (<language>): Kind of compiler used for a given
      language. Recognized values are:
      - "GNU" (the default)
      - possibly others in the future, such as "Diab"
      This attribute is used by gprmake to set various defaults and change the
      way the build is handled in some cases.
      For now, any value other than "GNU" is considered as non-gnu compiler
      (e.g. "unknown").

    - Compiler'Driver (<language>): name of the tool that knows
      how to compile files of the given language. Defaults to "<prefix>gcc"
      where <prefix> is an optional prefix computed based on the name
      of the gprmake tool when launched (e.g. calling powerpc-elf-gprmake
      will set the default Compiler'Driver to "powerpc-elf-gcc").

    - Compiler'Compilation_Option (<language>): list of switches to be
      used to tell the Compiler'Driver to compile-only
      Defaults to ("-c") for non GNU compilers.
      Defaults to ("-c", "-x", <language>) for GNU compilers.

      Note: there's a potential risk of misuse of this attribute vs
      Default_Switches (<language>)

    See below 'Specify how to handle dependencies' for more info on the
    following attributes:

    - Compiler'Dependency_Kind (<language>): kind of dependency produced
      by Compiler'Driver (<language>).
      Recognized values are:
      - "ali"  (default for "Ada")
      - "makefile"  (default for other languages)

      This option tells gprmake how to retrieve the dependency information

    - Compiler'Dependency_Option (<language>): list of switches to
      be used to tell the Compiler'Driver to generate a dependency file
      as part of the compilation process, e.g: ("-Wp,-MD,"),
      appended by Object_Dir & "file".d
      Defaults to ("-Wp,-MD,") for "c" and "c++" if the Compiler_Kind is set
      to "GNU".
      Defaults to () otherwise

      See related attribute Compiler'Compute_Dependency below.
 
      Question: How to specify whether the filename is part of the option,
      or should be the next option on the command line ?

      Answer: could assume that the name is always appended. If some compiler
      does not support it, there's always the possibility to use a wrapper,
      or use the Compute_Dependency attribute instead.

      If set, the Compute_Dependency attribute is ignored.

      If not set, gprmake assumes that a separate tool needs to be launched
      before the compilation in order to compute the dependencies (such as
      gcc -M, makedep, or a wrapper, etc...).

    - Compiler'Compute_Dependency (<language>): Command used to compute
      the dependency for a given language. This is a list of strings, the
      first string being the command itself, and the remaining strings are
      the options. The path to the filename will be appended to the command,
      and the source search path will be set via additional switches or
      environment variables.
      Defaults to:
      (Compiler'Driver (<language>), "-M") & Default_Switches (<language>)

      If set and Compiler'Dependency_Option isn't, this command is called right
      after a source file has been recompiled.

    -> If Dependency_Option and Compute_Dependency are both undefined or set
       to the empty value, gprmake will consider that sources for this language
       have no dependencies and will only compare the timestamp of the object
       and source file.

    - Handle of search path
      The source search path is extracted from the Source_Dirs attribute.
      Depending on the compiler, gprmake will need to:

      - use compiler switches (-I/path)
      - set an environment variable (ADA_INCLUDE_PATH, CPATH)

      New attributes are therefore added to tell gprmake how to behave:

      - New attribute Compiler'Path_Env (<language>)
        Defaults to ADA_INCLUDE_PATH for "ada"
        Defaults to CPATH for "c" and "c++"
        Defaults to "" otherwise

        If not null, gprmake will set this environment variable to the list
        of source directories for a given project before compiling the
        project's sources, if some compilations are needed.
        This list is concatenated and separated by the
        appropriate Path_Separator (":" under unix, ";" under Windows), and
        concatenated with the previous value of this env var, if any.

      - New attribute Compiler'Include_Option (<language>)
        Simple string, defaults to "-I" for all languages.

        If Compiler'Path_Env is null, each source dir is put on the command
        line, prepended with Compiler'Include_Option, e.g:
        if Source_Dirs is set to ("/a/b", "../foo"), gprmake appends
        ("-I/a/b", "-I../foo") to the compilation switches, translating if
        needed relative paths to absolute paths, resolved based on the
        project file's directory.

      Note: if a compiler uses/requires another mechanism to pass include
      options (such as an input file), this can be achieved by using a wrapper
      that will generate the input file, either from an environment variable
      (preferred to work around command line limitations) or from the
      command line.

  TBC

- Specify how to handle dependencies
  TBC

  - investigate how dependencies are handled in other languages
    and verify that the proposed scheme would allow handling of these languages

    - fortran: apparently fortran does not really have the notion of
    dependencies between files (there is no 'with' nor '#include' in the C
    sense), so it's possible that the handling of dependencies is a simple
    matter of comparing the timestamp of the object file against the timestamp
    of the source file (correspond to having no
    Dependency_Option/Compute_Dependency attribute).

    - java: it seems that recompiling java files is handled either by IDEs
    directly or using tools such as 'ant', which is a make-like tool written in
    Java. Using 'ant' is in line with the Builder'Driver attribute
    proposed.

    - assembler: no dependencies with assembler files.
    With a GNU toolchain, using default values should work out of the
    box: "gcc" as the Compiler'Driver, and ("-c", "-x", "assembler") for the
    Compiler'Compilation_Option. No dependency files will be created.

  - for simplicity, gprmake will, at least in a first step, only understand
    Makefile fragments.
    In the future, it would probably make sense to handle other formats
    directly, in particular ALI files, so that compilation of Ada files is
    handled without using gnatmake.

    Note: if some compiler (e.g. proprietary Ada compiler) does not provide
    one of the capabilities listed above, the idea would be to provide a
    helper tool (a wrapper) that would extract the proprietary information
    (from e.g. the Ada 83 library) and generate the information in one of the
    supported formats (typically a Makefile fragment). Another approach
    would be to use gcc -c -gnatc to generate .ali files, and gnatmake -M
    to generate corresponding Makefile fragments. In this case,
    Compiler'Compute_Dependency would be set to a wrapper that would
    first call gcc -c -gnatc, and then gnatmake -M on the resulting ali file.

  Note: as opposed to gpr2make which needed to post process the Makefile
  fragments (*.d files), gprmake does not need to modify these files, since
  the extra capability can be handled by the tool directly. Namely, handling
  of added/removed files in the project.

  - switch added to the compiler to generate the dependency (optional)

  - post processing command to call to generate/update the dependency (optional)

- Ability to specify that a given project should not be compiled
  This is needed so that external scripts/makefiles can be provided
  instead, and have other gpr-related tools such as GPS still be able to
  take advantage of the source list associated to a given project (for
  instance, to provide source navigation in GPS).

  -> This can be achieved by specifying an empty or special value to
  Builder'Driver (e.g. "null").

- Specify how to handle bind phase between languages
  TBC
  New attribute Binder'Driver (<language>)
  Defaults to "<prefix>gnatbind" for "ada"
  Defaults to "" for other languages

  If non null, Binder'Driver (<language>) is called for each language
  supported by the project.

  ??? which option should be passed to gnatbind ? Should -P project be passed
  we well ?

- Specify how to handle link phase between languages
  TBC

  Examples, to be generalized:
  - C: use Compiler'Driver ("c") (e.g. gcc)
  - C++: use Compiler'Driver ("c++") (e.g. g++)
  - Ada: use gnatlink with GNAT
  - C & C++: use Compiler'Driver ("c++")
  - C & Ada: use gnatlink with GNAT
  - Ada & C++: use gnatlink --LINK=Compiler_Command ("c++")

  Add new attribute Linker'Driver (<language>) which defaults to:
  - <prefix>gnatlink for Ada
  - Compiler'Driver (<language>) for other languages

  Add new attribute Linker'Default_Driver to specify the name of the tool
  called to handle linking. Empty by default, meaning that a built-in driver
  is used, which behaves as follows:

  Add new attribute Linker'Output_Option, which defaults to
  "-o". This is the switch used to specify the output name.

  - for projects with a single language, call Linker'Driver (<language>)
  followed by (Linker'Output_Option (<language>)) & (<executable name>) if
  Linker'Output_Option is not null;
  followed by the object of the main unit, followed by lib<project>.a,
  followed by Linker'Default_Switches (<language>) or
  Linker'Switches (<main>) if defined.

  executable name is computed based on the project info and defaults, as
  done by gnatmake for Ada projects.

  - for projects with multiple languages excluding Ada, call
  Linker'Driver (<language of the main unit>) followed by the same arguments
  as single language projects.

  - Ada+C ???
  - Ada+C++ ???

  Arguments passed to Linker'Default_Driver:
  for each language used in the project, provide the language, the name of the
  language linker driver, object of the main source if available,
  language of the main source, list of all objects for this language &
  associated linker options (such as libraries). This command will typically
  be a wrapper doing some tests and computation based on the language list.

  At link time, when some sources or executable are not up-to-date,
  an archive is built containing the object files of each non Ada language
  source and recreated in the object directory of the main project as
  lib<project>.a.

  If a previous archive exists, it is removed before creating a new one, so
  as to avoid picking obsolete object files coming from deleted or moved source
  files.

  Linker'Default_Switches (<language>) or Linker'Switches (<executable>)
  are taken into account by gprmake and added to the end of the link options,
  after the lib<project>.a file.

- How to handle default values ?
  Lots of default values are suggested in this document.
  Would it be worth having a meta-configuration file used to set/change
  these default values ?

MISSING:

- more details on command line options supported
