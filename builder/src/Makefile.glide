# Generic Makefile to support compilation for multiple languages.
# Copyright (C) 2001 ACT-Europe

# This Makefile provides a very generic framework of the following
# functionnalities:
#
# Multi-language support (currently any combination of Ada/C/C++ supported)
# Automatic handling of source dependencies
# Handling of various C/C++ compilers
# Handling of Ada sources using the GNAT toolchain
# Complete build process (compile/bind/link)
# Individual compilation (on a file, or on a language)
# Handling of an object directory

# Here are the rules that can be used from the command line:
#
# build:         complete compile/bind/link process
# compile:       compile all files that are not up-to-date
# link:          bind/link
# ada:           compile all Ada files that are not up-to-date
# c:             ditto for C files
# c++:           ditto for C++ files
# <ada file>:    compile the specified file if needed.
# <object file>: compile the corresponding source file if needed.

# This Makefile expects the following variables to be set by the caller
# (typically another Makefile):
#
# C_EXT        extension of C files (optional)
# CXX_EXT      extension of C++ files (optional)
# OBJ_EXT      extension of object files for the target, e.g ".o"
# SRC_DIRS     blank separated list of source directories
# C_SRCS       explicit list of C sources (optional)
# CXX_SRCS     explicit list of C++ sources (optional)
# OBJ_DIR      a single directory where object files should be put
# LANGUAGES    a blank separated list of languages supported, e.g "ada c"
#              the current list of recognized languages is: ada, c, c++
# CC           name of the C compiler (optional)
# CXX          name of the C++ compiler (optional)
# AR           name of the archiver
# AR_FLAGS     flags to create an archive
# AR_EXT       file extension of an archive
# GNATMAKE     name of the GNAT builder, e.g "gnatmake" (optional)
# CFLAGS       default C compilation switches, e.g "-O2 -g" (optional)
# CXXFLAGS     default C++ compilation switches (optional)
# LDFLAGS      linker switches (optional)
# ADA_SOURCES  list of main Ada sources (optional)
# EXEC         name of the final executable (optional)
# MAIN         language of the main program (optional)
# PROJECT_FILE name of the GNAT project file (optional)

# Set the source search path for C and C++ if needed

ifneq ($(C_EXT),)
   vpath %$(C_EXT) $(SRC_DIRS)
endif

ifneq ($(CXX_EXT),)
   vpath %$(CXX_EXT) $(SRC_DIRS)
endif

# Set the object search path

vpath %$(OBJ_EXT) $(OBJ_DIR)
vpath %$(AR_EXT) $(OBJ_DIR)

# Default target is to build (compile/bind/link)
all: build

# Set C/C++ linker command & target

ifeq ($(filter c++,$(LANGUAGES)),c++)
   LINKER = $(CXX)

   ifeq ($(filter ada,$(LANGUAGES)),ada)
      # C++ and Ada mixed
      LINKER = $(OBJ_DIR)/c++linker
      LARGS = --LINK=$(LINKER)

      ifeq ($(strip $(filter-out %gcc %g++ %c++,$(CXX))),)
         # Case of GNU C++ and GNAT

$(LINKER): Makefile
	@echo \#!/bin/sh > $(LINKER)
	@echo unset BINUTILS_ROOT >> $(LINKER)
	@echo unset GCC_ROOT >> $(LINKER)
	@echo $(CXX) $$\* >> $(LINKER)
	@chmod +x $(LINKER)

      else
$(LINKER): Makefile
	@echo \#!/bin/sh > $(LINKER)
	@echo $(CXX) $$\* $(shell gcc -print-libgcc-file-name) >> $(LINKER)
	@chmod +x $(LINKER)
      endif
   endif
else
   ifeq ($(strip $(LANGUAGES)),c)
      # Case of C only
      LINKER = $(CC)
   endif
endif

C_INCLUDES := $(foreach name,$(SRC_DIRS),-I$(name))
ALL_CFLAGS = $(CFLAGS) $(C_INCLUDES)
ALL_CXXFLAGS = $(CXXFLAGS) $(C_INCLUDES)

# Compute list of objects based on languages

ifeq ($(strip $(filter c,$(LANGUAGES))),c)
   # Compute list of C sources automatically unless already specified

   ifndef C_SRCS
      C_SRCS := \
        $(foreach name,$(SRC_DIRS),$(notdir $(wildcard $(name)/*$(C_EXT))))
   endif

   C_OBJECTS := $(C_SRCS:$(C_EXT)=$(OBJ_EXT))
   OBJECTS += $(C_OBJECTS)
endif

ifeq ($(strip $(filter c++,$(LANGUAGES))),c++)
   # Compute list of C++ sources automatically unless already specified

   ifndef CXX_SRCS
      CXX_SRCS := \
        $(foreach name,$(SRC_DIRS),$(notdir $(wildcard $(name)/*$(CXX_EXT))))
   endif

   CXX_OBJECTS := $(CXX_SRCS:$(CXX_EXT)=$(OBJ_EXT))
   OBJECTS += $(CXX_OBJECTS)
endif

OBJ_FILES := $(foreach name,$(OBJECTS),$(OBJ_DIR)/$(name))

# To handle C/C++ dependencies, we associate a small file for each
# source that will list the dependencies as a make rule, so that we can then
# include these rules in this makefile, and recompute them on a file by file
# basis

DEP_FILES := $(OBJ_FILES:$(OBJ_EXT)=.d)

# Ada compilations are taken care of automatically, so do not mess with Ada
# objects, only with main sources.

compile: libobjects$(AR_EXT) $(ADA_SOURCES)

libobjects$(AR_EXT): $(OBJECTS)
ifeq ($(strip $(filter-out %sh,$(SHELL))),)
	(cd $(OBJ_DIR); $(AR) $(AR_FLAGS) $@ $(strip $(OBJECTS)))
else
	$(AR) $(AR_FLAGS) $(OBJ_DIR)/libobjects$(AR_EXT) $(OBJ_FILES)
endif

# Linking rules

# There are three cases:
#
# - C/C++ sources
#
# - Ada/C/C++, main program is in Ada
#
# - Ada/C/C++, main program is in C/C++

ifeq ($(strip $(filter-out c c++,$(LANGUAGES))),)
# link with C/C++
link: $(OBJ_DIR)/$(EXEC)
$(OBJ_DIR)/$(EXEC): $(OBJ_FILES)
	$(LINKER) $(OBJ_FILES) -o $(OBJ_DIR)/$(EXEC) $(LDFLAGS)

build: compile link

else
ifeq ($(strip $(filter-out c c++ ada,$(LANGUAGES))),)
# link with Ada/C/C++

ifeq ($(MAIN),ada)
# Ada main
link: $(LINKER) force
	$(GNATMAKE) -b -l -P$(PROJECT_FILE) $(ADA_SOURCES) \
		 -largs $(OBJ_FILES) $(LARGS) $(LDFLAGS)

build: libobjects$(AR_EXT) $(LINKER) force
	$(GNATMAKE) -P$(PROJECT_FILE) $(ADA_SOURCES) \
		 -largs $(OBJ_DIR)/libobjects$(AR_EXT) $(LARGS) $(LDFLAGS)

else
# C/C++ main
# The trick here is to force gnatmake to bind/link, even if there is no
# Ada main program. To achieve this effect, we use the -z switch, which is
# close enough to our needs, and the usual -n gnatbind switch and --LINK= 
# gnatlink switch.

link: $(LINKER) force
	$(GNATMAKE) -o $(OBJ_DIR)/$(EXEC) -z -P$(PROJECT_FILE) $(ADA_SOURCES) \
		 -bargs -n -largs $(OBJ_DIR)/libobjects$(AR_EXT) \
		 $(LARGS) $(LDFLAGS)

build: libobjects$(AR_EXT) $(LINKER) force
	$(GNATMAKE) -o $(OBJ_DIR)/$(EXEC) -z \
		 -P$(PROJECT_FILE) $(ADA_SOURCES) \
		 -bargs -n \
		 -largs $(OBJ_DIR)/libobjects$(AR_EXT) $(LARGS) $(LDFLAGS)
endif

else
# unknown set of languages, fail
link:
	@echo do not know how to link with the following languages: $(LANGUAGES)
	exit 1
endif
endif

# Automatic handling of dependencies

ifeq ($(CC),gcc)
   DEP_FLAGS := -MM
else
   DEP_FLAGS := -M
endif

ifeq ($(strip $(filter-out %sh,$(SHELL))),)
$(OBJ_DIR)/%.d: %$(C_EXT)
	@echo updating dependencies for $(notdir $<)
	@$(SHELL) -ec '$(CC) $(DEP_FLAGS) $(ALL_CFLAGS) $< \
	| sed '\''s/\($*\)\$(OBJ_EXT)[ :]*/\1$(OBJ_EXT) $(notdir $@) : /g'\'' > $@; \
	[ -s $@ ] || rm -f $@'

$(OBJ_DIR)/%.d: %$(CXX_EXT)
	@echo updating dependencies for $(notdir $<)
	@$(SHELL) -ec '$(CXX) $(DEP_FLAGS) $(ALL_CXXFLAGS) $< \
	| sed '\''s/\($*\)\$(OBJ_EXT)[ :]*/\1$(OBJ_EXT) $(notdir $@) : /g'\'' > $@; \
	[ -s $@ ] || rm -f $@'
else
$(OBJ_DIR)/%.d: %$(C_EXT)
	@echo updating dependencies for $(notdir $<)
	@$(CC) $(DEP_FLAGS) $(ALL_CFLAGS) $< \
	| sed 's/\($*\)\$(OBJ_EXT)[ :]*/\1$(OBJ_EXT) $(notdir $@) : /g' > $@

$(OBJ_DIR)/%.d: %$(CXX_EXT)
	@echo updating dependencies for $(notdir $<)
	@$(CC) $(DEP_FLAGS) $(ALL_CXXFLAGS) $< \
	| sed 's/\($*\)\$(OBJ_EXT)[ :]*/\1$(OBJ_EXT) $(notdir $@) : /g' > $@
endif

-include $(DEP_FILES)

# Compilation rules

.SUFFIXES: $(C_EXT) $(CXX_EXT)

# File rules

# Compile C files individually
%$(OBJ_EXT) : %$(C_EXT)
	$(CC) -c $(ALL_CFLAGS) $< -o $(OBJ_DIR)/$@

# Compile C++ files individually
%$(OBJ_EXT) : %$(CXX_EXT)
	$(CXX) -c $(ALL_CXXFLAGS) $< -o $(OBJ_DIR)/$@

# Compile Ada body files individually
%.adb : force
	$(GNATMAKE) -c -P$(PROJECT_FILE) $@

# Compile Ada spec files individually
%.ads : force
	$(GNATMAKE) -c -P$(PROJECT_FILE) $@

# Languages rules

# Compile all Ada files in the project
ada :
	$(GNATMAKE) -c -P$(PROJECT_FILE)

# Compile all C files in the project
c : $(C_OBJECTS)

# Compile all C++ files in the project
c++ : $(CXX_OBJECTS)

.PHONY: clean all force ada

clean:
	$(RM) $(OBJ_DIR)/*$(OBJ_EXT)
	$(RM) $(OBJ_DIR)/*.ali
	$(RM) $(OBJ_DIR)/b~*
	$(RM) $(OBJ_DIR)/b_*
	$(RM) $(OBJ_DIR)/*$(AR_EXT)
	$(RM) $(OBJ_DIR)/$(EXEC)
	$(RM) $(DEP_FILES)

force:

