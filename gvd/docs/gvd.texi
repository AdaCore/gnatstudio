\input texiplus   @c -*-texinfo-*-
@c %**start of header
@setfilename gvd.info
@settitle Using the GNU Visual Debugger
@syncodeindex fn cp

@set GVDVersion 1.2.0

@titlepage

@title Using the GNU Visual Debugger
@subtitle Version @value{GVDVersion}
@subtitle Document revision level $Revision$
@subtitle Date: $Date$
@author ACT-Europe

@page
@vskip 0pt plus 1filll

Copyright @copyright{} 2000-2001, ACT-Europe.
This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are clearly
marked as alterations and (2) this copyright notice is included
unmodified in any copy.

@end titlepage

@ifinfo
@node Top, Introduction, (dir), (dir)
@top Using the GNU Visual Debugger

Using the GNU Visual Debugger

GVD, the GNU Visual Debugger

Version @value{GVDVersion}

Date: $Date$

Copyright @copyright{} 2000-2001, ACT-Europe.
This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are clearly
marked as alterations and (2) this copyright notice is included
unmodified in any copy.

@menu
* Introduction::
* Description of the main windows::
* Integrating GVD::
* Debugging a program remotely::
* Environment::

@detailmenu
 --- The Detailed Node Listing ---

Description of the main windows

* The Menu Bar::
* The Tool Bar::
* The Call Stack Window::
* The Data Window::
* The Memory Window::
* The Explorer Window::
* The Source Window::
* The Assembly Window::
* The Debugger Console::
* The Status Line::

Integrating GVD

* General Information::
* Using GVD with Glide::
* Using GVD with Emacs::
* Using GVD with XEmacs::
* Using GVD as a Library::
* Using GVD as a Corba Object::

Debugging a program remotely

* Using GVD with a Remote Debugger::
* Using GVD with a Remote Program::

Environment

* Command Line Options::
* Environment Variables::
* Files::
* Limitations::
* Reporting bugs::

@end detailmenu
@end menu
@end ifinfo

@c --------------------------------------------------------------------
@node Introduction
@chapter Introduction
@c --------------------------------------------------------------------

@noindent
GVD is a graphical front-end for text based debuggers such as GDB.
A knowledge of the basics of the underlying debugger used by GVD will help
understanding how GVD works and what kind of functionalities it provides.
Please refer to the debugger specific documentation (e.g the GDB documentation)
for more details.

The purpose of a debugger such as GVD is to allow you to see what is going on
inside another program while it executes, or what another program was doing
at the moment it crashed.

@c --------------------------------------------------------------------
@node Description of the main windows
@chapter Description of the main windows
@c --------------------------------------------------------------------

@noindent

@menu
* The Menu Bar::
* The Tool Bar::
* The Call Stack Window::
* The Data Window::
* The Memory Window::
* The Explorer Window::
* The Source Window::
* The Assembly Window::
* The Debugger Console::
* The Status Line::
@end menu

@iftex
@image{main-window, 12.7cm}
@end iftex

@c --------------------------------------------------------------------
@node The Menu Bar
@section The Menu Bar
@c --------------------------------------------------------------------

The menu bar provides operations that act either at a global level, or on
a specific debugger. Since GVD can handle multiple debuggers at the same
time, the commands that deal with debugging on a specific module are always
using the current debugger to perform the various operations provided by the
menus. Key shortcuts are also available for the most common operations, and
are displayed in the menus themselves.
Here is a detailed list of the menu items that can be found in the menu bar:

@subsection File
@table @b
   @item Open Program...
@anchor{open program menu}
Open a file selection dialog that allows you to choose a program to
debug. The program to debug is either an executable for native debugging, or
a partially linked module for cross environments (e.g VxWorks).
Do not use this menu to edit a source file, see the @ref{The Explorer Window},
or the @ref{open source menu}.

   @item New Debugger...
@anchor{new debugger menu}
Open a dialog to create a new debugger window. The new debugger window will be
added in the main window.
This dialog allows you to specify the name of the executable to debug by
entering its name in the @i{Program File entry}, or by clicking on the
@dots{} button to open a file selection dialog. You can also select
the machine on which your underlying debugger (e.g GDB) will run. By default,
the debugger will run on the current machine (the machine on which GVD is
running), so you only need to specify a value for remote debugging.
For more information, see @ref{Debugging a program remotely}.

@b{Limitation}: under Windows systems, you can only have one debugger window
at a time, so use this menu only after having closed the current debugger, and
launch several GVDs to debug multiple processes.
See also the @ref{close menu}, to close a debugger window.

   @item Open Core Dump...
@anchor{core files}
This will open a file selection dialog that allows you to debug a core file
instead of debugging a running process. Note that you must first specify an
executable to debug, by either using the @ref{open program menu}, or
by specifying the name of the executable on the command line (@pxref{Command
Line Options}).

   @item Edit Source
Launch an external editor that will open the file currently displayed
in se source window (see @ref{The Source Window}). You can specify the name of
the external editor by using the @ref{preferences menu}.

   @item Open Source...
@anchor{open source menu}
Open a file selection dialog that allows you to load any source file in the
source window. You can also open directly the source files used in your
application by using @ref{The Explorer Window}.

   @item Open Session...
Open a dialog giving you the list of sessions that are saved under the
@file{$HOME/.gvd/sessions} directory under Unix systems, and
@file{%HOME%\.gvd\sessions} under Windows systems. The @i{Session List} area
lists all
such sessions. The @i{Session} field shows the current selection (that can
be filled either by entering the name on the keyboard, or by clicking in the
@i{Session List} window). The right area gives you a list of sub-sessions,
or debuggers launched during a selected session. You can select any of the
debuggers of a specific session in order to replay one, some or all of them.
To select the debuggers, either click on the check box on the left of each
item, or use the @i{Select All} and @i{Unselect All} buttons.
If you confirm by clicking on the @i{OK} button, GVD will open a new
debugger for each sub session selected and will replay all the commands
automatically.

   @item Save Session As...
Open a dialog similar to the @i{Open Session} dialog, allowing you to specify
the name of the session to save, and what sub sessions/debuggers to save.
By default, this will save all the sub sessions ran in GVD since start up.

   @item Attach To Process...
Instead of starting a program to debug, you can instead attach GVD to an
already running process. To do so, you need to specify the process id
of the process you want to debug. The process might be busy in an
infinite loop, or waiting for event processing. Note that as for
@ref{core files}, you need to specify an executable before attaching to a
process.

   @item Detach Process
Detach the currently debugged process from the underlying debugger.
This means that the executable will continue to run outside GVD. You can use
the @i{Attach To Process} menu to re-attach later to this process.

   @item Change Directory...
Open a directory selection dialog to change the directory in the underlying
debugger. Useful in particular before executing a process, or loading a
file using a relative path.

   @item Close
@anchor{close menu}
Close the current debugger. If this is the last debugger, the main window
will remain visible, but with a gray area instead of the notebook containing
the Data, Explorer, Source and Debugger windows.
To create a new debugger, see also the @ref{new debugger menu}.

   @item Exit
Save the window settings and exit GVD.
@end table

@subsection Edit
The only item currently available in this menu is the preferences menu.

@subsubsection Preferences...
@anchor{preferences menu}
Open a dialog window allowing you to modify the global preferences of GVD.
To enable the new preferences, you simply need to confirm by pressing the
@i{OK} button. The preferences will be saved in a file located under
@file{$HOME/.gvd/preferences} under Unix systems, and
@file{%HOME%\.gvd\preferences} under Windows systems.

To simply test your changes, you can use the @i{Test} button. Pressing
the @i{Cancel} button will undo all your changes.

The preferences dialog is composed of five areas, accessible through the
tabs at the top of the dialog, labelled @i{General}, @i{Source}, @i{Data},
@i{Command}, @i{Memory}, @i{Helpers}. Each page corresponds to a section of
preferences.

@table @b
@item General
Give access to the general preferences in GVD.

@table @i
@item Break On Exceptions
Whether a breakpoint on all exceptions should be set by default when loading
a program.

@item Status Bar Time Out
Time after which a message in the status bar will disappear. Messages that
have disappeared can be displayed using the arrow in the bottom left area
of the main window.

@item File Extensions
Filename extensions recognized for each of the following supported languages:
Ada, C, C++.
Each text entry is a semicolon separated list of filename extensions, e.g
@code{.ads;.adb} for Ada files.
@end table

@item Source
You can modify the preferences for the @i{Explorer}, @i{Source}, and
@i{Assembly} windows, in particular the font and colors used to highlight
elements.

@table @i
@item Display Explorer Tree
Whether the list of files should be displayed.

@item File Name Background
Color used for the background of the file name in the editor.
This is also used for the background of the current frame in the Call Stack
window.

@item Font
Font used in the editor.

@item Show Line Numbers
Whether line numbers should be displayed in the code editor.

@item Show Lines with Code
Whether dots should be displayed in the code editor for lines that
contain code.

@item Automatic Display of Variables
Whether tooltips should appear automatically to display the value of the
variable under the cursor.

@item Syntax Highlighting
Indicate whether the editor should provide color highlighting.

@item Strip Carriage Return
Whether Carriage Return characters will be stripped when reading a file.
GVD tries to detect this automatically but in some rare cases, it can be useful
to enable this option by hand.

@item Comments
Color used for comments.

@item Strings
Color used for string literals.

@item Keywords
Color used for keywords.

@item Current Line
The color to use to highlight the current line in the editor
@end table

@item Data
Let you change the preferences of the @i{Data Window}, in particular
the fonts and colors used to display the data graphically.

@table @i
@item Clickable Item
Color to use for the items that are clickable (e.g pointers).

@item Title Background
Color to use for the background of the title.

@item Changed Data
Color used to highlight fields that have changed since the last update.

@item Auto-Refreshed
Color used for auto-refreshed items.

@item Frozen
Color used for frozen items.

@item Separate Window
Whether the Data window should be a separate window.

@item 3D Look
Whether the items should have a 3d look.

@item Item Name
Font used for the name of the item.

@item Item Value
Font used to display the value of the item.

@item Item Type
Font used to display the type of the item.

@item Hide Big Items
@anchor{hiding big items}
Whether items larger than a given size will start in a hidden state.

@item Big Item Height
Items taller than this value will start hidden.

@item Detect Aliased (shared data structures)
If enabled, do not create new items when an item with the same address is
already present in the canvas.

@item Display Grid Points
Whether the grid should be displayed in the canvas.

@item Auto-Align Displays on Nearest Grid Point
Whether items should be aligned on the grid.

@item Show Call Stack
@anchor{Show Call Stack}
Whether the Call Stack view should be shown in the data window.
@end table

@item Command
Enable you to change the preferences of the @i{Debugger Console}, also
known as the @i{Command Window}.

@table @i
@item Color Highlighting
Set the color used to highlight debugger commands and prompts.
@item Font
Set the font name and size for the @i{Debugger Console}. Note that it
is recommended to use a fixed size font such as Courier to get a better
looking display.
@end table

@item Memory
Gives access to the preferences related to the memory view window.
The values are currently not taken into account.

@table @i
@item Font
Set the font name and size to display the contents of the memory. It
is recommended to use a fixed size font such as Courier to get a better
looking display.

@item Default Color
Color used by default in the memory view window.

@item Color Highlighting
Color used for highlighted items in the memory view.

@item Selection
Color used for selected items in the memory view.

@item Modified
Color used for modified items in the memory view.
@end table

@item Helpers
@anchor{helpers menu}
Helpers are external programs that are used by GVD to perform specific
actions.

@table @i
@item Edit Sources
Program used by the @i{Edit Current Source} menu. Special arguments are
@i{%f} that is replaced by the full path name to the current file,
and @i{%l} that is replaced by the current line number.
This value is superseded by the environment variable
@code{GVD_EDITOR} if it exists (see also @ref{GVD_EDITOR}).
Try e.g using "xterm -e /bin/vi %f +%l" if you prefer vi.

@item List Processes
This is the command that generates a list of processes
suitable for process actions such as attach. This helper is ignored under
Windows when using a local debugger, since the computation of the list of
processes is built-in under this OS.
@item Remote Shell
Command used to establish a remote connection
(see @ref{Using GVD with a Remote Debugger}).
@item Remote Copy
Command used to copy files remotely
(see @ref{Using GVD with a Remote Debugger}).
@item HTML Browser
@anchor{HTML browser}
Command used to browse HTML files, in particular the HTML version of this
help file.
@end table

@end table

@subsection Program
@table @b
   @item Run/Start...
Open a dialog window allowing you to specify the arguments to pass to the
program, and whether the program should be stopped at the beginning of the
main program. If you confirm by clicking on the @i{OK} button, the program
will be launched according to the arguments entered.

   @item Step
Step the program until it reaches a different source line.

   @item Step Instruction
Step the program by one machine instruction exactly.

   @item Next
Step the program, proceeding through subroutine calls.

   @item Next Instruction
Step the program by one machine instruction but proceed through subroutine
calls.

   @item Finish
Continue until selected stack frame returns.

   @item Continue
Continue the program being debugged.

   @item Interrupt
Interrupt asynchronously the program being debugged. Note that depending on
the state of the program, you may stop it in low level system code that does
not have debug information, or even in some cases, a coherent state. Use
of breakpoints is recommended instead to stop programs.

@end table

@subsection Command
@table @b
   @item Command History...
Open a dialog with the list of commands executed in the current session.
You can select any number of items in this list and replay the selection
automatically.

   @item Clear Window
Clear the debugger console window. This removes the recording of interchanges
between GVD and the underlying debugger, and resets the scrollbar
accordingly.

@end table

@subsection Data
Note that most items in this menu need to access to the underlying debugger
when the process is stopped, not when it is running, which means that you first
need to stop the process on a breakpoint, or interrupt it before using
the following items. Failing to do so will result in blank windows.

@table @b
   @item Call Stack
      Display/Hide the Call Stack window inside the Data window.
      See @ref{The Call Stack Window} for more details. Note that you can
      also display or hide the call stack at the preferences level, see
      @ref{Show Call Stack}.

   @item Threads...
      The process being debugged needs to be stopped before using this window,
      otherwise a blank list will be displayed.
      Open a new window containing the list of threads currently present in
      the executable as reported by the underlying debugger. For each thread,
      it will give information such as internal identifier, name and status.
      This information is language and debugger dependent. You should refer to
      the underlying debugger's documentation for more details.

      When supported by the underlying debugger, clicking on a thread will
      change the context (variables, call stack, source file) displayed by GVD,
      allowing you to inspect the new thread's stack.

   @item Tasks...
      As for the thread window, the process being debugged needs to be stopped
      before using this window.
      For GDB only, this will open a new window containing the list of Ada
      tasks currently present in the executable. Similarly to the thread
      window, you can switch to the task context by clicking on it, if
      supported by GDB. See the GDB documentation for the list of
      items displayed for each task.

@iftex
@image{tasks, 12.7cm}
@end iftex

@iftex
@image{breakpoints, 12.7cm}
@end iftex

   @item Edit Breakpoints...
      Open an advanced window to create any kind of breakpoint. For simple
      breakpoint creation, see the description of the source window.

   @item Examine Memory...
      Open a memory viewer/editor. See @ref{The Memory Window} for more
      details.

   @item Display Local Variables
      Open an item in the Data Window containing all the local variables
      for the current frame.

   @item Display Arguments
      Open an item in the Data Window containing the arguments
      for the current frame.

   @item Display Registers
      Open an item in the Data Window containing the machine registers
      for the current frame.

   @item Display Any Expression...
      Open a small dialog letting you specify an arbitrary expression
      in the Data Window. This expression can be a variable name, or a
      more complex expression, following the syntax of the underlying debugger.
      See the documentation of e.g gdb for more details on the syntax.
      The check button @i{Expression is a subprogram call} should be enabled
      if the expression is actually not an expression but rather a debugger
      command (e.g @code{p/x var}) or a procedure call in the program being
      debugged (e.g @code{call my_proc}).

   @item Refresh
      Refresh all the items displayed in the Data Window.
@end table

@subsection Help
@table @b
   @item GVD Manual...
Open this documentation in an HTML browser (as specified in the
@ref{HTML browser}).

   @item About...
Open a simple information box about GVD.
@end table

@c --------------------------------------------------------------------
@node The Tool Bar
@section The Tool Bar
@c --------------------------------------------------------------------

@noindent
   The tool bar can be detached from the main window, using the left area:
   click on this left gray area, and move your mouse outside the window. The
   tool bar will be detached and its form will also change from a horizontal
   bar to a vertical bar with two columns.
   To move it back to the main window, double click on the left area.

@table @b
  @item Run
Run the program using the arguments set previously (e.g on the command
line).
  @item Start
Same as @i{Run}, but stops at the beginning of the main subprogram.

  @item Step
Step the program until it reaches a different source line.

  @item Stepi
Step the program by one machine instruction exactly.

  @item Next
Step the program, proceeding through subroutine calls.

  @item Nexti
Step the program by one machine instruction but proceed through subroutine
calls.

  @item Finish
Continue until selected stack frame returns.

  @item Cont
Continue the program being debugged.

  @item Up
Go up one frame in the call stack.

  @item Down
Go down one frame in the call stack.

  @item Interrupt
Interrupt asynchronously the program being debugged. Note that depending on
the state of the program, you may stop it in low level system code that does
not have debug information, or even in some cases, a coherent state. Use
of breakpoints is recommended instead to stop programs.

@end table

@c --------------------------------------------------------------------
@node The Call Stack Window
@section The Call Stack Window
@c --------------------------------------------------------------------

@noindent
   The call stack window gives a list of frames corresponding to the current
   stack of execution for the current thread/task.
   The top frame corresponds to the outermost frame where the thread is
   currently stopped. This frame corresponds to the first function
   executed by the current thread (e.g main for the main thread in C).
   You can click on any frame to switch to the caller's context, this will
   update the display in the source window. See also the up and down
   buttons in the tool bar to go up and down one frame in the call stack.

   The contextual menu (right mouse button) allows you to choose which
   information you want to display in the call stack window (via check buttons):
   @itemize @bullet
      @item Frame number: the debugger frame number (usually starts at 0 or 1)
      @item Program Counter: the low level address corresponding to the
            function's entry point.
      @item Subprogram Name: name of the subprogram in a given frame
      @item Parameters: parameters of the subprogram
      @item File Location: filename and line number information.
   @end itemize

   By default, the subprogram and parameters are displayed.
   You can hide the call stack window using the menu Data->Call Stack, and
   show it again using the same menu (this menu item is a check button that
   can be enabled/disabled)

@c --------------------------------------------------------------------
@node The Data Window
@section The Data Window
@c --------------------------------------------------------------------

@c --------------------------------------------------------------------
@subsection Description
@c --------------------------------------------------------------------

@noindent
   The data window will contain all the graphic boxes that can be accessed
   using the @i{Data->Display} menu items, or the data window
   @i{Display Expression...} contextual menu, or the source window
   @i{Display} contextual menu items, or finally the
   @i{graph} command in the debugger console.

   For each of these commands, a box will be displayed in the data window
   with the following information:

@iftex
@image{canvas, 12.7cm}
@end iftex

   @itemize @bullet
   @item A title bar containing:
     @itemize @bullet
     @item The number of this expression: this is a positive number starting
       from 1 and incremented for each new box displayed. It represents the
       internal identifier of the box.

     @item The name of the expression: this is the expression or variable
       specified when creating the box.

     @item An icon representing either a flash light, or a lock.
       This is a click-able icon that will change the state of the box from
       automatically updated (the flash light icon) to frozen (the lock
       icon).
       When frozen, the value is grayed, and will never change, until you change
       the state. When updated, the value of the box will be recomputed each
       time an execution command is sent to the debugger (e.g step, next).

     @item An icon representing an 'X'.
       You can click on this icon to close/delete any box.
     @end itemize

   @item A main area.
     The main area will display the data value hierarchically
     in a language sensitive manner. The canvas knows about data structures
     of various languages (e.g @code{C}, @code{Ada}, @code{C++}) and will
     organize them accordingly.
     For example, each field of a record/struct/class, or each item of an
     array will be displayed separately. For each subcomponent, a thin box
     is displayed to separate it from the other components.
   @end itemize

   A contextual menu, taking into account the current component pointed to
   by the mouse, gives access to the following capabilities:
   @table @b
     @item Close @i{component}
Close the selected item.

     @item Hide all @i{component}
Hide all subcomponents of the selected item. To select a particular field
or item in a record/array, move your mouse over the name of this
component, not over the box containing the values for this item.

     @item Show all @i{component}
Show all subcomponents of the selected item.

     @item Clone @i{component}
Clone the selected component into a new, independant item.

     @item View memory at &@i{component}
Bring up the memory view dialog and explore memory at the address of the 
component.

     @item Set value of @i{component}
Set the value of a selected component. This will open an entry box
where you can enter the new value of a variable/component. Note that
GDB does not perform any type or range checking on the value entered.

     @item Update Value
Refresh the value displayed in the selected item.

     @item Show Value
Show only the value of the item.

     @item Show Type
Show only the type of each field for the item.

     @item Show Value+Type
Show both the value and the type of the item.

@c  Should have screenshot with value + type

     @item Auto refresh
Enable or disable the automatic refreshing of the item upon program execution
(e.g step, next).

   @end table

   A contextual menu can be accessed in the canvas itself (point the mouse to
   an empty area in the canvas, and click on the right mouse button) with the
   following entries:
   @table @b
     @item Display Expression...
      Open a small dialog letting you specify an arbitrary expression
      in the Data Window. This expression can be a variable name, or a
      more complex expression, following the syntax of the current language and
      underlying debugger.
      See the documentation of e.g gdb for more details on the syntax.
      The check button @i{Expression is a subprogram call} should be enabled
      if the expression is actually not an expression but rather a debugger
      command (e.g @code{p/x var}) or a procedure call in the program being
      debugged (e.g @code{call my_proc}).

     @item Align On Grid
Enable or disable alignment of items on the grid.

     @item Detect Aliases
Enable or disable the automatic detection of shared data structures.
Each time you display an item or dereference a pointer, GVD look at all
the items already displayed on the canvas and compares their addresses with
the address of the new item to display. If they match, GVD will not
create a new item, but it will create a link (if you tried to dereference
a pointer).

     @item Zoom in
Redisplay the items in the data window with a bigger font

     @item Zoom out
Display the items in the data window with smaller fonts and pixmaps. This
can be used when you have several items in the window and you can't see all
of them at the same time (for instance if you are displaying a tree and
want to clearly see its structure).

     @item Zoom
This allows you to choose the zoom level directly from a menu.

   @end table

@c --------------------------------------------------------------------
@subsection Manipulating items
@c --------------------------------------------------------------------

@subsubsection Moving items

All the items on the canvas have some common behavior and can be fully
manipulated with the mouse.

They can be moved freely anywhere on the canvas, simply by clicking on
them and then dragging the mouse. Note that if you are trying to move
an item outside of the visible area of the data window, the latter will
be scrolled so as to make the new position visible.

Automatic scrolling is also provided if you move the mouse, while dragging
an item, near the borders of the data window. As long as the mouse
remains close to the border and the button is pressed on the item,
the data window is scrolled and the item is moved. This provides an
easy way to move an item a long distance from its initial position.

@subsubsection Colors

Most of the items are displayed using several colors, each
conveying a special meaning. Here is the description for all the colors
(note that the exact color can be changed through the preferences
dialog; these are the default colors):

@iftex
@image{colors, 10cm}
@end iftex

@table @b

@item black
This is the default color used to print the value of variables or
expressions.

@item blue
This color is used for C pointers (or Ada access values), ie all the variables
and fields that are memory addresses pointing to some other value in
memory.

You can easily dereference these (see the value pointed to) by double-clicking
on the blue text itself.

@item red
This color is used for variables and fields whose value has changed since
the data window was last displayed. For instance, if you display an array
in the data window and then select the @i{Next} button in the toolbar, then
the elements of the array whose value has just changed will appear in red.

As another example, if you choose to display the value of local variables in
the data window (@i{Display->Display Local Variables}), then only the
variables whose value has changed are highlighted, the others are left in
black.

@end table

@subsubsection Icons

Several different icons can be used to in the display of items. They also
convey special meanings.

@table @b

@item trash bin icon
This icon indicates that the debugger could not get the value of the
variable or expression. There might be several reasons, for instance the
variable is currently not in scope (and thus does not exist), or it might
have been optimized away by the compiler. In all cases, GVD will update the
display as soon as the variable becomes visible again.

@item package icon
This icon indicates that part of a complex structure is currently hidden.
Manipulating huge items in the data window (for instance if the variable
is an array of hundreds of complex elements) might not be very helpful. As a
result, GVD gives you the opportunity to shrink part of the value to
save some screen space and make it easier to visualize the interesting parts
of these variables. See @ref{hiding big items} to enable or disable this
facility, and to set the threshold used to hide items automatically.

Double-clicking on this icon will expand the hidden part, and clicking on
any sub-rectangle in the display of the variable will hide that part and
replace it with that icon.

See also the description of the contextual menu to automatically show or hide
all the contents of an item. Note also that one alternative to hidding
subcomponents is to clone them in a separate item (see the contextual menu
again).

@end table


@c --------------------------------------------------------------------
@node The Memory Window
@section The Memory Window
@c --------------------------------------------------------------------

@iftex
@image{memory-view, 12.7cm}
@end iftex

@noindent
The memory window allows you to display the contents of the memory given
either an address, or a variable name.

To display memory contents, enter the address with the C hexadecimal form:
0xabcd,
or the name of a variable, e.g foo in the @i{Location} text entry. In the
latter case, GVD will compute its address automatically. Then either press
@i{Enter} or click on the @i{View} button. This will display the memory with
the corresponding addresses in the bottom text area.

You can also specify the unit size (@i{Byte}, @i{Halfword} or @i{Word}),
the format (@i{Hexadecimal}, @i{Decimal}, @i{Octal} or @i{ASCII}), and you
can display the corresponding ASCII value at the same time.

The @i{up} and @i{down} arrows as well as the @key{Page up} and @key{Page down}
keys in the memory text area allows you to walk through the memory.

Finally, you can modify a memory area by simply clicking on the location
you want to modify, and by entering the new values. Modified values will
appear in a different color (red by default) and will only be taken into
account (i.e written to the target) when you click on the @i{Submit changes}
button. Clicking on the @i{Undo changes} or going up/down in the memory
will undo your editing.

Clicking on @i{Close} will close the memory window, cancelling your last
nonsubmitted changes, if any.

@c --------------------------------------------------------------------
@node The Explorer Window
@section The Explorer Window
@c --------------------------------------------------------------------

@noindent
@iftex
@image{explorer, 6cm}
@end iftex

The explorer window gives a fast access to the files contained in the
module you debug (and that have been compiled with debug information).
Note that you can have multiple entries with the same file name if there
are duplicate file name located at different places (which can either be
different files, e.g @code{/usr/include/signal.h} and
@code{/usr/include/sys/signal.h}, or identical files located in different
source paths).

Each file can be opened (by clicking on the @code{+} icon on the left of
the file name, or double clicking on the file name), giving access to
language sensitive information such as packages, functions, tasks, etc...
You can then open each of these sections and by selecting an item,
the source editor will select and jump to this item.

Note: some items are disabled until an executable is loaded using either the
Open Program, Open Core Dump, or Attach Process menu, or the corresponding
commands in the debugger console.

   Contextual menu:
   @table @b
     @item Hide System Files
Hide the files that are part of the system.
This currently only affects Ada programs compiled with GNAT, and will hide the
GNAT run time files used by the executable.

     @item Reload Files
Recompute the list of files. this is particularly useful when the program
uses shared libraries that are not known until the program references
them.

     @item Delete Files Not Found
Delete the files that cannot be found on the file system. Note that this
operation can take a long time to complete.

     @item Show Current File
Highlight the file containing the current execution point.
   @end table

@c --------------------------------------------------------------------
@node The Source Window
@section The Source Window
@c --------------------------------------------------------------------

@noindent
   The source window is composed of two main areas. The first is a small
   column on the left containing the following information:
   @table @b
     @item Lines with code
In this area, blue dots are shown that represent lines for which the debugger
has debug information, in other words, lines that have been compiled with
debug information and for which the compiler has generated some code.
Currently, GVD does not check whether you try to set a breakpoint on a dotted
line or not, and it will simply send the breakpoint command to the underlying
debugger. This will usually (e.g in the case of gdb) result in setting a
breakpoint in the closest location that matches the file and line that you
specified.
     @item Current line executed
This is a green arrow showing the line about to be executed.

     @item Lines with breakpoints
For lines where breakpoints have been set, a red mark is displayed on top
of the blue dots showing the lines with code. You can add and delete
breakpoints by clicking on this area (the first click will set a breakpoint,
the second click will remove it).
   @end table

@iftex
@image{tooltips, 12.7cm}
@end iftex

   The second area in the source window is a text window on the right that
   displays the source files with syntax highlighting.
   If you leave the cursor over a variable, a tooltip will
   appear showing the value of this variable. Automatic tooltips can be
   disabled in the @ref{preferences menu}.

   The contextual menu of the source window contains the following entries:
   @table @b
     @item Print @i{selection}
Print the selection (or by default the name under the cursor) in the
debugger console.

     @item Display @i{selection}
Display the selection (or by default the name under the cursor) in the
data window. The value will be automatically refreshed each time the process
state changes (e.g after a step or a next command). To freeze the display
in the canvas, you can either click on the corresponding icon in the data
window, or use the contextual menu for the specific item (see
@ref{The Data Window} for more information).

     @item Print @i{selection}.all
Dereference the selection (or by default the name under the cursor) and
print the value in the debugger console.

     @item Display @i{selection}.all
Dereference the selection (or by default the name under the cursor) and
display the value in the data window.

     @item View memory at &@i{selection}
Bring up the memory view dialog and explore memory at the address of the 
selection.

     @item Set Breakpoint on Line @i{xx}
Set a breakpoint on the line under the cursor, in the current file.

     @item Set Breakpoint on @i{selection}
Set a breakpoint at the beginning of the subprogram named @i{selection}

     @item Continue Until Line @i{xx}
Contine execution (the program must have been started previously) until a
specified line.

     @item Show Current Location
Jump to the current line of execution. This is particularly useful after
navigating through your source code.

     @item Display Line Numbers
Enable/Disable the display of line numbers on the left of the source
editor.

     @item Show Lines with Code
Enable/Disable the display of lines with code, as described above.

     @item Show...
A submenu composed of the following options:
     @table @b
        @item Source Code
Show only the source code.

        @item Asm Code
Show only the assembly code around the current execution point.
See @ref{The Assembly Window} for more details.

        @item Asm and Source
Show both the source code and the assembly window at the same time.
     @end table
   @end table

@c --------------------------------------------------------------------
@node The Assembly Window
@section The Assembly Window
@c --------------------------------------------------------------------

It is often convenient to look at the assembly code for the subprogram
or source line you are currently debugging. If the underlying debugger
provides this kind of support (gdb does, but not jdb), then GVD will
fully support that kind of debugging.

You can access the assembly window by right-clicking in the source
window, and select one of the menus "Show Asm Code" or "Show Asm and
Source", the later will allow you to see both the source code and the
matching assembly code.

@iftex
@image{assembly, 12.7cm}
@end iftex

The current assembly instruction is, as usual, highlighted with a green
arrow on its left.  The instructions corresponding to the current source
line are highlighted in red by default. This allows you to easily see
where the program counter will point to once you have pressed the "Next"
button on the toolbar.

Moving to the next assembly instruction is done through the "Nexti"
(next instruction) button in the toolbar. If you choose "Stepi"
instead (step instruction), this will also jump to the subprogram
being called.

For efficiency reasons, GVD will only display a small part of the
assembly code around the current instruction.
You can specify in the @ref{preferences menu} how many instructions
are displayed by default. Also, you can easily
display the instructions immediately preceding or following the
currently displayed instructions by pressing one of the @key{Page up} or
@key{Page down} keys, or by using the contextual menu in the assembly
window.

One feature which is related to debugging at the assembly level is
the display of the value of registers. When the debugger supports it
(as gdb does), you can select the @code{Data->Display Registers} menu
to get an item in the canvas that will show the current value of the
registers, and will be updated every time one of them changes.

You might however choose to look at a single register. Although this is
dependent on the debugger you are currently using, you can do this with
gdb by selecting the @code{Data->Display Any Expression}, entering
something like

@smallexample
output /x $eax
@end smallexample

in the field, and select the toggle button "Expression is a subprogram
call". This will create a new canvas item that will be refreshed every
time the value of the register (in this case eax) changes.

@c --------------------------------------------------------------------
@node The Debugger Console
@section The Debugger Console
@c --------------------------------------------------------------------

@noindent
This is the text window located at the bottom of the main window.
In this console, you have direct access to the underlying debugger,
and can send commands (you need to refer to the underlying debugger's
documentation, but usually typing @i{help} will give you an overview of
the commands available).

If the underlying debugger allows it, pressing the TAB key in this 
window will provide completion for the command that is being typed (or its
arguments).

GVD also adds a number of commands to the debugger to provide a simple
text interface to some of its graphical features. These commands, as documented
below, enable you to create scripts that automatically change the graphical
aspect of GVD. They also permit, through the use of the @code{--tty} command
line option, a better integration of GVD into other integrated environments
and editors like GNU Emacs.

Here is the complete lists of such commands. The arguments between square
brackets are optional and can be omitted.

@table @b
@item graph (print|display) expression [dependent on display_num] [link_name name]
This command creates a new item in the canvas, that shows the value of
@var{Expression}. @var{Expression} should be the name of a variable, or one
of its fields, that is in the current scope for the debugger.

The command @code{graph print} will create a frozen item, that is not
automatically refreshed when the debugger stops, whereas @code{graph display}
displays an automatically refreshed item.

The new item is associated with a number, that is visible in its title bar.
These numbers can be used to create links between the items, using the
second argument to the command, @var{dependent on}. The link itself (ie the
line) can be given a name that is automatically displayed, using the third
argument.

@item graph (print|display) `command`
This command is similar to the one above, except it should be used to
display the result of a debugger command in the canvas.

For instance, if you want to display the value of a variable in hexadecimal
rather than the default decimal with gdb, you should use a command like:

@smallexample
graph display `print /x my_variable`
@end smallexample

This will evaluate the command between back-quotes every time the debugger
stops, and display this in the canvas. The lines that have changed will
be automatically highlighted (in red by default).

This command is the one used by default to display the value of registers
for instance.

@item graph (enable|disable) display display_num [display_num ...]
This command will change the refresh status of items in the canvas. As
explained above, items are associated with a number visible in their title
bar.

Using the @code{graph enable} command will force the item to be automatically
refreshed every time the debugger stops, whereas the @code{graph disable}
command will freeze the item.

@item graph undisplay display_num
This command will remove an item from the canvas

@item view (source|asm|source_asm)
This command indicates what should be displayed in the source window.
The first possible value indicates that only the source code should be visible,
the second one specifies that only the assembly code should be visible,
and the last one indicates that both should be displayed.

@end table


@c --------------------------------------------------------------------
@node The Status Line
@section The Status Line
@c --------------------------------------------------------------------

@noindent
This is the line located at the bottom of the main window. This area
will contain information about events, and errors such as parsing errors.
After a time out (that can be changed in the preferences menu), each
message disappears and is added to the history of messages that can be
accessed using the arrow located at the left of the status line.

@c --------------------------------------------------------------------
@node Integrating GVD
@chapter Integrating GVD
@c --------------------------------------------------------------------

@menu
* General Information::
* Using GVD with Glide::
* Using GVD with Emacs::
* Using GVD with XEmacs::
* Using GVD as a Library::
* Using GVD as a Corba Object::
@end menu

@noindent
@node General Information
@section General Information
     To have GVD run as an inferior in other front-ends, you can either set up
     your debugger front-end such that @i{gvd --tty} is invoked instead of
     the inferior debugger, or use GVD as a library.
     When GVD is invoked using the @i{--tty} option, it enables its TTY
     interface, taking additional debugger commands from standard input and
     forwarding debugger output to standard output, just as if the inferior
     debugger had been invoked directly. All remaining GVD functionalities stay
     unchanged. Note that the @i{--tty} option is currently not supported
     under Windows systems.

     The @i{--tty} option also implies the GDB @i{-fullname} option, when
     GDB is used as the underlying debugger.

     You may also invoke @i{gvd --tty} directly, entering GVD commands from
     your TTY, or use GVD as the end of a pipe, controlled by a remote program.
     Be aware, however, that the TTY interface does not support line editing and
     command completion. Also, do not try to run GVD with GVD as inferior
     debugger.

@node Using GVD with Glide
@section Using GVD with Glide
     Select @i{Ada->Project->Edit Current}, go in the @i{[Ada Menu]}
     section, in the @i{Debugging the application:} field, enter
     @i{gvd --tty $@{main@}}.
     Save. Then launch the debugging session by using the menu
     @i{Ada->Debug}.
     In the source window, you can display variables graphically using the
     contextual menu on top of a variable, or after selecting an expression.
     The display will be done in GVD's canvas window.

@node Using GVD with Emacs
@section Using GVD with Emacs
     Use @i{M-x gdb} to start a debugging session. At the prompt, enter
     @i{gvd --tty} and the name of the program to be debugged. Process as
     usual.

@node Using GVD with XEmacs
@section Using GVD with XEmacs
     In XEmacs 21 and later, select @i{Tools->Debug (GDB)}. At the prompt,
     enter @i{gvd --tty} and the name of the program to be debugged.
     Proceed as usual.

@node Using GVD as a Library
@section Using GVD as a Library
     GVD can also be used as a library. This is still work in
     progress however. The interface provided by GVD to other programs can
     be found in the file gvd-api.ads, and gvd-api.h.
     Note that to integrate GVD code in Ada applications, using the various
     high level packages provided by GVD directly is the recommended way.
     The gvd-api.ads file is provided mainly for integrating GVD in other
     languages. This API is provided as a C API, so that any language that can
     interface with C can use it. For more information, refer directly to
     the gvd-api.ads file.

@node Using GVD as a Corba Object
@section Using GVD as a Corba Object
     Future development plans of GVD include transforming GVD into a Corba
     object, so that it can be used by other applications in any language
     easily, and in particular in the context of the GNOME framework.

@c --------------------------------------------------------------------
@node Debugging a program remotely
@chapter Debugging a program remotely
@c --------------------------------------------------------------------

@menu
* Using GVD with a Remote Debugger::
* Using GVD with a Remote Program::
@end menu

@noindent
It is possible to have the inferior debugger run on a remote host. This is
useful when the remote host has a slow network connection or when GVD is
available on the local host only.

Furthermore, the inferior debugger may support debugging a program on a remote
host. This is useful when the inferior debugger is not available on the remote
host - for instance, because the remote system does not have a general purpose
operating system powerful enough to run a full featured debugger. When
developing in a cross environment (e.g VxWorks, Lynx OS), you will be in such
situation.

@node Using GVD with a Remote Debugger
@section Using GVD with a Remote Debugger
To debug a program running on a remote machine you have two main options:
either run GVD on the remote machine, using the remote capabilities of the X
windowing system;
or run GVD on the host machine, and run the underlying debugger on the remote
machine.

For the first option, open a shell on the remote machine (using e.g
telnet or rlogin), simply set the DISPLAY environment variable to the
value of your local display, and launch gvd from your remote machine.
For example, assuming your local machine is called @i{local}, and your display
is the default display @i{local:0}, your remote machine is called @i{remote}.
you can do the following (assuming you are using an sh-like shell):

@smallexample
$ rlogin remote
$ DISPLAY=local:0
$ export DISPLAY
$ gvd
@end smallexample

You also need to ensure that @i{remote} is allowed to access @i{local:0} by
e.g using the xhost utility under Unix.

For the second option, gvd will internally use the standard @i{rsh} and
@i{rcp} utilities. These are standard tools available under all Unix systems and
under Windows NT/2000 as well.

First make sure that rsh/rcp can be used from your local to your remote machine
without having to enter a password. This is usually done via the configuration
of a @i{.rhosts} file in your remote home directory that will typically look
like:

@smallexample
local user-name
@end smallexample

local is the name of the local machine you want to rlogin from, and the .rhosts
file needs to be present in the home directory on the remote machine.

To check whether you can use gvd in remote mode, try the following using a
shell window on your local machine:

@smallexample
$ rsh remote gdb
@end smallexample

This should launch gdb on the remote machine.

Note that on some systems, rsh is called differently, in particular under
HPUX, the remote shell capability is called remsh. For those systems, and
also in order to use other remote utilities such as ssh/scp, you can change
the default remote shell and copy by using the @ref{helpers menu}.

After ensuring that you have the proper setup in place, to run the debugger on
a remote host @i{remote}, either invoke GVD as

@smallexample
gvd --host 'remote' remote-program
@end smallexample

or use the @i{File->New Debugger...} menu in GVD.

There are a few caveats in remote mode:

  The remote debugger is started in your remote home directory. Hence, you must
  specify an absolute path name for @i{remote-program} (or a path name relative
  to your remote home directory). The same applies to remote core files.
  Also, be sure to specify a remote process id when debugging a running program.

  To access files remotely, gvd will first try to read the files locally,
  assuming that you have the remote files mounted locally at the same
  location (using e.g nfs+symbolic links, or samba), and if it cannot find the
  files locally, it will then try to copy the file from the remote machine,
  using rcp. As for rsh, you need to make sure that rcp can be called without
  having to enter a password, and you can also replace rcp by similar remote
  copy utilities such as scp. Note that the file
  selection dialogs (change directory, open file, @dots{}) will scan the local
  directory, so you will need to know in advance the complete path if your
  remote files are not mounted on your local host.

@node Using GVD with a Remote Program
@section Using GVD with a Remote Program

  The GDB debugger allows you to run the @i{debugger program} on a remote
  machine (called @i{program host}) while GDB runs on the local machine.

  The section @i{Remote debugging} in the GDB documentation contains all the
  details. Basically, the following steps are required:

  Transfer the executable to the remote target.

  Optionally start gdbserver on the remote target (e.g under Lynx OS). This
    is not needed for environments such as VxWorks.

  Start GVD using a properly configured cross GDB, e.g powerpc-wrs-vxworks-gdb
  for a gdb configured for VxWorks PowerPC and specify the name of the remote
  target, as well as the protocol used to communicate with it. To specify
  the cross gdb and the remote target, you can use either the --debugger and
  --target command line options, e.g:

@smallexample
gvd --debugger powerpc-wrs-vxworks-gdb --target my_target:wtx
@end smallexample

  or using the @i{Debugger Name}, @i{Program Host} and @i{Protocol} entries in
  the @i{File->New Debugger} menu item.

@iftex
@image{process, 12.7cm}
@end iftex

You can also combine GVD remote mode and GDB remote mode, running
GVD, GDB and the debugged program each on a different machine.

@c --------------------------------------------------------------------
@node Environment
@chapter Environment
@c --------------------------------------------------------------------

@menu
* Command Line Options::
* Environment Variables::
* Files::
* Limitations::
* Reporting bugs::
@end menu

@node Command Line Options
@section Command Line Options

@smallexample
Usage:
   gvd [options...] executable-file
       [--dargs [debugger options]] [--pargs [program options]]
@end smallexample

@noindent
The options recognized by GVD are:

@table @b
@item --debugger DEBUG
use DEBUG as the underlying debugger.

@item --jdb
assume a Java debugger. This option is currently not fully supported.

@item --host HOST
Run inferior debugger on HOST. See
@ref{Using GVD with a Remote Debugger} for more information.

@item --target TARG:PRO
Load program on machine TARG using protocol PRO.
Note that TARG can contain the @code{:} character for e.g specifying the
port number. The last colon will be used by GVD as the separator between
the target and the protocol. For instance, assuming you want to connect
to a board named @i{bare} on port 1234 using the @i{remote} protocol, you
would specify:

@smallexample
gvd --target bare:1234:remote
@end smallexample

See @ref{Using GVD with a Remote Program} for more information.

@item --log-level [0-4]
Set level of logging (Default is 3).
This option can be useful when reporting bugs in GVD, in which case the
maximum level of logs (4) gives more details, but will also generate
more disk activity, which can slow down GVD significantly if the
log file is located through a network disk.

@item --editor-window=xid
Use xid as the editor X window id.
GVD takes advantage of this option by integrating the specified window
as the source editor.
This option is not currently supported under Windows.

@item --tty
Use controlling tty as the debugger console.
This option is very useful for integrating GVD in other debugger front-ends
(e.g Emacs), since in this mode, GVD appears as the underlying debugger to
the caller. See @ref{Integrating GVD} for more details.
This option is not currently supported under Windows.

@item --version
Show the GVD version and exit.

@end table

@noindent
The @code{--dargs} section let you specify an arbitrary number of options
to pass to the underlying debugger.

@noindent
Similarly, the @code{--pargs} section let you specify options to pass to the
debugged program.

@noindent
For example, if you want to pass the @code{--nx} option to gdb, and the
options @code{--file foo --version} to the debugged program @code{my_code}
you would launch GVD as follows:

@smallexample
gvd my_code --dargs --nx --pargs --file foo --version
@end smallexample

@c --------------------------------------------------------------------
@node Environment Variables
@section Environment Variables
@c --------------------------------------------------------------------

@noindent
The following environment variables can be set to override some default
settings in GVD:

@table @samp
   @item GVD_ROOT.
Override the default root directory specified when GVD
is built (during the @i{configure} process, see the file @code{INSTALL} in
the GVD sources for more details) to access information such as the location
of the translation files.

   @item GVD_HOME.
Override the variable HOME if present. All the configuration files and
directories used by GVD are either relative to $HOME/.gvd (%HOME%\.gvd under
Windows) if GVD_HOME is not set, or to $GVD_HOME/.gvd (respectively
%GVD_HOME%\.gvd) if set.

   @item GVD_EDITOR.
@anchor{GVD_EDITOR}
Override the default editor as found in the @ref{helpers menu}.

@end table

@c --------------------------------------------------------------------
@node Files
@section Files
@c --------------------------------------------------------------------

@noindent

@table @file
   @item $HOME/.gvd
GVD state directory
   @item $HOME/.gvd/log
@anchor{log file}
Log file created automatically by GVD. This log file contains all the input
and output exchanged between GVD and the underlying debugger. You can
specify the level of logs (from no log to very verbose) by using the
@code{--log-level} command line option. Using a high level of log can be
useful to track communication problems between GVD and the underlying debugger,
but will slow down GVD if $HOME is located on a network disk.

   @item $HOME/.gvd/preferences
Contains all the preferences in XML format, as specified in the
@ref{preferences menu}.

   @item $HOME/.gvd/window_settings
Contains all the settings of the windows (window sizes, pane
offset) in XML format. These settings are saved automatically when quitting
GVD, and loaded automatically at start up. To reset the settings, simply
remove this file.

   @item $HOME/.gvd/sessions
Directory containing the GVD sessions.

   @item $HOME/.gvd/sessions/@i{session}
Each file in the @code{sessions} directory represents a particular session
saved by the user.

   @item $HOME/.gdbinit   GDB initialization file
@end table

@c --------------------------------------------------------------------
@node Limitations
@section Limitations
@c --------------------------------------------------------------------

@menu
* General Limitations::
* Limitations using GDB::
@end menu

@noindent
@node General Limitations
@subsection General Limitations
@noindent
     If command output is sent to the debugger console, it is impossible for GVD
     to distinguish between the output of the debugged program and the output
     of the inferior debugger. This problem can be avoided by running the
     program in the separate execution window.

     Output that confuses GVD includes:

     @itemize @bullet
       @item Primary debugger prompts (e.g '(gdb) ')
       @item Secondary debugger prompts (e.g '>')
       @item Confirmation prompts (e.g '(y or n)')
     @end itemize

     If your program outputs any of these strings, you should run it in the
     separate execution window.

     If the inferior debugger changes the default TTY settings, for instance
     through a @i{stty} command in its initialization file, GVD will likely
     become confused. The same applies to debugged program which change the
     default TTY settings.

@node Limitations using GDB
@subsection Limitations using GDB
@noindent
     Some GDB settings are essential for GVD to work correctly. These settings
     with their correct values are:

     @itemize @bullet
     @item set height 0
     @item set width 0
     @item set verbose off
     @item set prompt (gdb) 
     @end itemize

     GVD sets these values automatically when invoking GDB; if these values
     are changed, there may be some malfunctions, especially in the data
     display.

@c --------------------------------------------------------------------
@node Reporting bugs
@section Reporting bugs
@c --------------------------------------------------------------------

@noindent
If you encounter a bug in GVD, you can report it to
@uref{mailto:report@@gnat.com} if you are a supported user (to become a
supported user, contact @uref{mailto:sales@@gnat.com}), or to the
public gvd development list (@uref{mailto:gvd-devel@@lists.act-europe.fr}).

Please try to include a detailed description of the problem, including
sources to reproduce it if possible, and/or a scenario describing the
actions performed to reproduce the problem. Saving your session and
the log file (see @ref{log file}) can help automate this process.

@c @printindex cp

@contents

@bye
